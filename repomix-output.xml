This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  settings.local.json
docs/
  experiment-management-api.md
  inject-positions.md
  PIPELINE.md
  SELECTOR_GENERATION_FLOW.md
  TEST_VARIANTS.md
prisma/
  migrations/
    20250929070921_init/
      migration.sql
    20251001081017_add_markdown_to_screenshots/
      migration.sql
    20251004092856_add_analytics_events/
      migration.sql
    20251004132504_add_better_auth_tables/
      migration.sql
    20251004133400_remove_firstname_lastname_columns/
      migration.sql
    20251004192836_add_event_types_enum/
      migration.sql
    20251004202510_add_url_targeting_to_experiments/
      migration.sql
    20251005132159_add_append_prepend_positions/
      migration.sql
    20251005155025_add_store_type/
      migration.sql
    20251006103959_add_js_to_variants/
      migration.sql
    20251006112713_add_purchase_event_type/
      migration.sql
    20251006151506_add_targeting_to_experiment/
      migration.sql
    migration_lock.toml
  schema.prisma
src/
  app/
    container.ts
    server.ts
  domain/
    agent/
      tools/
        check-variants.ts
        create-experiment.ts
        generate-hypotheses.ts
        generate-variants.ts
        get-brand-analysis.ts
        get-brand-sources.ts
        get-experiment-overview.ts
        get-project-info.ts
        index.ts
        preview-experiment.ts
        schemas.ts
      agent.ts
      experiment-state-manager.ts
      hypothesis-state-manager.ts
      index.ts
      prompts.ts
      types.ts
      variant-state-manager.ts
    analytics/
      analytics-service.ts
      index.ts
      types.ts
  features/
    brand_analysis/
      brand-analysis.ts
      firecrawl-service.ts
      index.ts
      prompts.ts
      types.ts
      url-selector.ts
    conflict_guard/
      index.ts
    crawler/
      index.ts
      playwright.ts
      types.ts
    hypotheses_generation/
      hypotheses-generation.ts
      types.ts
    variant_generation/
      code-generator.ts
      css-path-generator.ts
      design-system-extractor.ts
      dom-analyzer.ts
      element-detector.ts
      hypothesis-aware-selector.ts
      prompts.ts
      selector-generator.ts
      smart-screenshot-strategy.ts
      types.ts
      variant-generation.ts
      variant-improvement.ts
      visual-refinement.ts
  infra/
    config/
      auth0.ts
      langsmith.ts
      services.ts
    dal/
      analytics.ts
      chat-message.ts
      experiment.ts
      index.ts
      project.ts
      screenshot.ts
      types.ts
      user.ts
      variant-job.ts
    external/
      auth0/
        auth0.ts
        index.ts
      cloudflare/
        cloudflare-publisher.ts
        index.ts
        types.ts
      posthog/
        config.ts
        index.ts
        service.ts
        types.ts
      shopify/
        config.ts
        graphql.ts
        index.ts
        oauth.ts
        README.md
        service.ts
    auth.ts
    encryption.ts
    errors.ts
    prisma.ts
  interfaces/
    http/
      analytics/
        handlers.ts
        index.ts
        schemas.ts
      auth/
        index.ts
      experiment/
        index.ts
      middleware/
        authorization.ts
        better-auth.ts
        validation.ts
      plugins/
        better-auth-plugin.ts
      project/
        brandSummary.ts
        jobs.ts
        reset.ts
      schemas/
        chat.schema.ts
      user/
        index.ts
        schemas.ts
      utils/
        chat-utils.ts
      chat.ts
      health.ts
      index.ts
      screenshots.ts
      shopify.ts
  services/
    analytics.ts
    background-services.ts
    experiment-publisher.ts
    index.ts
    job-cleanup.ts
    project-info.ts
    screenshot-analytics.ts
    screenshot-storage.ts
    variant-job-processor.ts
  shared/
    normalization/
      url.ts
    utils/
      html-simplifier.ts
      url-utils.ts
    validation/
      sanitizers/
        css.sanitizer.ts
        html.sanitizer.ts
      schemas/
        experiment.schema.ts
      index.ts
      validator.ts
    ai-config.ts
    demo-config.ts
    fastify.d.ts
    screenshot-config.ts
    types.ts
  index.ts
  test-variant-pipeline.ts
test-output/
  variant-js-2025-10-07T13-17-23-078Z.js
  variant-test-2025-10-07T13-17-23-078Z.json
tests/
  integration/
    variant-pipeline.test.ts
    variant-simple.test.ts
.dockerignore
.gitignore
AGENTS.md
app.json
check-experiment-status.ts
docker-compose.prod.yml
docker-compose.yml
Dockerfile
Dockerfile.prod
env.template
eslint.config.js
package.json
Procfile
test-variant-feedback.ts
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(npx eslint:*)"
    ],
    "deny": [],
    "ask": []
  }
}
</file>

<file path="src/infra/config/auth0.ts">
/**
 * Auth0 Configuration
 * 
 * Environment variables required:
 * - AUTH0_DOMAIN: Your Auth0 tenant domain (e.g., "your-tenant.auth0.com")
 * - AUTH0_AUDIENCE: Your API identifier from Auth0 dashboard
 * - AUTH0_ISSUER: Usually "https://{AUTH0_DOMAIN}/"
 */

export const auth0Config = {
  domain: process.env.AUTH0_DOMAIN!,
  audience: process.env.AUTH0_AUDIENCE!,
  issuer: process.env.AUTH0_ISSUER!,
  jwksUri: `https://${process.env.AUTH0_DOMAIN}/.well-known/jwks.json`,
};

// Validate required environment variables
const requiredEnvVars = ['AUTH0_DOMAIN', 'AUTH0_AUDIENCE', 'AUTH0_ISSUER'];
const missingVars = requiredEnvVars.filter(varName => !process.env[varName]);

if (missingVars.length > 0) {
  throw new Error(`Missing required environment variables: ${missingVars.join(', ')}`);
}
</file>

<file path="src/infra/external/shopify/README.md">
# Shopify External Service

This module handles all Shopify-related functionality including OAuth flow, API calls, and shop profile management.

## Files

- **`config.ts`**: Shopify API configuration and environment variable validation
- **`service.ts`**: Main Shopify service with API methods and utilities
- **`index.ts`**: Clean exports for the service and types

## Features

### OAuth Flow
- Generate OAuth URLs for store authorization
- Handle OAuth callbacks with HMAC validation
- Exchange authorization codes for access tokens

### Shop Management
- Fetch shop profile information
- Validate and normalize shop domains
- Store encrypted access tokens

### API Integration
- Shopify Admin API integration
- Error handling for API failures
- Type-safe API responses

## Usage

```typescript
import { shopify, shopifyConfig } from '@infra/external/shopify';

// Generate OAuth URL
const oauthUrl = shopify.generateOAuthUrl('shop-name.myshopify.com', state);

// Exchange code for token
const tokenResponse = await shopify.exchangeCodeForToken(shop, code);

// Fetch shop profile
const shopProfile = await shopify.getShopProfile(shop, accessToken);
```

## Configuration

Required environment variables:
- `SHOPIFY_API_KEY`: Shopify app API key
- `SHOPIFY_API_SECRET`: Shopify app secret
- `SHOPIFY_SCOPES`: Required permissions (comma-separated)
- `SHOPIFY_REDIRECT_URI`: OAuth callback URL
- `ENCRYPTION_KEY`: 32-character encryption key for token storage
</file>

<file path="src/infra/encryption.ts">
import crypto from 'crypto';
import { shopifyConfig } from './external/shopify/config';

/**
 * Encryption utilities for sensitive data like Shopify access tokens
 */

const ALGORITHM = 'aes-256-gcm';
const IV_LENGTH = 16; // For GCM, this is always 16
const SALT_LENGTH = 64;
const TAG_LENGTH = 16;

/**
 * Encrypt a string using AES-256-GCM
 */
export function encrypt(text: string): string {
  const iv = crypto.randomBytes(IV_LENGTH);
  const salt = crypto.randomBytes(SALT_LENGTH);
  
  // Derive key from password and salt
  const key = crypto.pbkdf2Sync(shopifyConfig.encryptionKey, salt, 100000, 32, 'sha512');
  
  const cipher = crypto.createCipheriv(ALGORITHM, key, iv);
  cipher.setAAD(salt);
  
  let encrypted = cipher.update(text, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  
  const tag = cipher.getAuthTag();
  
  // Combine salt + iv + tag + encrypted data
  const combined = Buffer.concat([salt, iv, tag, Buffer.from(encrypted, 'hex')]);
  
  return combined.toString('base64');
}

/**
 * Decrypt a string using AES-256-GCM
 */
export function decrypt(encryptedData: string): string {
  const combined = Buffer.from(encryptedData, 'base64');
  
  // Extract components
  const salt = combined.subarray(0, SALT_LENGTH);
  const iv = combined.subarray(SALT_LENGTH, SALT_LENGTH + IV_LENGTH);
  const tag = combined.subarray(SALT_LENGTH + IV_LENGTH, SALT_LENGTH + IV_LENGTH + TAG_LENGTH);
  const encrypted = combined.subarray(SALT_LENGTH + IV_LENGTH + TAG_LENGTH);
  
  // Derive key from password and salt
  const key = crypto.pbkdf2Sync(shopifyConfig.encryptionKey, salt, 100000, 32, 'sha512');
  
  const decipher = crypto.createDecipheriv(ALGORITHM, key, iv);
  decipher.setAAD(salt);
  decipher.setAuthTag(tag);
  
  let decrypted = decipher.update(encrypted, undefined, 'utf8');
  decrypted += decipher.final('utf8');
  
  return decrypted;
}

/**
 * Generate HMAC for Shopify OAuth verification
 */
export function generateHmac(queryString: string, secret: string): string {
  return crypto
    .createHmac('sha256', secret)
    .update(queryString)
    .digest('hex');
}

/**
 * Verify HMAC for Shopify OAuth
 */
export function verifyHmac(queryString: string, secret: string, hmac: string): boolean {
  const expectedHmac = generateHmac(queryString, secret);
  return crypto.timingSafeEqual(Buffer.from(hmac, 'hex'), Buffer.from(expectedHmac, 'hex'));
}
</file>

<file path="src/infra/prisma.ts">
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma = globalForPrisma.prisma ?? new PrismaClient();

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;
</file>

<file path="src/interfaces/http/health.ts">
import type { FastifyInstance } from 'fastify/types/instance.js';
import type { FastifyRequest, FastifyReply } from 'fastify';
import { prisma } from '@infra/prisma';

export async function healthRoutes(fastify: FastifyInstance) {
    // Health check route (public)
    fastify.get('/healthz', async (_request: FastifyRequest, _reply: FastifyReply) => {
        return { ok: true };
    });

    // Database health check route (public)
    fastify.get('/healthz/db', async (_request: FastifyRequest, _reply: FastifyReply) => {
        try {
            await prisma.$queryRaw`SELECT 1`;
            return { ok: true, database: 'connected' };
        } catch (error) {
            fastify.log.error(error);
            return { ok: false, database: 'disconnected' };
        }
    });
}
</file>

<file path="src/shared/validation/sanitizers/css.sanitizer.ts">
/**
 * CSS Sanitizer
 * 
 * CSS validation and sanitization with regex-based approach
 * Lightweight and secure validation for experiment variants
 */

export interface CSSSanitizationResult {
  isValid: boolean;
  sanitizedCSS: string;
  errors: string[];
}

// Allowed CSS properties (subset for safety)
const ALLOWED_CSS_PROPERTIES = new Set([
  // Layout
  'display', 'position', 'top', 'right', 'bottom', 'left', 'z-index',
  'float', 'clear', 'overflow', 'overflow-x', 'overflow-y',
  'width', 'height', 'max-width', 'max-height', 'min-width', 'min-height',
  'margin', 'margin-top', 'margin-right', 'margin-bottom', 'margin-left',
  'padding', 'padding-top', 'padding-right', 'padding-bottom', 'padding-left',
  'border', 'border-width', 'border-style', 'border-color',
  'border-top', 'border-right', 'border-bottom', 'border-left',
  'border-radius', 'box-shadow', 'box-sizing',
  
  // Typography
  'font-family', 'font-size', 'font-weight', 'font-style', 'font-variant',
  'line-height', 'text-align', 'text-decoration', 'text-transform',
  'text-shadow', 'letter-spacing', 'word-spacing', 'white-space',
  'text-overflow', 'word-wrap', 'word-break',
  
  // Colors and backgrounds
  'color', 'background-color', 'background-image', 'background-position',
  'background-repeat', 'background-size', 'background-attachment',
  'opacity', 'visibility',
  
  // Flexbox
  'flex', 'flex-direction', 'flex-wrap', 'flex-flow', 'justify-content',
  'align-items', 'align-content', 'align-self', 'flex-grow', 'flex-shrink',
  'flex-basis', 'order',
  
  // Grid (basic)
  'grid', 'grid-template-columns', 'grid-template-rows', 'grid-template-areas',
  'grid-gap', 'grid-column-gap', 'grid-row-gap', 'justify-items', 'align-items',
  'grid-column', 'grid-row', 'grid-area',
  
  // Transitions and animations (basic)
  'transition', 'transition-property', 'transition-duration', 'transition-timing-function',
  'animation', 'animation-name', 'animation-duration', 'animation-timing-function',
  'animation-delay', 'animation-iteration-count', 'animation-direction',
  
  // Transform (basic)
  'transform', 'transform-origin',
  
  // Other safe properties
  'cursor', 'user-select', 'pointer-events', 'resize', 'outline', 'outline-width',
  'outline-style', 'outline-color', 'outline-offset'
]);

// Forbidden CSS properties
const FORBIDDEN_CSS_PROPERTIES = new Set([
  'behavior', 'expression', 'javascript:', 'vbscript:', 'mso-', '-moz-binding',
  'content', 'counter-reset', 'counter-increment', 'quotes'
]);

/**
 * Sanitizes CSS content for experiment variants
 */
export async function sanitizeCSS(css: string): Promise<CSSSanitizationResult> {
  const errors: string[] = [];

  try {
    // Check size limit first
    const sizeKB = Buffer.byteLength(css, 'utf8') / 1024;
    if (sizeKB > 10) {
      errors.push(`CSS content exceeds 10KB limit. Current size: ${sizeKB.toFixed(2)}KB`);
      return { isValid: false, sanitizedCSS: '', errors };
    }

    // Check for @import statements
    if (css.includes('@import')) {
      errors.push('@import statements are not allowed');
      return { isValid: false, sanitizedCSS: '', errors };
    }

    // Check for @font-face
    if (css.includes('@font-face')) {
      errors.push('@font-face is not allowed in MVP');
      return { isValid: false, sanitizedCSS: '', errors };
    }

    // Check for dangerous functions
    const dangerousFunctions = ['javascript:', 'vbscript:', 'expression(', 'url(javascript:', 'url(vbscript:'];
    for (const func of dangerousFunctions) {
      if (css.toLowerCase().includes(func.toLowerCase())) {
        errors.push(`Dangerous CSS function found: ${func}`);
        return { isValid: false, sanitizedCSS: '', errors };
      }
    }

    // Check for forbidden properties
    for (const prop of FORBIDDEN_CSS_PROPERTIES) {
      const regex = new RegExp(`\\b${prop.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\s*:`, 'gi');
      if (regex.test(css)) {
        errors.push(`Forbidden CSS property found: ${prop}`);
        return { isValid: false, sanitizedCSS: '', errors };
      }
    }

    // Validate that all selectors start with .omen-
    const selectorRegex = /([^{}]+)\s*{/g;
    let match;
    while ((match = selectorRegex.exec(css)) !== null) {
      const selector = match[1].trim();
      if (selector && !selector.includes('.omen-')) {
        errors.push(`CSS selector must include .omen- prefix: ${selector}`);
        return { isValid: false, sanitizedCSS: '', errors };
      }
    }

    // Basic property validation
    const propertyRegex = /([a-zA-Z-]+)\s*:/g;
    while ((match = propertyRegex.exec(css)) !== null) {
      const property = match[1].toLowerCase();
      if (!ALLOWED_CSS_PROPERTIES.has(property) && !property.startsWith('--')) {
        errors.push(`Unallowed CSS property: ${property}`);
        return { isValid: false, sanitizedCSS: '', errors };
      }
    }

    return {
      isValid: errors.length === 0,
      sanitizedCSS: css,
      errors: []
    };

  } catch (error) {
    errors.push(`CSS sanitization error: ${error instanceof Error ? error.message : 'Unknown error'}`);
    return { isValid: false, sanitizedCSS: '', errors };
  }
}

/**
 * Validates CSS content size
 */
export function validateCSSSize(css: string, maxSizeKB: number = 10): boolean {
  const sizeKB = Buffer.byteLength(css, 'utf8') / 1024;
  return sizeKB <= maxSizeKB;
}

/**
 * Gets CSS content size in KB
 */
export function getCSSSizeKB(css: string): number {
  return Buffer.byteLength(css, 'utf8') / 1024;
}

/**
 * Validates that all CSS selectors are properly namespaced with .omen-
 */
export async function validateCSSNamespace(css: string): Promise<boolean> {
  try {
    const selectorRegex = /([^{}]+)\s*{/g;
    let match;
    while ((match = selectorRegex.exec(css)) !== null) {
      const selector = match[1].trim();
      if (selector && !selector.includes('.omen-')) {
        return false; // Found non-namespaced selector
      }
    }
    return true;
  } catch {
    return false;
  }
}
</file>

<file path="src/shared/validation/sanitizers/html.sanitizer.ts">
/**
 * HTML Sanitizer using DOMPurify
 * 
 * Professional HTML sanitization with configurable rules
 */

import DOMPurify from 'dompurify';
import { JSDOM } from 'jsdom';

// Create a JSDOM instance for server-side DOMPurify
const window = new JSDOM('').window;
const purify = DOMPurify(window as any);

export interface HTMLSanitizationResult {
  isValid: boolean;
  sanitizedHTML: string;
  errors: string[];
}

// DOMPurify configuration for experiment variants
const SANITIZE_CONFIG = {
  ALLOWED_TAGS: [
    'div', 'span', 'p', 'strong', 'em', 'b', 'i', 'u', 'small',
    'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
    'ul', 'ol', 'li',
    'a', 'button', 'img',
    'br', 'hr',
    'section', 'article', 'header', 'footer', 'main', 'aside',
    'nav', 'figure', 'figcaption',
    'blockquote', 'cite', 'q',
    'code', 'pre', 'kbd', 'samp',
    'mark', 'del', 'ins', 'sub', 'sup',
    'time', 'address'
  ],
  ALLOWED_ATTR: [
    'class', 'id', 'style', 'title', 'lang', 'dir',
    'href', 'target', 'rel', 'type', 'role', 'aria-label', 'aria-labelledby',
    'src', 'alt', 'width', 'height', 'loading',
    'data-*' // Allow data attributes
  ],
  FORBID_ATTR: [
    'onload', 'onunload', 'onclick', 'ondblclick', 'onmousedown', 'onmouseup',
    'onmouseover', 'onmousemove', 'onmouseout', 'onfocus', 'onblur', 'onkeypress',
    'onkeydown', 'onkeyup', 'onsubmit', 'onreset', 'onselect', 'onchange',
    'onabort', 'onerror', 'onresize', 'onscroll', 'onbeforeunload', 'onunload',
    'srcdoc'
  ],
  FORBID_TAGS: [
    'script', 'iframe', 'object', 'embed', 'style', 'link', 'meta',
    'form', 'input', 'textarea', 'select', 'option',
    'canvas', 'svg', 'video', 'audio', 'source', 'track',
    'applet', 'base', 'frame', 'frameset', 'noframes'
  ],
  ALLOWED_URI_REGEXP: /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i,
  ALLOW_DATA_ATTR: true,
  SANITIZE_DOM: true,
  KEEP_CONTENT: true,
  RETURN_DOM: false,
  RETURN_DOM_FRAGMENT: false,
  RETURN_DOM_IMPORT: false
};

/**
 * Sanitizes HTML content for experiment variants
 */
export function sanitizeHTML(html: string): HTMLSanitizationResult {
  const errors: string[] = [];

  try {
    // Check size limit first
    const sizeKB = Buffer.byteLength(html, 'utf8') / 1024;
    if (sizeKB > 5) {
      errors.push(`HTML content exceeds 5KB limit. Current size: ${sizeKB.toFixed(2)}KB`);
      return { isValid: false, sanitizedHTML: '', errors };
    }

    // Sanitize with DOMPurify
    const sanitized = purify.sanitize(html, SANITIZE_CONFIG);

    // Check if anything was removed (indicates unsafe content)
    if (sanitized !== html) {
      // This is actually fine - DOMPurify removed unsafe content
      // We'll log it but not treat it as an error
      console.log('DOMPurify sanitized HTML content');
    }

    // Additional checks for specific dangerous patterns
    if (html.includes('javascript:') || html.includes('vbscript:') || html.includes('data:')) {
      errors.push('Dangerous protocols found in HTML content');
      return { isValid: false, sanitizedHTML: '', errors };
    }

    return {
      isValid: errors.length === 0,
      sanitizedHTML: sanitized,
      errors
    };

  } catch (error) {
    errors.push(`HTML sanitization error: ${error instanceof Error ? error.message : 'Unknown error'}`);
    return { isValid: false, sanitizedHTML: '', errors };
  }
}

/**
 * Validates HTML content size
 */
export function validateHTMLSize(html: string, maxSizeKB: number = 5): boolean {
  const sizeKB = Buffer.byteLength(html, 'utf8') / 1024;
  return sizeKB <= maxSizeKB;
}

/**
 * Gets HTML content size in KB
 */
export function getHTMLSizeKB(html: string): number {
  return Buffer.byteLength(html, 'utf8') / 1024;
}
</file>

<file path="src/shared/validation/index.ts">
/**
 * Validation Module Exports
 * 
 * Centralized exports for all validation utilities
 */

export * from './validator.js';
export * from './schemas/experiment.schema.js';
export * from './sanitizers/html.sanitizer.js';
export * from './sanitizers/css.sanitizer.js';
</file>

<file path="src/shared/validation/validator.ts">
/**
 * Main DSL Validator
 * 
 * Orchestrates validation using Zod schemas and sanitizers
 */

import { ExperimentDSLSchema, type ExperimentDSL } from './schemas/experiment.schema.js';
import { sanitizeHTML } from './sanitizers/html.sanitizer.js';
import { sanitizeCSS } from './sanitizers/css.sanitizer.js';

export interface ValidationResult {
  isValid: boolean;
  errors: ValidationError[];
}

export interface ValidationError {
  code: string;
  message: string;
  field?: string;
  details?: unknown;
}

// Unsafe selectors for outer position
const UNSAFE_OUTER_SELECTORS = [
  'form', 'input', 'textarea', 'select', 'button[type="submit"]',
  '[id*="checkout"]', '[id*="payment"]', '[id*="billing"]',
  '[id*="shipping"]', '[id*="address"]', '[id*="credit"]',
  '[id*="card"]', '[id*="cvv"]', '[id*="cvc"]'
];

/**
 * Validates an experiment DSL
 */
export async function validateExperimentDSL(dsl: unknown): Promise<ValidationResult> {
  const errors: ValidationError[] = [];

  try {
    // 1. Schema validation with Zod
    const schemaResult = ExperimentDSLSchema.safeParse(dsl);
    if (!schemaResult.success) {
      const zodErrors = schemaResult.error.issues.map((err) => ({
        code: 'INVALID_DSL_STRUCTURE',
        message: err.message,
        field: err.path.join('.'),
        details: err
      }));
      return { isValid: false, errors: zodErrors };
    }

    const experiment = schemaResult.data;

    // 2. Additional safety checks
    await validateSafetyRules(experiment, errors);
    if (errors.length > 0) return { isValid: false, errors };

    // 3. HTML sanitization
    await validateHTMLContent(experiment, errors);
    if (errors.length > 0) return { isValid: false, errors };

    // 4. CSS sanitization
    await validateCSSContent(experiment, errors);
    if (errors.length > 0) return { isValid: false, errors };

  } catch (error) {
    errors.push({
      code: 'VALIDATION_ERROR',
      message: `Validation error: ${error instanceof Error ? error.message : 'Unknown error'}`,
      details: error
    });
  }

  return {
    isValid: errors.length === 0,
    errors
  };
}

/**
 * Validates safety rules
 */
async function validateSafetyRules(experiment: ExperimentDSL, errors: ValidationError[]): Promise<void> {
  for (const target of experiment.targets) {
    for (const [variantId, variant] of Object.entries(target.variants)) {
      // Check for unsafe outer targets
      if (variant.render.position === 'outer' && isUnsafeOuterTarget(target.selector)) {
        errors.push({
          code: 'UNSAFE_OUTER_TARGET',
          message: `Outer position not allowed for critical elements: ${target.selector}`,
          field: `targets.${experiment.targets.indexOf(target)}.variants.${variantId}.render.position`
        });
      }
    }
  }
}

/**
 * Validates HTML content
 */
async function validateHTMLContent(experiment: ExperimentDSL, errors: ValidationError[]): Promise<void> {
  for (const target of experiment.targets) {
    for (const [variantId, variant] of Object.entries(target.variants)) {
      const htmlResult = sanitizeHTML(variant.render.html);
      if (!htmlResult.isValid) {
        errors.push({
          code: 'UNSAFE_HTML',
          message: `Unsafe HTML content: ${htmlResult.errors.join(', ')}`,
          field: `targets.${experiment.targets.indexOf(target)}.variants.${variantId}.render.html`,
          details: htmlResult.errors
        });
      }
    }
  }
}

/**
 * Validates CSS content
 */
async function validateCSSContent(experiment: ExperimentDSL, errors: ValidationError[]): Promise<void> {
  for (const target of experiment.targets) {
    for (const [variantId, variant] of Object.entries(target.variants)) {
      if (variant.render.css) {
        const cssResult = await sanitizeCSS(variant.render.css);
        if (!cssResult.isValid) {
          errors.push({
            code: 'UNSCOPED_CSS',
            message: `Unsafe CSS content: ${cssResult.errors.join(', ')}`,
            field: `targets.${experiment.targets.indexOf(target)}.variants.${variantId}.render.css`,
            details: cssResult.errors
          });
        }
      }
    }
  }
}

/**
 * Checks if a selector targets unsafe elements for outer position
 */
function isUnsafeOuterTarget(selector: string): boolean {
  const lowerSelector = selector.toLowerCase();
  return UNSAFE_OUTER_SELECTORS.some(unsafe => 
    lowerSelector.includes(unsafe) || 
    lowerSelector.match(new RegExp(unsafe.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')))
  );
}
</file>

<file path=".dockerignore">
node_modules
npm-debug.log
.git
.gitignore
README.md
.env
.nyc_output
coverage
.nyc_output
.coverage
dist
.eslintrc.*
eslint.config.js
</file>

<file path=".gitignore">
node_modules/
dist/
*.log
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

/src/generated/prisma
</file>

<file path="docker-compose.prod.yml">
services:
  api:
    build:
      context: .
      dockerfile: Dockerfile.prod
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=${DATABASE_URL}
    depends_on:
      postgres:
        condition: service_healthy
    restart: unless-stopped
    command: sh -c "npx prisma migrate deploy && npm start"

  postgres:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

volumes:
  postgres_data:
</file>

<file path="Dockerfile.prod">
# Production Dockerfile
FROM node:20-alpine

# Set working directory
WORKDIR /app

# Copy package files
COPY package*.json ./

# Install all dependencies (including dev dependencies for build)
RUN npm ci

# Copy source code
COPY src/ ./src/
COPY tsconfig.json ./
COPY prisma/ ./prisma/

# Generate Prisma client and build TypeScript
RUN npm run db:generate
RUN npm run build

# Remove dev dependencies after build
RUN npm prune --production

# Expose port
EXPOSE 3000

# Start the application
CMD ["npm", "start"]
</file>

<file path="docs/experiment-management-api.md">
# Experiment Management API

Complete API reference for managing experiments.

## Endpoints Overview

| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | `/api/experiments` | List all experiments for a project |
| GET | `/api/experiments/:id` | Get a single experiment with details |
| POST | `/api/experiments` | Create a new experiment |
| PATCH | `/api/experiments/:id/status` | Update experiment status (start/pause/resume/complete) |
| DELETE | `/api/experiments/:id` | Delete an experiment |

---

## GET /api/experiments

Get all experiments for the authenticated user's project.

### Request

**Headers:**
```
Authorization: Bearer <token>
```

### Response (200 OK)

```json
[
  {
    "id": "cm1x7y8z9...",
    "name": "Button Color Test",
    "status": "RUNNING",
    "oec": "Increase conversion rate",
    "minDays": 7,
    "minSessionsPerVariant": 1000,
    "targetUrls": ["/products/*"],
    "createdAt": "2025-10-05T10:00:00.000Z",
    "publishedAt": "2025-10-05T11:00:00.000Z",
    "finishedAt": null
  }
]
```

---

## GET /api/experiments/:id

Get a single experiment with all related data (hypothesis, variants, traffic distribution).

### Request

**Headers:**
```
Authorization: Bearer <token>
```

**Parameters:**
- `id` (path) - Experiment ID

### Response (200 OK)

```json
{
  "id": "cm1x7y8z9...",
  "projectId": "cm1x7y8z9...",
  "name": "Button Color Test",
  "status": "RUNNING",
  "oec": "Increase conversion rate",
  "minDays": 7,
  "minSessionsPerVariant": 1000,
  "targetUrls": ["/products/*"],
  "createdAt": "2025-10-05T10:00:00.000Z",
  "publishedAt": "2025-10-05T11:00:00.000Z",
  "finishedAt": null,
  "hypothesis": {
    "id": "cm1x7y8z9...",
    "experimentId": "cm1x7y8z9...",
    "hypothesis": "Green button will increase conversions",
    "rationale": "Green color is associated with 'go' action",
    "primaryKpi": "conversion_rate",
    "createdAt": "2025-10-05T10:00:00.000Z"
  },
  "traffic": [
    {
      "id": "cm1x7y8z9...",
      "experimentId": "cm1x7y8z9...",
      "variantId": "control",
      "percentage": "0.3333"
    },
    {
      "id": "cm1x7y8z9...",
      "experimentId": "cm1x7y8z9...",
      "variantId": "A",
      "percentage": "0.3333"
    },
    {
      "id": "cm1x7y8z9...",
      "experimentId": "cm1x7y8z9...",
      "variantId": "B",
      "percentage": "0.3334"
    }
  ],
  "variants": [
    {
      "id": "cm1x7y8z9...",
      "experimentId": "cm1x7y8z9...",
      "variantId": "A",
      "selector": ".cta-button",
      "html": "<button class=\"green-btn\">Buy Now</button>",
      "css": ".green-btn { background: green; }",
      "position": "OUTER"
    },
    {
      "id": "cm1x7y8z9...",
      "experimentId": "cm1x7y8z9...",
      "variantId": "B",
      "selector": ".cta-button",
      "html": "<button class=\"blue-btn\">Buy Now</button>",
      "css": ".blue-btn { background: blue; }",
      "position": "OUTER"
    }
  ]
}
```

### Error Responses

**404 Not Found:**
```json
{
  "error": "NOT_FOUND",
  "message": "Experiment not found"
}
```

**403 Forbidden:**
```json
{
  "error": "FORBIDDEN",
  "message": "You do not have access to this experiment"
}
```

---

## POST /api/experiments

Create a new experiment. See [manual-experiment-creation.md](./manual-experiment-creation.md) for detailed documentation.

---

## PATCH /api/experiments/:id/status

Update experiment status with state transitions.

### Request

**Headers:**
```
Authorization: Bearer <token>
Content-Type: application/json
```

**Parameters:**
- `id` (path) - Experiment ID

**Body:**
```json
{
  "action": "start" | "pause" | "resume" | "complete"
}
```

### Actions

#### `start`
- **From:** `DRAFT`
- **To:** `RUNNING`
- **Effect:** Publishes experiment to Cloudflare, starts serving variants
- **Sets:** `publishedAt` timestamp

#### `pause`
- **From:** `RUNNING`
- **To:** `PAUSED`
- **Effect:** Unpublishes from Cloudflare, **STOPS serving variants to users**

#### `resume`
- **From:** `PAUSED`
- **To:** `RUNNING`
- **Effect:** Re-publishes to Cloudflare, **STARTS serving variants again**

#### `complete`
- **From:** `RUNNING` or `PAUSED`
- **To:** `COMPLETED`
- **Effect:** Unpublishes from Cloudflare, stops serving variants
- **Sets:** `finishedAt` timestamp

### State Transition Diagram

```
DRAFT ──(start)──> RUNNING ──(pause)──> PAUSED
                      │                    │
                      │                    │
                      └─────(complete)─────┘
                              │
                              ▼
                          COMPLETED
```

### Response (200 OK)

```json
{
  "success": true,
  "experiment": {
    "id": "cm1x7y8z9...",
    "status": "RUNNING",
    "publishedAt": "2025-10-05T12:00:00.000Z",
    ...
  }
}
```

### Error Responses

**400 Invalid State Transition:**
```json
{
  "error": "INVALID_STATE_TRANSITION",
  "message": "Cannot start experiment in RUNNING status. Only DRAFT experiments can be started."
}
```

**500 Publish Failed:**
```json
{
  "error": "PUBLISH_FAILED",
  "message": "Failed to publish experiment: Cloudflare API error"
}
```

### Examples

**Start an experiment:**
```bash
curl -X PATCH http://localhost:3000/api/experiments/cm1x7y8z9.../status \
  -H "Authorization: Bearer <token>" \
  -H "Content-Type: application/json" \
  -d '{"action": "start"}'
```

**Pause an experiment:**
```bash
curl -X PATCH http://localhost:3000/api/experiments/cm1x7y8z9.../status \
  -H "Authorization: Bearer <token>" \
  -H "Content-Type: application/json" \
  -d '{"action": "pause"}'
```

**Resume an experiment:**
```bash
curl -X PATCH http://localhost:3000/api/experiments/cm1x7y8z9.../status \
  -H "Authorization: Bearer <token>" \
  -H "Content-Type: application/json" \
  -d '{"action": "resume"}'
```

**Complete an experiment:**
```bash
curl -X PATCH http://localhost:3000/api/experiments/cm1x7y8z9.../status \
  -H "Authorization: Bearer <token>" \
  -H "Content-Type: application/json" \
  -d '{"action": "complete"}'
```

---

## DELETE /api/experiments/:id

Delete an experiment and all related data (hypothesis, variants, traffic distribution).

### Request

**Headers:**
```
Authorization: Bearer <token>
```

**Parameters:**
- `id` (path) - Experiment ID

### Rules

- ✅ Can delete: `DRAFT`, `PAUSED`, `COMPLETED` experiments
- ❌ Cannot delete: `RUNNING` experiments (must pause/complete first)
- Automatically unpublishes from Cloudflare if needed
- Cascading delete removes all related data

### Response (200 OK)

```json
{
  "success": true,
  "message": "Experiment deleted successfully"
}
```

### Error Responses

**400 Invalid State:**
```json
{
  "error": "INVALID_STATE",
  "message": "Cannot delete a RUNNING experiment. Please pause or complete it first."
}
```

**404 Not Found:**
```json
{
  "error": "NOT_FOUND",
  "message": "Experiment not found"
}
```

**403 Forbidden:**
```json
{
  "error": "FORBIDDEN",
  "message": "You do not have access to this experiment"
}
```

### Example

```bash
curl -X DELETE http://localhost:3000/api/experiments/cm1x7y8z9... \
  -H "Authorization: Bearer <token>"
```

---

## Common Workflows

### Creating and Running an Experiment

1. **Create experiment** (DRAFT status by default)
   ```
   POST /api/experiments
   ```

2. **Review experiment details**
   ```
   GET /api/experiments/:id
   ```

3. **Start experiment** (publishes to Cloudflare)
   ```
   PATCH /api/experiments/:id/status
   Body: {"action": "start"}
   ```

### Stopping an Experiment

1. **Pause temporarily** (keeps published)
   ```
   PATCH /api/experiments/:id/status
   Body: {"action": "pause"}
   ```

2. **Or complete permanently** (unpublishes)
   ```
   PATCH /api/experiments/:id/status
   Body: {"action": "complete"}
   ```

### Deleting an Experiment

1. **If running, complete it first**
   ```
   PATCH /api/experiments/:id/status
   Body: {"action": "complete"}
   ```

2. **Then delete**
   ```
   DELETE /api/experiments/:id
   ```

---

## Status Meanings

| Status | Description | Serving State |
|--------|-------------|---------------|
| `DRAFT` | Created but not published. | ❌ Not serving |
| `RUNNING` | Published to Cloudflare. | ✅ Actively serving variants |
| `PAUSED` | Temporarily stopped. Unpublished from Cloudflare. | ❌ Not serving (can resume) |
| `COMPLETED` | Permanently finished. Unpublished from Cloudflare. | ❌ Not serving (cannot resume) |
| `FAILED` | (Future) Experiment failed to publish or encountered errors. | ❌ Not serving |

---

## Notes

- All endpoints require authentication via Better Auth
- All endpoints verify project ownership
- State transitions are strictly enforced
- Cloudflare publish/unpublish is automatic with state changes
- All deletes are cascading (removes hypothesis, variants, traffic)
</file>

<file path="docs/inject-positions.md">
# Injection Positions Reference

This document explains all available injection positions for experiment variants.

## Position Types

### INNER
**Replaces the inner content of the target element**

```javascript
// Implementation
element.innerHTML = content;
```

**Example:**
```json
{
  "selector": ".product-title",
  "html": "<h2>New Title</h2>",
  "position": "INNER"
}
```

**Result:**
```html
<!-- Before -->
<div class="product-title">
  <h2>Old Title</h2>
</div>

<!-- After -->
<div class="product-title">
  <h2>New Title</h2>
</div>
```

⚠️ **Warning:** Removes all existing content inside the element.

---

### OUTER
**Replaces the entire target element**

```javascript
// Implementation
element.outerHTML = content;
```

**Example:**
```json
{
  "selector": ".old-button",
  "html": "<button class=\"new-button\">Click Me</button>",
  "position": "OUTER"
}
```

**Result:**
```html
<!-- Before -->
<button class="old-button">Old Text</button>

<!-- After -->
<button class="new-button">Click Me</button>
```

⚠️ **Warning:** Removes the target element entirely, including its attributes and event listeners.

---

### BEFORE
**Inserts content before the target element (as a sibling)**

```javascript
// Implementation
element.insertAdjacentHTML('beforebegin', content);
```

**Example:**
```json
{
  "selector": ".main-content",
  "html": "<div class=\"banner\">Special Offer!</div>",
  "position": "BEFORE"
}
```

**Result:**
```html
<!-- Before -->
<div class="main-content">Content</div>

<!-- After -->
<div class="banner">Special Offer!</div>
<div class="main-content">Content</div>
```

✅ Safe - doesn't modify the target element.

---

### AFTER
**Inserts content after the target element (as a sibling)**

```javascript
// Implementation
element.insertAdjacentHTML('afterend', content);
```

**Example:**
```json
{
  "selector": ".product-description",
  "html": "<div class=\"reviews\">Customer Reviews</div>",
  "position": "AFTER"
}
```

**Result:**
```html
<!-- Before -->
<div class="product-description">Description</div>

<!-- After -->
<div class="product-description">Description</div>
<div class="reviews">Customer Reviews</div>
```

✅ Safe - doesn't modify the target element.

---

### APPEND ⭐ NEW
**Appends content as the last child of the target element**

```javascript
// Implementation
element.insertAdjacentHTML('beforeend', content);
// or
element.appendChild(newElement);
```

**Example:**
```json
{
  "selector": "head",
  "html": "<style>.new-class { color: red; }</style>",
  "position": "APPEND"
}
```

**Result:**
```html
<!-- Before -->
<head>
  <meta charset="utf-8">
  <title>Page</title>
</head>

<!-- After -->
<head>
  <meta charset="utf-8">
  <title>Page</title>
  <style>.new-class { color: red; }</style>
</head>
```

✅ **Perfect for CSS injection** - preserves existing head content.

---

### PREPEND ⭐ NEW
**Prepends content as the first child of the target element**

```javascript
// Implementation
element.insertAdjacentHTML('afterbegin', content);
// or
element.insertBefore(newElement, element.firstChild);
```

**Example:**
```json
{
  "selector": "body",
  "html": "<div class=\"top-banner\">Announcement</div>",
  "position": "PREPEND"
}
```

**Result:**
```html
<!-- Before -->
<body>
  <header>Header</header>
  <main>Content</main>
</body>

<!-- After -->
<body>
  <div class="top-banner">Announcement</div>
  <header>Header</header>
  <main>Content</main>
</body>
```

✅ Safe - preserves existing content, adds to the beginning.

---

## Common Use Cases

### Injecting CSS Styles
**✅ Recommended: APPEND to head**
```json
{
  "selector": "head",
  "html": "<style>/* your CSS */</style>",
  "position": "APPEND"
}
```

### Injecting JavaScript
**✅ Recommended: APPEND to head or BEFORE body**
```json
{
  "selector": "head",
  "html": "<script>(function() { /* your code */ })();</script>",
  "position": "APPEND"
}
```

### Adding a Banner Above Content
**✅ Use: PREPEND to body or AFTER to header**
```json
{
  "selector": "body",
  "html": "<div class=\"banner\">Special Offer!</div>",
  "position": "PREPEND"
}
```

### Replacing a Button
**✅ Use: OUTER**
```json
{
  "selector": ".old-button",
  "html": "<button class=\"new-button\">Buy Now</button>",
  "position": "OUTER"
}
```

### Modifying Button Text Only
**✅ Use: INNER**
```json
{
  "selector": ".cta-button",
  "html": "Get Started Free",
  "position": "INNER"
}
```

---

## Visual Guide

```
                  BEFORE
                    ↓
         ┌─────────────────────┐
         │  <div class="box">  │ ← OUTER replaces this
         ├─────────────────────┤
PREPEND→ │                     │
         │   existing content  │ ← INNER replaces this
         │                     │ ←APPEND
         └─────────────────────┘
                    ↑
                  AFTER
```

---

## Safety Considerations

| Position | Destructive? | Use Case |
|----------|-------------|----------|
| INNER | ⚠️ Yes | Replacing content inside an element |
| OUTER | ⚠️ Yes | Replacing entire element |
| BEFORE | ✅ No | Adding sibling before |
| AFTER | ✅ No | Adding sibling after |
| APPEND | ✅ No | Adding to end of children (best for `<head>`) |
| PREPEND | ✅ No | Adding to start of children |

**Best Practice:** Use non-destructive positions (BEFORE, AFTER, APPEND, PREPEND) whenever possible to avoid breaking existing functionality.

---

## API Examples

### Complete Request: CSS Injection

```json
{
  "name": "PLP Grid Optimization",
  "oec": "Improve product discoverability",
  "hypothesis": {
    "hypothesis": "4-column grid layout will increase engagement",
    "rationale": "More products visible above the fold",
    "primaryKpi": "click_through_rate"
  },
  "variants": [
    {
      "variantId": "A",
      "selector": "head",
      "html": "<style>@media (min-width:1000px) { .products { display: grid; grid-template-columns: repeat(4, 1fr); } }</style>",
      "position": "APPEND"
    }
  ]
}
```

### Complete Request: HTML Banner

```json
{
  "name": "Urgency Banner Test",
  "oec": "Increase conversion rate",
  "hypothesis": {
    "hypothesis": "Urgency messaging will drive faster purchase decisions",
    "rationale": "FOMO triggers action",
    "primaryKpi": "conversion_rate"
  },
  "variants": [
    {
      "variantId": "A",
      "selector": "body",
      "html": "<div style=\"background: #ff0000; color: white; padding: 10px; text-align: center;\">⏰ Sale ends in 24 hours!</div>",
      "position": "PREPEND"
    }
  ]
}
```

---

## Migration Notes

If you have existing experiments using:
- `selector: "head"` + `position: "INNER"` → **Change to APPEND** to avoid breaking the page
- `selector: "body"` + `position: "INNER"` → **Change to PREPEND** if adding content at the top
</file>

<file path="docs/PIPELINE.md">
# Omen Experimentation Pipeline - Complete Documentation

## Overview

The Omen experimentation pipeline is an end-to-end automated system for running A/B tests and conversion rate optimization (CRO) experiments on e-commerce websites. The pipeline leverages AI models to analyze brands, generate hypotheses, create variants, and deploy experiments automatically.

## Architecture Overview

```
┌─────────────────┐      ┌──────────────────┐      ┌───────────────────┐
│  Brand Analysis │ ───> │    Hypothesis    │ ───> │     Variant       │
│     Phase       │      │    Generation    │      │    Generation     │
└─────────────────┘      └──────────────────┘      └───────────────────┘
         │                        │                          │
         ▼                        ▼                          ▼
   Brand Intelligence       Test Hypotheses            Code & Selectors
                                                              │
                                                              ▼
                                                   ┌───────────────────┐
                                                   │    Experiment     │
                                                   │    Deployment     │
                                                   └───────────────────┘
```

---

## Phase 1: Brand Analysis

### Purpose
Extract comprehensive brand intelligence from target websites to understand brand personality, positioning, and visual identity.

### Input
- **Shop Domain**: The target website URL (e.g., `shop.omen.so`)
- **Project ID**: Unique identifier for the project
- **Authentication**: Optional Shopify password for protected stores

### Process

#### 1.1 Web Crawling with Firecrawl
- **Service**: `FirecrawlService` (`omen-backend/src/features/brand_analysis/firecrawl-service.ts`)
- **Tool**: Firecrawl API with Mendable SDK
- **Actions**:
  - Navigate to website with authentication if needed
  - Wait for page load (5 seconds)
  - Extract HTML, markdown, and screenshot

```typescript
// Example Firecrawl configuration
const result = await firecrawl.scrape(websiteUrl, {
    onlyMainContent: true,
    actions: [
        { "type": "write", "selector": "#password", "text": "reitri" },
        { "type": "executeJavascript", "script": "..." },
        { "type": "wait", "milliseconds": 5000 }
    ],
    formats: ["json", "screenshot", "html"]
});
```

#### 1.2 Brand Intelligence Extraction
- **Model**: Google Gemini (via structured generation)
- **Schema**: `BrandIntelligenceData`
- **Extraction Components**:

```typescript
interface BrandIntelligenceData {
    brand_description: string;           // 1-2 sentences about the brand
    brand_personality_words: string[];   // 4 words capturing character
    brand_trait_scores: {
        premium: { score: number; explanation: string };
        energetic: { score: number; explanation: string };
        innovator: { score: number; explanation: string };
        social_proof: { score: number; explanation: string };
        curated: { score: number; explanation: string };
        serious: { score: number; explanation: string };
    };
    brand_colors: Array<{
        color: string;
        description: string;
        usage_type: 'primary' | 'secondary' | 'tertiary' | 'accent';
        hex_code: string;
    }>;
}
```

#### 1.3 Storage
- Screenshots stored with metadata
- Brand analysis saved to database
- HTML and markdown content preserved

### Output
- **Brand Analysis JSON**: Complete brand intelligence profile
- **Screenshot**: Full-page screenshot (base64 encoded)
- **HTML Content**: Simplified HTML for later analysis
- **Markdown**: Extracted text content

### Example Output
```json
{
  "brand_description": "Your brand offers premium organic dog food products targeting health-conscious pet owners who prioritize natural ingredients and sustainable sourcing.",
  "brand_personality_words": ["Natural", "Caring", "Premium", "Trustworthy"],
  "brand_trait_scores": {
    "premium": {
      "score": 75,
      "explanation": "Strong premium signals through minimalist design, high-quality product photography, and emphasis on organic ingredients"
    },
    "social_proof": {
      "score": 45,
      "explanation": "Moderate social proof with customer testimonials visible but lacks prominent review counts or trust badges"
    }
  },
  "brand_colors": [
    {
      "color": "Forest Green",
      "description": "Primary brand color used in headers and CTAs",
      "usage_type": "primary",
      "hex_code": "#2D5016"
    }
  ]
}
```

---

## Phase 2: Hypothesis Generation

### Purpose
Generate data-driven hypotheses for A/B testing based on the brand analysis and current website state.

### Input
- **URL**: Target page for experimentation
- **Project ID**: Links to brand analysis
- **Brand Analysis**: Retrieved from Phase 1
- **Active Targets**: Existing experiments to avoid conflicts

### Process

#### 2.1 Page Analysis
- **Service**: `HypothesesGenerationService` (`omen-backend/src/features/hypotheses_generation/hypotheses-generation.ts`)
- **Crawler**: Playwright-based crawler for dynamic content
- **Screenshot**: High-quality capture (1920x1080)

```typescript
const crawlResult = await this.crawlerService.crawlPage(url, {
    viewport: { width: 1920, height: 1080 },
    waitFor: 3000,
    screenshot: { fullPage: true, quality: 80 },
    authentication: {
        type: 'shopify_password',
        password: 'reitri',
        shopDomain: 'shop.omen.so'
    }
});
```

#### 2.2 AI Hypothesis Generation
- **Model**: Google Gemini with structured output
- **Context Provided**:
  - Brand analysis from Phase 1
  - Current page screenshot
  - Simplified HTML
  - Active experiment targets (for conflict avoidance)

#### 2.3 Hypothesis Schema
```typescript
interface Hypothesis {
    title: string;                    // Clear hypothesis name
    description: string;               // One sentence breakdown
    primary_outcome: string;           // OEC (20 chars max)
    current_problem: string;           // Current issue identified
    why_it_works: Array<{
        reason: string;                // 5-7 word explanations
    }>;
    baseline_performance: number;      // Estimated current conversion %
    predicted_lift_range: {
        min: number;                   // Minimum expected lift
        max: number;                   // Maximum expected lift
    };
}
```

### Demo Mode
When `DEMO_CONDITION` is enabled:
- Focuses on specific target elements
- Uses predefined selectors
- Constrains hypothesis to button variations

### Output
- **Hypotheses Array**: 3-5 test hypotheses
- **Stored Screenshots**: Saved with HTML for variant generation
- **State Management**: First hypothesis stored for pipeline continuation

### Example Output
```json
{
  "hypotheses": [
    {
      "title": "Urgency-Driven Add to Cart",
      "description": "Adding urgency messaging to the add-to-cart button will increase conversions",
      "primary_outcome": "Add to Cart Rate",
      "current_problem": "Users lack motivation to make immediate purchase decisions",
      "why_it_works": [
        { "reason": "Creates fear of missing out" },
        { "reason": "Reduces decision paralysis time" }
      ],
      "baseline_performance": 3.2,
      "predicted_lift_range": { "min": 0.15, "max": 0.35 }
    }
  ]
}
```

---

## Phase 3: Variant Generation

### Purpose
Generate executable A/B test variants with code, selectors, and implementation details.

### Input
- **Hypothesis**: Selected from Phase 2
- **Project ID**: For retrieving context
- **Brand Analysis**: Design guidance
- **Screenshot & HTML**: Page state

### Process

#### 3.1 DOM Analysis
- **Service**: `DOMAnalyzerService` (`omen-backend/src/features/variant_generation/dom-analyzer.ts`)
- **Element Detection**: Identifies targetable elements
- **Injection Points**: Finds safe modification points

```typescript
interface InjectionPoint {
    selector: string;           // CSS selector
    confidence: number;         // 0-1 confidence score
    elementType: string;        // button, link, heading, etc.
    attributes: Record<string, string>;
    textContent?: string;
    position: { x: number; y: number; width: number; height: number };
}
```

#### 3.2 Variant Schema Generation
- **Service**: `VariantGenerationService` (`omen-backend/src/features/variant_generation/variant-generation.ts`)
- **AI Model**: Google Gemini
- **Output Schema**:

```typescript
interface Variant {
    variant_label: string;      // e.g., "Control", "Variant A"
    description: string;        // What changes
    rationale: string;          // Why it should work
    visual_changes: string[];   // List of visual modifications
    psychological_triggers: string[];  // Behavioral principles
}
```

#### 3.3 Code Generation
- **Service**: `VariantCodeGenerator` (`omen-backend/src/features/variant_generation/code-generator.ts`)
- **Pattern**: Self-contained IIFE JavaScript
- **Safety Features**:
  - Error handling with try-catch
  - Selector validation
  - Media guardrails (no external URLs)
  - Link preservation

```javascript
// Generated code structure
(function() {
  'use strict';

  function initVariant() {
    try {
      const baseElement = document.querySelector('[selector]');
      if (!baseElement) {
        console.warn('Target element not found');
        return;
      }

      // Variant implementation
      baseElement.textContent = 'New Text';
      baseElement.style.backgroundColor = '#FF0000';

    } catch (error) {
      console.error('Variant error:', error);
    }
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initVariant);
  } else {
    initVariant();
  }
})();
```

#### 3.4 Selector Strategy
Multiple approaches for robust element targeting:

1. **CSS Path Generator**: Creates specific paths
2. **Hypothesis-Aware Selector**: Context-based selection
3. **Smart Screenshot Strategy**: Visual recognition
4. **Demo Mode**: Fixed selectors for testing

### Output
- **Variants Array**: Control + test variants
- **JavaScript Code**: Implementation for each variant
- **Target Selectors**: CSS selectors for modifications
- **Execution Instructions**: Timing and setup details

### Example Output
```json
{
  "variants": [
    {
      "variant_label": "Control",
      "description": "Original button unchanged",
      "javascript_code": "// No changes for control",
      "target_selector": "body"
    },
    {
      "variant_label": "Variant A",
      "description": "Add urgency text to button",
      "javascript_code": "(function() { /* ... */ })();",
      "target_selector": ".add-to-cart-button",
      "visual_changes": ["Button text changed", "Red accent added"],
      "psychological_triggers": ["Urgency", "Scarcity"]
    }
  ]
}
```

---

## Phase 4: Experiment Creation & Deployment

### Purpose
Package variants into a complete experiment and deploy to the A/B testing platform.

### Input
- **Hypothesis**: Complete hypothesis object
- **Variants**: Generated code and configurations
- **Experiment Metadata**: Name, duration, traffic allocation

### Process

#### 4.1 Experiment Configuration
```typescript
interface ExperimentConfig {
    name: string;
    oec: string;                    // Overall Evaluation Criterion
    minDays: number;                 // Minimum test duration
    minSessionsPerVariant: number;  // Statistical significance threshold
    targetUrls: string[];           // Where to run the test
    targeting?: {
        match: 'all' | 'any';
        timeoutMs: number;
        rules: TargetingRule[];
    };
    hypothesis: Hypothesis;
    variants: Variant[];
    trafficDistribution: Record<string, number>;  // e.g., {"control": 0.5, "variant_a": 0.5}
}
```

#### 4.2 Targeting Rules
Support for advanced targeting:
- DOM element presence/absence
- Text content matching
- Meta tags
- Cookies
- URL parameters
- Local storage values

```typescript
type TargetingRule =
  | { type: 'selectorExists'; selector: string }
  | { type: 'textContains'; selector: string; text: string }
  | { type: 'cookie'; name: string; value: string }
  | { type: 'urlParam'; name: string; value: string };
```

#### 4.3 Cloudflare Worker Deployment
- **Publisher**: `CloudflarePublisher` (`omen-backend/src/infra/external/cloudflare/cloudflare-publisher.ts`)
- **KV Storage**: Experiment data stored in Cloudflare KV
- **Edge Execution**: Tests run at CDN edge

```typescript
// Deployment process
await cloudflarePublisher.publishExperiment({
    experimentId: experiment.id,
    projectId: project.id,
    variants: transformedVariants,
    targeting: experiment.targeting,
    status: 'ACTIVE'
});
```

### Output
- **Experiment ID**: Unique identifier
- **Deployment Status**: Success/failure
- **Preview URLs**: Test variant previews
- **Analytics Setup**: Tracking configuration

---

## Integration Points

### Frontend (Next.js)
- **Location**: `omen-frontend/app/api/`
- **Endpoints**:
  - `/api/brand-summary`: Initiate brand analysis
  - `/api/experiments`: Create/list experiments
  - `/api/chat`: AI assistant interface

### SDK (JavaScript)
- **Location**: `omen-js-sdk/`
- **Components**:
  - User identification
  - Variant assignment
  - Analytics tracking
  - Preview management

### Worker (Cloudflare)
- **Location**: `omen-sdk-worker/`
- **Functions**:
  - Variant serving
  - User bucketing
  - Analytics collection
  - A/B test execution

---

## Data Flow

```mermaid
graph LR
    A[User Request] --> B[Frontend API]
    B --> C[Backend Services]
    C --> D[Brand Analysis]
    D --> E[Hypothesis Generation]
    E --> F[Variant Generation]
    F --> G[Experiment Creation]
    G --> H[Cloudflare Deployment]
    H --> I[SDK Execution]
    I --> J[Analytics Collection]
```

---

## Key Technologies

### AI/ML
- **Google Gemini**: Primary language model
- **Structured Generation**: Type-safe AI outputs
- **Vision Models**: Screenshot analysis

### Web Technologies
- **Playwright**: Browser automation
- **Firecrawl**: Web scraping
- **Cloudflare Workers**: Edge computing

### Data Storage
- **PostgreSQL**: Primary database
- **Cloudflare KV**: Edge data store
- **Screenshot Storage**: Base64 encoded images

### Languages & Frameworks
- **TypeScript**: Primary language
- **Next.js**: Frontend framework
- **Prisma**: ORM
- **Zod**: Schema validation

---

## Configuration & Settings

### Environment Variables
```bash
# AI Configuration
AI_MODEL="gemini-1.5-pro"
GOOGLE_AI_API_KEY="..."

# Services
BACKEND_URL="http://localhost:3001"
FIRECRAWL_API_KEY="..."

# Cloudflare
CLOUDFLARE_ACCOUNT_ID="..."
CLOUDFLARE_API_TOKEN="..."
CLOUDFLARE_KV_NAMESPACE_ID="..."

# Database
DATABASE_URL="postgresql://..."
```

### Demo Mode
Toggle in `src/shared/demo-config.ts`:
```typescript
export const DEMO_CONDITION = true;  // Enable demo mode
export const DEMO_TARGET_ELEMENT = {
    selector: 'a[href="/collections/all"]',
    description: 'Shop All button'
};
```

---

## Error Handling & Recovery

### Retry Logic
- Automatic retries for transient failures
- Exponential backoff for API calls
- Fallback to cached data when available

### Validation
- Zod schemas for all data structures
- Input sanitization
- Selector validation before code execution

### Monitoring
- Comprehensive logging at each phase
- Error tracking with context
- Performance metrics collection

---

## Security Considerations

### Code Execution
- Sandboxed JavaScript execution
- No external resource loading
- DOM modification restrictions

### Data Protection
- Authentication via Auth0
- Encrypted storage for sensitive data
- Session-based access control

### Rate Limiting
- API call throttling
- Resource usage monitoring
- Concurrent execution limits

---

## Performance Optimizations

### Caching
- Brand analysis results (5-minute TTL)
- Screenshots and HTML
- AI responses for similar queries

### Parallel Processing
- Concurrent variant generation
- Batch API calls where possible
- Asynchronous pipeline stages

### Resource Management
- Browser instance pooling
- Memory-efficient image handling
- Lazy loading of heavy dependencies

---

## Future Enhancements

### Planned Features
1. **Multi-page experiments**: Test across entire user journey
2. **Personalization**: User segment targeting
3. **Mobile-specific variants**: Responsive test variations
4. **Visual editor**: GUI for variant creation
5. **Statistical significance calculator**: Real-time test analysis

### Technical Improvements
1. **WebAssembly modules**: Performance-critical operations
2. **GraphQL API**: Flexible data fetching
3. **Event streaming**: Real-time analytics
4. **ML model fine-tuning**: Domain-specific optimization
5. **Distributed processing**: Horizontal scaling

---

## Conclusion

The Omen experimentation pipeline represents a sophisticated, AI-driven approach to conversion rate optimization. By automating the entire process from brand analysis to variant deployment, it enables rapid, data-driven experimentation at scale. The modular architecture ensures flexibility and maintainability while the comprehensive safety measures guarantee reliable execution in production environments.
</file>

<file path="docs/SELECTOR_GENERATION_FLOW.md">
# Selector Generation Flow - Detailed Explanation

## Overview
The selector generation pipeline has been enhanced to be **hypothesis-aware**, moving from generic selector detection to context-specific element targeting based on the A/B test hypothesis.

## Architecture

```
Hypothesis → DOM Analyzer → Selector Generator → Validation → Code Generator
                    ↓
            [Hypothesis-Aware]  [Multi-Strategy]
             (Primary Path)      (Fallback Path)
```

## Detailed Flow

### 1. **Hypothesis Input**
When a hypothesis is generated, it contains specific information about what element needs to be modified:
```
Example: "Replacing the static 'Engineered for Every Turn' text section with
customer photos will build trust and increase engagement."
```

### 2. **DOM Analyzer Processing** (`dom-analyzer.ts`)

#### Step 2.1: HTML Preparation
```typescript
// Clean HTML by removing scripts, styles, and comments
const $ = cheerio.load(pageSource);
$('script').remove();
$('style').remove();
$('noscript').remove();
const cleanedHTML = $.html();
```

#### Step 2.2: Primary Path - Hypothesis-Aware Selection
```typescript
const hypothesisSelector = createHypothesisAwareSelector(cleanedHTML);
const hypothesisCandidates = await hypothesisSelector.generateSelector(hypothesis);
```

### 3. **Hypothesis-Aware Selector Generation** (`hypothesis-aware-selector.ts`)

#### Step 3.1: AI-Powered Element Identification
The system sends the hypothesis to an AI model (Google Gemini) with a structured prompt:

```typescript
const elementIdentification = await generateObject({
  model: google(aiConfig.model),
  schema: selectorGenerationSchema,
  messages: [{
    role: 'user',
    content: buildIdentificationPrompt(hypothesis)
  }]
});
```

The AI returns:
- `primary_selector`: Most specific CSS selector for the target
- `element_identifier`: Natural language description of what we're looking for
- `search_strategy`: How to find this element (text_content, section_heading, structural, semantic)
- `alternative_selectors`: Fallback selectors in order of preference
- `confidence`: 0-1 confidence score
- `reasoning`: Why this selector was chosen

#### Step 3.2: Candidate Discovery
```typescript
private async findElementCandidates(aiResult): Promise<HypothesisSelector[]> {
  const candidates = [];
  const allSelectors = [aiResult.primary_selector, ...aiResult.alternative_selectors];

  for (const selector of allSelectors) {
    const elements = $(selector);

    if (elements.length === 0) {
      // Selector found nothing - skip
      continue;
    }

    if (elements.length === 1) {
      // Perfect match - create high-confidence candidate
      candidates.push(createCandidate(element, selector, reasoning));
    }

    if (elements.length > 1) {
      // Multiple matches - might be section-level targeting
      // Create candidate with reduced confidence
      candidate.confidence *= 0.5;
      candidates.push(candidate);
    }
  }

  return candidates;
}
```

#### Step 3.3: Fallback Text-Based Search
If no candidates are found via selectors, the system searches by text content:
```typescript
if (candidates.length === 0 && aiResult.element_identifier) {
  const textBasedCandidates = this.findByText(aiResult.element_identifier);
  candidates.push(...textBasedCandidates);
}
```

#### Step 3.4: Selector Generation Strategies
For each found element, multiple selector strategies are generated:

1. **Data Attributes** (Most Reliable)
   ```css
   [data-testid="resource-list-grid"]
   ```

2. **ARIA/Role Attributes** (Very Reliable)
   ```css
   section[role="region"]
   button[aria-label="Shop all"]
   ```

3. **Stable IDs** (Reliable if not generated)
   ```css
   #engineered-section
   ```

4. **Semantic Classes** (Moderately Reliable)
   ```css
   section.feature-section
   .hero__content-wrapper
   ```

5. **Path-Based** (Less Reliable)
   ```css
   main > section:nth-child(3) > div.container
   ```

6. **Text Content** (Least Reliable)
   ```css
   h2:contains("Engineered for Every Turn")
   ```

### 4. **Validation & Ranking**

#### Validation Checks
Each candidate selector is validated for:
- **Exists**: Does the selector match any elements?
- **Unique**: Does it match exactly one element?
- **Stable**: Does it avoid generated IDs/classes?

```typescript
validation: {
  exists: $(selector).length > 0,
  unique: $(selector).length === 1,
  stable: !hasGeneratedPatterns(selector)
}
```

#### Scoring System
Candidates are scored based on:
```typescript
let score = 0;
if (candidate.validation.exists) score += 3;
if (candidate.validation.unique) score += 3;
if (candidate.validation.stable) score += 2;
// Plus relevance to hypothesis text
score += textRelevanceScore * 1;
// Plus AI confidence
score += candidate.confidence * 5;
```

### 5. **Injection Point Creation**
The validated candidates are converted to injection points with rich context:

```typescript
{
  selector: "section.feature-section",
  confidence: 0.85,
  type: "container",
  context: {
    elementText: "Engineered for Every Turn...",
    elementType: "section",
    parentContext: "main",
    htmlSnippet: "<section class='feature-section'>..."
  },
  alternativeSelectors: [
    "#engineered-section",
    "main > section:nth-child(3)",
    ".container:has(h2:contains('Engineered'))"
  ],
  reasoning: "Section containing the exact heading text mentioned in hypothesis",
  selectorReliability: {
    works: true,
    confidence: 0.85,
    reason: "Hypothesis-aware: stable selector"
  }
}
```

### 6. **Fallback Path - Multi-Strategy Detection**
If hypothesis-aware selection fails, the system falls back to the original multi-strategy detector which tries 10 different strategies:
- Role-based detection
- Text-based detection
- Data attributes
- Label-based detection
- Placeholder-based detection
- Title-based detection
- Alt text detection
- Semantic class detection
- Stable ID detection
- Position-based detection

### 7. **Code Generator Integration** (`code-generator.ts`)
The code generator receives enhanced context for each selector:

```javascript
PRIMARY SELECTOR:
- Selector: section.feature-section
- Type: container
- Confidence: 0.85
- Current text: "Engineered for Every Turn..."
- Validation: VALID - Hypothesis-aware: stable selector
- Alternative selectors: #engineered-section, main > section:nth-child(3)
- HTML Context:
  Element HTML: <section class="feature-section">...
  Parent: <main class="main-content">
  Siblings: Previous: <section>, Next: <section>
  Position: 3 of 5 siblings
```

## Key Improvements Over Previous System

### Before (Generic Detection)
```
Hypothesis → Extract Keywords → Search for ANY element with keywords → Generic selectors
Result: [data-testid="resource-list-grid"] (generic container)
```

### After (Hypothesis-Aware)
```
Hypothesis → Understand Context → Find SPECIFIC element mentioned → Precise selectors
Result: section:has(h2:contains("Engineered for Every Turn")) (exact section)
```

## Example: "Engineered for Every Turn" Section

### Previous Approach Output:
```javascript
// Generic selectors without context
[
  "[data-testid='resource-list-grid']",  // Wrong section
  "[data-testid='group-block']",          // Too generic
  "[data-testid='footer-utilities']"      // Completely unrelated
]
```

### New Approach Output:
```javascript
// Hypothesis-specific selectors with context
[
  {
    selector: "section:has(h2:contains('Engineered for Every Turn'))",
    confidence: 0.9,
    reasoning: "Section containing the exact heading mentioned",
    alternatives: [
      ".feature-section",
      "#ResourceListtemplateresourcelist",
      "section.shopify-section:nth-of-type(4)"
    ]
  }
]
```

## Benefits

1. **Precision**: Selectors target the exact elements mentioned in hypotheses
2. **Context**: Rich metadata helps code generator make better decisions
3. **Reliability**: Multiple validation checks ensure selectors work
4. **Fallbacks**: Alternative selectors provide resilience
5. **Intelligence**: AI understands the semantic meaning of the hypothesis

## Configuration

The system uses Google Gemini 2.5 Pro for AI-powered selection with these key parameters:
- Model: `gemini-2.5-pro`
- Max HTML snippet: 30,000 chars
- Max selectors to try: 10
- Confidence range: 0-1

## Error Handling

- Invalid selectors are caught and skipped
- Multi-element matches are handled with reduced confidence
- Text-based fallback for when selectors fail
- Graceful degradation to multi-strategy detection
- Infinite loop prevention with selector limits

## Future Enhancements

1. **Learning System**: Track which selectors work best over time
2. **Visual Validation**: Use screenshots to verify selector accuracy
3. **Dynamic Refinement**: Iteratively improve selectors based on feedback
4. **Cross-Page Stability**: Test selectors across multiple pages
5. **Performance Optimization**: Cache successful selector patterns
</file>

<file path="docs/TEST_VARIANTS.md">
# Testing the Variant Generation Pipeline

This document explains how to test the hypothesis → variant → JavaScript code generation pipeline without using the agent.

## Quick Start

```bash
# Test with any available project from database
npm run test:variants

# Test with a specific project
TEST_PROJECT_ID=your-project-id npm run test:variants

# Simple test (just AI generation, no database)
npm run test:variants:simple
```

## Test Files

### 1. `test-variant-pipeline.ts`
Full end-to-end test using real projects from database:
- Automatically lists available projects
- Uses real brand analysis from database
- Generates hypothesis from project URL
- Generates variant ideas
- Generates JavaScript code
- Validates code and saves results

### 2. `test-variant-simple.ts`
Lightweight test focusing on AI generation:
- No database required
- Uses hardcoded hypothesis
- Tests variant and code generation
- Quick validation

## How It Works

### Using Real Projects

The pipeline test now:
1. **Lists all projects** from your database
2. **Auto-selects** the most recent project (or uses TEST_PROJECT_ID)
3. **Checks for brand analysis** (warns if missing)
4. **Generates hypothesis** from the project's homepage
5. **Creates variants** using the real brand analysis
6. **Validates JavaScript** and saves results

### Project Selection

```bash
# Will list all projects and auto-select the most recent
npm run test:variants

# Use a specific project
TEST_PROJECT_ID=clxxxxx npm run test:variants
```

Output example:
```
📋 Fetching available projects from database...

Available projects:
────────────────────────────────────────────────────────────
1. shop.omen.so
   ID: cl123abc456
   Created: 1/15/2024

2. another-store.myshopify.com
   ID: cl789def012
   Created: 1/10/2024

➡️  Auto-selecting most recent project: shop.omen.so
```

### In `test-variant-simple.ts`:
```typescript
const TEST_HYPOTHESIS: Hypothesis = {
    title: "Your hypothesis title",
    description: "What you want to test",
    // ... modify as needed
};
```

## Demo Mode

When `DEMO_CONDITION` is `true` (in `src/shared/demo-config.ts`):
- Targets the "Shop all" button specifically
- Uses button-focused prompts
- Generates button-specific variants

When `DEMO_CONDITION` is `false`:
- Uses AI to detect relevant elements
- General variant generation
- More flexible targeting

## Output

### Pipeline Test Output
- Console output with detailed progress
- JSON file saved to `./test-output/variant-test-[timestamp].json`
- Contains hypothesis, variants, and JavaScript code

### Simple Test Output
- Console output only
- Shows variant ideas and JavaScript preview
- Validates syntax

## Example Output

```
🚀 Starting Variant Generation Pipeline Test

📦 Step 1: Initializing services...
✅ Services initialized

🎯 Step 2: Setting up hypothesis...
📝 Using custom hypothesis: Enhance Shop All Button with Urgency

🎨 Step 3: Generating variants...
  Demo Mode: ENABLED
✅ Generated 3 variants

📊 Step 4: Results

🔹 Variant 1: Urgency Timer Button
  Description: Adds a countdown timer to create urgency
  JavaScript Code Preview:
    (function() {
      'use strict';
      ...
    })();

✨ Pipeline test completed successfully!
```

## Troubleshooting

### API Key Issues
Make sure your `.env` file contains:
```
GOOGLE_GEMINI_API_KEY=your-key-here
```

### Module Import Errors
Run:
```bash
npm install
npm run db:generate
```

### Demo Mode Not Working
Check `src/shared/demo-config.ts`:
```typescript
export const DEMO_CONDITION = true;  // Should be true for demo
```

## What Gets Tested

1. **Hypothesis Processing**: Validates hypothesis structure and data
2. **Variant Generation**: Tests AI prompt generation and response parsing
3. **JavaScript Generation**: Tests code generation for each variant
4. **Code Validation**: Basic syntax checking of generated JavaScript
5. **Selector Validation**: Checks if selectors are valid
6. **Demo Mode**: Tests both demo and normal modes

## Extending the Tests

To add more test cases, modify the hypothesis in either test file:

```typescript
const MY_HYPOTHESIS: Hypothesis = {
    title: "Test Something New",
    description: "Your test description",
    current_problem: "The problem to solve",
    predicted_lift_range: { min: 10, max: 30 },
    // ... etc
};
```

Or test different URLs by changing:
```typescript
TEST_CONFIG.url = 'https://your-test-site.com';
```
</file>

<file path="prisma/migrations/20250929070921_init/migration.sql">
-- CreateEnum
CREATE TYPE "public"."JobStatus" AS ENUM ('DRAFT', 'PENDING', 'RUNNING', 'PAUSED', 'COMPLETED', 'FAILED');

-- CreateEnum
CREATE TYPE "public"."MessageRole" AS ENUM ('USER', 'AGENT', 'TOOL', 'SYSTEM');

-- CreateEnum
CREATE TYPE "public"."InjectPosition" AS ENUM ('INNER', 'OUTER', 'BEFORE', 'AFTER');

-- CreateTable
CREATE TABLE "public"."users" (
    "id" TEXT NOT NULL,
    "auth0Id" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "firstName" TEXT NOT NULL,
    "lastName" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "users_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."projects" (
    "id" TEXT NOT NULL,
    "shopDomain" TEXT NOT NULL,
    "brandAnalysis" JSONB,
    "accessTokenEnc" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "projects_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."experiments" (
    "id" TEXT NOT NULL,
    "projectId" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "status" "public"."JobStatus" NOT NULL DEFAULT 'DRAFT',
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "publishedAt" TIMESTAMP(3),
    "finishedAt" TIMESTAMP(3),
    "oec" TEXT NOT NULL,
    "minDays" INTEGER NOT NULL,
    "minSessionsPerVariant" INTEGER NOT NULL,

    CONSTRAINT "experiments_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."chat_messages" (
    "id" TEXT NOT NULL,
    "projectId" TEXT NOT NULL,
    "role" "public"."MessageRole" NOT NULL,
    "content" JSONB NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "chat_messages_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."brand_summary_jobs" (
    "id" TEXT NOT NULL,
    "projectId" TEXT NOT NULL,
    "status" "public"."JobStatus" NOT NULL DEFAULT 'PENDING',
    "progress" INTEGER DEFAULT 0,
    "result" JSONB,
    "error" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "startedAt" TIMESTAMP(3),
    "completedAt" TIMESTAMP(3),

    CONSTRAINT "brand_summary_jobs_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."variant_jobs" (
    "id" TEXT NOT NULL,
    "projectId" TEXT NOT NULL,
    "status" "public"."JobStatus" NOT NULL DEFAULT 'PENDING',
    "progress" INTEGER DEFAULT 0,
    "result" JSONB,
    "error" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "startedAt" TIMESTAMP(3),
    "completedAt" TIMESTAMP(3),

    CONSTRAINT "variant_jobs_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."experiment_hypotheses" (
    "id" TEXT NOT NULL,
    "experimentId" TEXT NOT NULL,
    "hypothesis" TEXT NOT NULL,
    "rationale" TEXT NOT NULL,
    "primaryKpi" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "experiment_hypotheses_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."experiment_traffic" (
    "id" TEXT NOT NULL,
    "experimentId" TEXT NOT NULL,
    "variantId" TEXT NOT NULL,
    "percentage" DECIMAL(5,4) NOT NULL,

    CONSTRAINT "experiment_traffic_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."experiment_variants" (
    "id" TEXT NOT NULL,
    "experimentId" TEXT NOT NULL,
    "variantId" TEXT NOT NULL,
    "selector" TEXT,
    "html" TEXT NOT NULL,
    "css" TEXT,
    "position" "public"."InjectPosition" NOT NULL,

    CONSTRAINT "experiment_variants_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."screenshots" (
    "id" TEXT NOT NULL,
    "projectId" TEXT NOT NULL,
    "url" TEXT NOT NULL,
    "pageType" TEXT NOT NULL,
    "variantId" TEXT,
    "viewportWidth" INTEGER NOT NULL,
    "viewportHeight" INTEGER NOT NULL,
    "fullPage" BOOLEAN NOT NULL,
    "quality" INTEGER NOT NULL,
    "data" BYTEA NOT NULL,
    "htmlContent" TEXT,
    "fileSize" INTEGER NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "expiresAt" TIMESTAMP(3) NOT NULL,
    "accessedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "accessCount" INTEGER NOT NULL DEFAULT 0,

    CONSTRAINT "screenshots_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "users_auth0Id_key" ON "public"."users"("auth0Id");

-- CreateIndex
CREATE UNIQUE INDEX "users_email_key" ON "public"."users"("email");

-- CreateIndex
CREATE UNIQUE INDEX "projects_shopDomain_key" ON "public"."projects"("shopDomain");

-- CreateIndex
CREATE UNIQUE INDEX "projects_userId_key" ON "public"."projects"("userId");

-- CreateIndex
CREATE INDEX "experiments_projectId_status_idx" ON "public"."experiments"("projectId", "status");

-- CreateIndex
CREATE INDEX "chat_messages_projectId_createdAt_idx" ON "public"."chat_messages"("projectId", "createdAt");

-- CreateIndex
CREATE INDEX "brand_summary_jobs_projectId_status_createdAt_idx" ON "public"."brand_summary_jobs"("projectId", "status", "createdAt");

-- CreateIndex
CREATE INDEX "brand_summary_jobs_status_createdAt_idx" ON "public"."brand_summary_jobs"("status", "createdAt");

-- CreateIndex
CREATE INDEX "variant_jobs_projectId_status_createdAt_idx" ON "public"."variant_jobs"("projectId", "status", "createdAt");

-- CreateIndex
CREATE INDEX "variant_jobs_status_createdAt_idx" ON "public"."variant_jobs"("status", "createdAt");

-- CreateIndex
CREATE UNIQUE INDEX "experiment_hypotheses_experimentId_key" ON "public"."experiment_hypotheses"("experimentId");

-- CreateIndex
CREATE INDEX "experiment_traffic_experimentId_idx" ON "public"."experiment_traffic"("experimentId");

-- CreateIndex
CREATE UNIQUE INDEX "experiment_traffic_experimentId_variantId_key" ON "public"."experiment_traffic"("experimentId", "variantId");

-- CreateIndex
CREATE INDEX "experiment_variants_experimentId_idx" ON "public"."experiment_variants"("experimentId");

-- CreateIndex
CREATE UNIQUE INDEX "experiment_variants_experimentId_variantId_key" ON "public"."experiment_variants"("experimentId", "variantId");

-- CreateIndex
CREATE INDEX "screenshots_projectId_idx" ON "public"."screenshots"("projectId");

-- CreateIndex
CREATE INDEX "screenshots_expiresAt_idx" ON "public"."screenshots"("expiresAt");

-- CreateIndex
CREATE INDEX "screenshots_pageType_idx" ON "public"."screenshots"("pageType");

-- CreateIndex
CREATE INDEX "screenshots_variantId_idx" ON "public"."screenshots"("variantId");

-- CreateIndex
CREATE UNIQUE INDEX "screenshots_projectId_pageType_variantId_viewportWidth_view_key" ON "public"."screenshots"("projectId", "pageType", "variantId", "viewportWidth", "viewportHeight", "fullPage", "quality");

-- AddForeignKey
ALTER TABLE "public"."projects" ADD CONSTRAINT "projects_userId_fkey" FOREIGN KEY ("userId") REFERENCES "public"."users"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."experiments" ADD CONSTRAINT "experiments_projectId_fkey" FOREIGN KEY ("projectId") REFERENCES "public"."projects"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."chat_messages" ADD CONSTRAINT "chat_messages_projectId_fkey" FOREIGN KEY ("projectId") REFERENCES "public"."projects"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."brand_summary_jobs" ADD CONSTRAINT "brand_summary_jobs_projectId_fkey" FOREIGN KEY ("projectId") REFERENCES "public"."projects"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."variant_jobs" ADD CONSTRAINT "variant_jobs_projectId_fkey" FOREIGN KEY ("projectId") REFERENCES "public"."projects"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."experiment_hypotheses" ADD CONSTRAINT "experiment_hypotheses_experimentId_fkey" FOREIGN KEY ("experimentId") REFERENCES "public"."experiments"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."experiment_traffic" ADD CONSTRAINT "experiment_traffic_experimentId_fkey" FOREIGN KEY ("experimentId") REFERENCES "public"."experiments"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."experiment_variants" ADD CONSTRAINT "experiment_variants_experimentId_fkey" FOREIGN KEY ("experimentId") REFERENCES "public"."experiments"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."screenshots" ADD CONSTRAINT "screenshots_projectId_fkey" FOREIGN KEY ("projectId") REFERENCES "public"."projects"("id") ON DELETE CASCADE ON UPDATE CASCADE;
</file>

<file path="prisma/migrations/20251001081017_add_markdown_to_screenshots/migration.sql">
-- AlterTable
ALTER TABLE "public"."screenshots" ADD COLUMN     "markdownContent" TEXT;
</file>

<file path="prisma/migrations/20251004092856_add_analytics_events/migration.sql">
-- CreateTable
CREATE TABLE "public"."analytics_events" (
    "id" TEXT NOT NULL,
    "projectId" TEXT NOT NULL,
    "experimentId" TEXT,
    "eventType" TEXT NOT NULL DEFAULT 'exposure',
    "sessionId" TEXT NOT NULL,
    "viewId" TEXT,
    "properties" JSONB NOT NULL,
    "timestamp" BIGINT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "analytics_events_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE INDEX "analytics_events_projectId_eventType_idx" ON "public"."analytics_events"("projectId", "eventType");

-- CreateIndex
CREATE INDEX "analytics_events_eventType_timestamp_idx" ON "public"."analytics_events"("eventType", "timestamp");

-- CreateIndex
CREATE INDEX "analytics_events_sessionId_idx" ON "public"."analytics_events"("sessionId");

-- CreateIndex
CREATE INDEX "analytics_events_experimentId_idx" ON "public"."analytics_events"("experimentId");

-- AddForeignKey
ALTER TABLE "public"."analytics_events" ADD CONSTRAINT "analytics_events_projectId_fkey" FOREIGN KEY ("projectId") REFERENCES "public"."projects"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."analytics_events" ADD CONSTRAINT "analytics_events_experimentId_fkey" FOREIGN KEY ("experimentId") REFERENCES "public"."experiments"("id") ON DELETE CASCADE ON UPDATE CASCADE;
</file>

<file path="prisma/migrations/20251004132504_add_better_auth_tables/migration.sql">
/*
  Warnings:

  - Added the required column `name` to the `users` table without a default value. This is not possible if the table is not empty.

*/
-- AlterTable
ALTER TABLE "public"."users" ADD COLUMN     "emailVerified" BOOLEAN NOT NULL DEFAULT false,
ADD COLUMN     "image" TEXT,
ADD COLUMN     "name" TEXT NOT NULL,
ALTER COLUMN "auth0Id" DROP NOT NULL;

-- CreateTable
CREATE TABLE "public"."session" (
    "id" TEXT NOT NULL,
    "expiresAt" TIMESTAMP(3) NOT NULL,
    "token" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "ipAddress" TEXT,
    "userAgent" TEXT,
    "userId" TEXT NOT NULL,
    "activeOrganizationId" TEXT,

    CONSTRAINT "session_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."account" (
    "id" TEXT NOT NULL,
    "accountId" TEXT NOT NULL,
    "providerId" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "accessToken" TEXT,
    "refreshToken" TEXT,
    "idToken" TEXT,
    "accessTokenExpiresAt" TIMESTAMP(3),
    "refreshTokenExpiresAt" TIMESTAMP(3),
    "scope" TEXT,
    "password" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "account_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."verification" (
    "id" TEXT NOT NULL,
    "identifier" TEXT NOT NULL,
    "value" TEXT NOT NULL,
    "expiresAt" TIMESTAMP(3) NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "verification_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."organization" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "slug" TEXT NOT NULL,
    "logo" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL,
    "metadata" TEXT,

    CONSTRAINT "organization_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."member" (
    "id" TEXT NOT NULL,
    "organizationId" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "role" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "member_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."invitation" (
    "id" TEXT NOT NULL,
    "organizationId" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "role" TEXT,
    "status" TEXT NOT NULL,
    "expiresAt" TIMESTAMP(3) NOT NULL,
    "inviterId" TEXT NOT NULL,

    CONSTRAINT "invitation_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "session_token_key" ON "public"."session"("token");

-- CreateIndex
CREATE UNIQUE INDEX "organization_slug_key" ON "public"."organization"("slug");

-- AddForeignKey
ALTER TABLE "public"."session" ADD CONSTRAINT "session_userId_fkey" FOREIGN KEY ("userId") REFERENCES "public"."users"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."account" ADD CONSTRAINT "account_userId_fkey" FOREIGN KEY ("userId") REFERENCES "public"."users"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."member" ADD CONSTRAINT "member_organizationId_fkey" FOREIGN KEY ("organizationId") REFERENCES "public"."organization"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."member" ADD CONSTRAINT "member_userId_fkey" FOREIGN KEY ("userId") REFERENCES "public"."users"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."invitation" ADD CONSTRAINT "invitation_organizationId_fkey" FOREIGN KEY ("organizationId") REFERENCES "public"."organization"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."invitation" ADD CONSTRAINT "invitation_inviterId_fkey" FOREIGN KEY ("inviterId") REFERENCES "public"."users"("id") ON DELETE CASCADE ON UPDATE CASCADE;
</file>

<file path="prisma/migrations/20251004133400_remove_firstname_lastname_columns/migration.sql">
/*
  Warnings:

  - You are about to drop the column `firstName` on the `users` table. All the data in the column will be lost.
  - You are about to drop the column `lastName` on the `users` table. All the data in the column will be lost.

*/
-- AlterTable
ALTER TABLE "public"."users" DROP COLUMN "firstName",
DROP COLUMN "lastName";
</file>

<file path="prisma/migrations/20251004192836_add_event_types_enum/migration.sql">
/*
  Warnings:

  - The `eventType` column on the `analytics_events` table would be dropped and recreated. This will lead to data loss if there is data in the column.

*/
-- CreateEnum
CREATE TYPE "public"."EventType" AS ENUM ('EXPOSURE', 'PAGEVIEW', 'CONVERSION', 'CUSTOM');

-- AlterTable
ALTER TABLE "public"."analytics_events" DROP COLUMN "eventType",
ADD COLUMN     "eventType" "public"."EventType" NOT NULL DEFAULT 'EXPOSURE';

-- CreateIndex
CREATE INDEX "analytics_events_projectId_eventType_idx" ON "public"."analytics_events"("projectId", "eventType");

-- CreateIndex
CREATE INDEX "analytics_events_eventType_timestamp_idx" ON "public"."analytics_events"("eventType", "timestamp");

-- CreateIndex
CREATE INDEX "analytics_events_sessionId_eventType_idx" ON "public"."analytics_events"("sessionId", "eventType");
</file>

<file path="prisma/migrations/20251004202510_add_url_targeting_to_experiments/migration.sql">
-- AlterTable
ALTER TABLE "public"."experiments" ADD COLUMN     "targetUrls" JSONB;
</file>

<file path="prisma/migrations/20251005132159_add_append_prepend_positions/migration.sql">
-- AlterEnum
-- This migration adds more than one value to an enum.
-- With PostgreSQL versions 11 and earlier, this is not possible
-- in a single migration. This can be worked around by creating
-- multiple migrations, each migration adding only one value to
-- the enum.


ALTER TYPE "public"."InjectPosition" ADD VALUE 'APPEND';
ALTER TYPE "public"."InjectPosition" ADD VALUE 'PREPEND';
</file>

<file path="prisma/migrations/20251005155025_add_store_type/migration.sql">
-- AlterTable
ALTER TABLE "public"."projects" ADD COLUMN     "isShopify" BOOLEAN NOT NULL DEFAULT true,
ALTER COLUMN "accessTokenEnc" DROP NOT NULL;
</file>

<file path="prisma/migrations/20251006103959_add_js_to_variants/migration.sql">
-- AlterTable
ALTER TABLE "public"."experiment_variants" ADD COLUMN     "js" TEXT;
</file>

<file path="prisma/migrations/20251006112713_add_purchase_event_type/migration.sql">
-- AlterEnum
ALTER TYPE "public"."EventType" ADD VALUE 'PURCHASE';
</file>

<file path="prisma/migrations/20251006151506_add_targeting_to_experiment/migration.sql">
-- AlterTable
ALTER TABLE "public"."experiments" ADD COLUMN     "targeting" JSONB;
</file>

<file path="src/domain/agent/tools/get-experiment-overview.ts">
// @ts-nocheck
import { tool } from 'ai';
import { z } from 'zod';
import { prisma } from '@infra/prisma';
import { experimentStateManager } from '../experiment-state-manager';

const getExperimentOverviewSchema = z.object({
  experimentId: z.string().optional().describe('The ID of the experiment to get overview for - if not provided, will use the current experiment from state')
});

class GetExperimentOverviewExecutor {
  async execute(input: { experimentId?: string }): Promise<{
    experiment: any;
    hypothesis: any;
    variants: any[];
    traffic: any[];
    summary: string;
  }> {
    // Get experiment ID from input or state
    const experimentId = input.experimentId || experimentStateManager.getCurrentExperimentId();
    
    if (!experimentId) {
      throw new Error('No experiment ID provided and no current experiment in state. Please create an experiment first or provide an experiment ID.');
    }
    
    console.log(`[EXPERIMENT_OVERVIEW] Getting overview for experiment: ${experimentId}`);
    
    try {
      // Fetch experiment data from database
      const experiment = await prisma.experiment.findUnique({
        where: { id: experimentId },
        include: {
          hypothesis: true,
          traffic: true,
          variants: true,
        },
      });

      if (!experiment) {
        throw new Error(`Experiment not found: ${experimentId}`);
      }

      console.log(`[EXPERIMENT_OVERVIEW] Found experiment:`, {
        id: experiment.id,
        name: experiment.name,
        status: experiment.status,
        variantCount: experiment.variants.length,
        trafficCount: experiment.traffic.length
      });

      // Create a summary for the user
      const variantSummary = experiment.variants.map((variant, index) => 
        `${variant.variantId}: ${variant.selector}`
      ).join(', ');

      const trafficSummary = experiment.traffic.map(t => 
        `${t.variantId}: ${Math.round(t.percentage * 100)}%`
      ).join(', ');

      const summary = `**Experiment Overview: ${experiment.name}**

**Status:** ${experiment.status}
**OEC:** ${experiment.oec}

**Hypothesis:**
${experiment.hypothesis?.hypothesis || 'No hypothesis available'}

**Rationale:**
${experiment.hypothesis?.rationale || 'No rationale available'}

**Success Metrics:**
${experiment.hypothesis?.primaryKpi || 'No metrics defined'}

**Variants (${experiment.variants.length}):**
${variantSummary}

**Traffic Distribution:**
${trafficSummary}

**Next Steps:**
This experiment is ready to be published. Once published, it will be live and the SDK can load the variants for testing.`;

      return {
        experiment,
        hypothesis: experiment.hypothesis,
        variants: experiment.variants,
        traffic: experiment.traffic,
        summary
      };
    } catch (error) {
      console.error(`[EXPERIMENT_OVERVIEW] Failed to get experiment overview:`, error);
      throw new Error(`Failed to get experiment overview: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
}

export function createGetExperimentOverviewTool() {
  const executor = new GetExperimentOverviewExecutor();

  return tool({
    description: 'Get a detailed overview of an experiment including hypothesis, variants, traffic distribution, and status. Use this to show users what will be published before they confirm.',
    inputSchema: getExperimentOverviewSchema,
    execute: async (input) => {
      try {
        const result = await executor.execute(input);
        return result;
      } catch (error) {
        console.error(`[EXPERIMENT_OVERVIEW] Tool execute failed:`, error);
        throw new Error(error instanceof Error ? error.message : 'Failed to get experiment overview');
      }
    },
  });
}
</file>

<file path="src/domain/agent/tools/preview-experiment.ts">
// @ts-nocheck
import { tool } from 'ai';
import { z } from 'zod';
import { hypothesisStateManager } from '../hypothesis-state-manager';
import { variantStateManager } from '../variant-state-manager';

const previewExperimentSchema = z.object({
  name: z.string().optional().describe('The name of the experiment to preview - if not provided, will be auto-generated from the hypothesis')
});

class PreviewExperimentExecutor {
  async execute(input: { name?: string }): Promise<{
    experimentName: string;
    hypothesis: any;
    variantCount: number;
    variants: Array<{ label: string }>;
    primaryOutcome: string;
    baselinePerformance: number;
    expectedUplift: { min: number; max: number };
    trafficSplit: string;
    runningTime: string;
    conflictCheck: string;
  }> {
    console.log(`[PREVIEW_EXPERIMENT] Creating experiment preview`);
    
    try {
      // Get hypothesis from state manager
      const hypothesis = hypothesisStateManager.getCurrentHypothesis();
      if (!hypothesis) {
        throw new Error('No hypothesis available in state. Please generate hypotheses first.');
      }

      // Get variants from state manager
      const variants = variantStateManager.getCurrentVariants();
      if (!variants || variants.length === 0) {
        throw new Error('No variants available in state. Please generate variants first.');
      }

      // Use provided name or hypothesis title as fallback
      const experimentName = input.name || hypothesis.title || 'Experiment';

      // Create short variant summaries (just labels, no descriptions)
      const variantSummaries = variants.map(variant => ({
        label: variant.variant_label
      }));

      // Calculate traffic split
      const percentagePerVariant = Math.round(100 / variants.length);
      const trafficSplit = variants.map((_, index) => 
        `${String.fromCharCode(65 + index)}: ${percentagePerVariant}%`
      ).join(', ');

      console.log(`[PREVIEW_EXPERIMENT] Preview created successfully:`, {
        experimentName,
        hypothesisTitle: hypothesis.title,
        variantCount: variants.length
      });

      return {
        experimentName,
        hypothesis,
        variantCount: variants.length,
        variants: variantSummaries,
        primaryOutcome: hypothesis.primary_outcome || 'Click-through rate',
        baselinePerformance: hypothesis.baseline_performance || 15,
        expectedUplift: {
          min: hypothesis.predicted_lift_range?.min || 0.05,
          max: hypothesis.predicted_lift_range?.max || 0.20
        },
        trafficSplit,
        runningTime: 'Indefinite',
        conflictCheck: 'No conflicts detected - experiment is safe to run'
      };
    } catch (error) {
      console.error(`[PREVIEW_EXPERIMENT] Failed to create preview:`, error);
      throw new Error(`Failed to create experiment preview: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
}

export function createPreviewExperimentTool() {
  const executor = new PreviewExperimentExecutor();

  return tool({
    description: 'Preview what an experiment would look like before creating it. Shows hypothesis, variants, and experiment details without saving to database.',
    inputSchema: previewExperimentSchema,
    execute: async (input) => {
      try {
        const result = await executor.execute(input);
        return result;
      } catch (error) {
        console.error(`[PREVIEW_EXPERIMENT] Tool execute failed:`, error);
        throw new Error(error instanceof Error ? error.message : 'Failed to preview experiment');
      }
    },
  });
}
</file>

<file path="src/domain/agent/experiment-state-manager.ts">
// Experiment State Manager - manages experiment state across tool calls
import { Experiment } from '@infra/dal/types';

class ExperimentStateManager {
  private currentExperiment: Experiment | null = null;
  private experimentHistory: Experiment[] = [];

  /**
   * Set the current experiment (from create_experiment tool)
   */
  setCurrentExperiment(experiment: Experiment): void {
    console.log(`[EXPERIMENT_STATE_MANAGER] Setting experiment: "${experiment.name}" (${experiment.id})`);
    this.currentExperiment = experiment;
    this.experimentHistory.push(experiment);
    console.log(`[EXPERIMENT_STATE_MANAGER] Experiment set: "${experiment.name}"`);
    console.log(`[EXPERIMENT_STATE_MANAGER] Current experiment count: ${this.experimentHistory.length}`);
  }

  /**
   * Get the current experiment (for get_experiment_overview and publish_experiment tools)
   */
  getCurrentExperiment(): Experiment | null {
    console.log(`[EXPERIMENT_STATE_MANAGER] Getting current experiment: ${this.currentExperiment ? 'FOUND' : 'NOT FOUND'}`);
    return this.currentExperiment;
  }

  /**
   * Get the most recent experiment from history
   */
  getLatestExperiment(): Experiment | null {
    return this.experimentHistory.length > 0 
      ? this.experimentHistory[this.experimentHistory.length - 1] 
      : null;
  }

  /**
   * Get current experiment ID
   */
  getCurrentExperimentId(): string | null {
    return this.currentExperiment?.id || null;
  }

  /**
   * Clear the current experiment
   */
  clearCurrentExperiment(): void {
    console.log(`[EXPERIMENT_STATE_MANAGER] Clearing current experiment`);
    this.currentExperiment = null;
  }

  /**
   * Clear all experiment history
   */
  clearAll(): void {
    console.log(`[EXPERIMENT_STATE_MANAGER] Clearing all experiment data`);
    this.currentExperiment = null;
    this.experimentHistory = [];
  }

  /**
   * Get experiment history
   */
  getHistory(): Experiment[] {
    return [...this.experimentHistory];
  }

  /**
   * Check if there's a current experiment
   */
  hasCurrentExperiment(): boolean {
    return this.currentExperiment !== null;
  }
}

// Singleton instance
export const experimentStateManager = new ExperimentStateManager();
</file>

<file path="src/features/brand_analysis/prompts.ts">
// Brand Analysis Prompts
export type PageType = 'home' | 'pdp' | 'about';

export function getPageSpecificPrompt(pageType: PageType): string {
  const basePrompt = `You are a professional UX researcher and CRO (Conversion Rate Optimization) expert conducting a critical brand analysis. Your job is to provide honest, evidence-based assessments that help identify real opportunities for improvement. Be harsh but fair - call out weaknesses honestly while acknowledging strengths where they exist.

Analyze this ${pageType} page and extract comprehensive brand intelligence data:`;

  const pageSpecificInstructions = {
    home: `
This is the HOMEPAGE - the main entry point that sets first impressions. Focus on:
- Overall brand positioning and value proposition
- Primary messaging and headlines
- Visual hierarchy and design system
- Navigation structure and user flow
- Trust signals and credibility indicators
- Call-to-action effectiveness
- Brand personality and tone`,
    
    pdp: `
This is a PRODUCT DETAIL PAGE (PDP) - where customers make purchase decisions. Focus on:
- Product presentation and photography quality
- Pricing strategy and value communication
- Product information depth and clarity
- Social proof and customer reviews
- Add-to-cart and checkout flow
- Product comparison and alternatives
- Trust and security indicators`,
    
    about: `
This is the ABOUT PAGE - where brands tell their story and build trust. Focus on:
- Brand story and company values
- Team presentation and expertise
- Mission, vision, and company culture
- Trust signals and credentials
- Contact information and transparency
- Brand personality and authenticity
- Social responsibility and values`
  };

  const commonInstructions = `

1. Brand Description:
   - Write 1–2 sentences that describe what the brand actually is and does, starting with "Your brand…".
   - Always use second person ("you/your") instead of third person ("they/their").
   - Write as if you're a specialist who has thoroughly analyzed their site and business model.
   - Use professional, analytical language that shows deep understanding of their market position.
   - Describe their actual business, products, and target market based on concrete evidence from the site.
   - Focus on what they sell, who they serve, and their core offering - not marketing claims.
   - If unclear what they do, state that directly rather than guessing.

2. Brand Personality Words:
   - Output exactly 4 words that capture the brand's character (e.g., Modern, Professional, Innovative, Friendly).
   - Words must reflect the actual tone and personality conveyed by the site, not aspirational goals.
   - If the brand personality is inconsistent or unclear, reflect that honestly.

3. Brand Trait Scores:
   - For each trait, provide both a score (1-100) and a detailed explanation.
   - Rate each trait using explicit signals from the website - be critical and honest.
   - Always justify your score with specific evidence and explain your reasoning.
   - If there is insufficient information, assign a lower score and explicitly state "insufficient signals."
   - Don't inflate scores to be nice - be brutally honest about what you actually observe.
   - Format: Each trait should have "score" (number) and "explanation" (string) fields.

  --- TRAIT RUBRICS ---
  (Rate based on what you actually observe, not what the brand might aspire to be)

   Premium (luxury / high-end perception):
   - 0–20: Clearly budget-focused: discount banners, coupon-heavy messaging, pixelated images, cluttered layouts, bargain-bin aesthetics.
   - 21–40: Basic/functional: low pricing emphasis, stock photography, minimal design effort, no luxury signals.
   - 41–60: Decent quality: clean design, mid-tier pricing, good photography, some quality indicators but not premium.
   - 61–80: Strong premium signals: higher pricing, lifestyle photography, "premium" language, polished design.
   - 81–100: True luxury positioning: minimalistic aesthetic, high price anchors, refined typography, aspirational storytelling.
   **Critical assessment**: Look for actual evidence of premium positioning, not just claims.

   Energetic (dynamic / vibrant / active feel):
   - 0–20: Completely static: muted colors, no CTAs, boring layout, zero energy.
   - 21–40: Minimal energy: a few bright elements, weak CTAs, mostly static presentation.
   - 41–60: Moderate energy: some color, basic CTAs, occasional dynamic elements.
   - 61–80: High energy: bold colors, strong CTAs, animations, urgent copy.
   - 81–100: Maximum energy: kinetic design, video loops, action-packed imagery, high-urgency messaging.
   **Critical assessment**: Measure actual energy conveyed, not just colorful design.

   Innovator (tech-forward / future-facing):
   - 0–20: No innovation signals: generic offering, traditional approach, no tech claims.
   - 21–40: Basic "modern" claims but no real innovation evidence.
   - 41–60: Some unique features or tools, but not groundbreaking.
   - 61–80: Clear innovation focus: patents, unique tech, "AI-powered" claims.
   - 81–100: Cutting-edge: advanced tech integration, experimental design, "first-ever" positioning.
   **Critical assessment**: Look for actual innovation, not just buzzwords.

   Social Proof (trust signals / external validation):
   - 0–20: Zero credibility signals: no reviews, testimonials, or trust indicators.
   - 21–40: Minimal proof: a few reviews, basic customer mentions.
   - 41–60: Decent proof: visible testimonials, some press mentions, basic trust signals.
   - 61–80: Strong proof: many reviews, client logos, press coverage, influencer endorsements.
   - 81–100: Overwhelming proof: thousands of reviews, major awards, extensive media coverage.
   **Critical assessment**: Count actual trust signals, not just claims of credibility.

   Curated (selectivity / expert curation):
   - 0–20: Mass marketplace feel: wide catalog, no curation story, generic selection.
   - 21–40: Basic categorization but no real curation narrative.
   - 41–60: Some themed collections, modest curation effort.
   - 61–80: Clear curation: "editor's picks," selection stories, limited scope.
   - 81–100: Expert curation: artisanal focus, strong expertise narrative, highly selective.
   **Critical assessment**: Evaluate actual selectivity and curation story, not just small inventory.

   Serious (professional / corporate vs casual / playful):
   - 0–20: Highly casual: slang, memes, cartoon fonts, emoji overuse, playful mascots.
   - 21–40: Informal: friendly but not professional, approachable but casual.
   - 41–60: Balanced: mix of casual and professional elements.
   - 61–80: Professional: restrained language, formal design, corporate tone.
   - 81–100: Very corporate: industry jargon, B2B focus, highly serious, no playfulness.
   **Critical assessment**: Measure actual tone and formality, not just design choices.

4. Brand Colors:
   - Analyze ONLY the actual UI design colors, NOT colors from images, photos, or content.
   - Focus exclusively on: navigation bars, buttons, headers, backgrounds, text colors, borders, and UI elements.
   - IGNORE: product photos, hero images, illustrations, or any content imagery.
   - ONLY include colors you are 100% certain are part of the design system.
   - If you cannot clearly identify 3-4 distinct UI colors, include fewer colors rather than guessing.
   - For each color, provide: hex code, color name, description, and usage type (primary/secondary/tertiary/accent).
   - Classify based on UI hierarchy: primary (main brand color in UI), secondary (supporting UI elements), tertiary (UI backgrounds/text), accent (UI highlights/CTAs).
   - Be brutally honest - if the UI is mostly black/white/gray, don't claim it has "vibrant colors."
   - When in doubt, exclude the color rather than include it.
   - Format: Each color should have: color (name), description, usage_type, hex_code.`;

  return basePrompt + pageSpecificInstructions[pageType] + commonInstructions;
}

export function getSynthesisPrompt(pageResults: Array<{ pageType: PageType; url: string; data?: any; error?: string }>): string {
  const validResults = pageResults.filter(result => result.data && !result.error);
  
  if (validResults.length === 0) {
    throw new Error('No valid page analysis results found for synthesis');
  }

  const resultsSummary = validResults.map(result => {
    const data = result.data;
    const personalityWords = Array.isArray(data.brand_personality_words) 
      ? data.brand_personality_words.join(', ') 
      : 'Not available';
    const colors = Array.isArray(data.brand_colors) 
      ? data.brand_colors.map((c: any) => `${c.color} (${c.hex_code})`).join(', ')
      : 'Not available';
    
    return `
${result.pageType.toUpperCase()} PAGE (${result.url}):
- Brand Description: ${data.brand_description || 'Not available'}
- Personality Words: ${personalityWords}
- Premium Score: ${data.brand_trait_scores?.premium?.score || 'N/A'} (${data.brand_trait_scores?.premium?.explanation || 'Not available'})
- Energetic Score: ${data.brand_trait_scores?.energetic?.score || 'N/A'} (${data.brand_trait_scores?.energetic?.explanation || 'Not available'})
- Innovator Score: ${data.brand_trait_scores?.innovator?.score || 'N/A'} (${data.brand_trait_scores?.innovator?.explanation || 'Not available'})
- Social Proof Score: ${data.brand_trait_scores?.social_proof?.score || 'N/A'} (${data.brand_trait_scores?.social_proof?.explanation || 'Not available'})
- Curated Score: ${data.brand_trait_scores?.curated?.score || 'N/A'} (${data.brand_trait_scores?.curated?.explanation || 'Not available'})
- Serious Score: ${data.brand_trait_scores?.serious?.score || 'N/A'} (${data.brand_trait_scores?.serious?.explanation || 'Not available'})
- Brand Colors: ${colors}
`;
  }).join('\n');

  return `You are a professional brand strategist conducting a comprehensive brand analysis synthesis. You have analyzed multiple pages of a website and now need to synthesize these findings into a cohesive, accurate brand intelligence report.

ANALYSIS RESULTS FROM MULTIPLE PAGES:
${resultsSummary}

SYNTHESIS INSTRUCTIONS:

Your task is to create a unified brand intelligence report that combines insights from all analyzed pages. Consider the following:

1. **Brand Description**: 
   - Create a comprehensive description that captures the brand's essence across all pages
   - Give primary weight (60%) to homepage messaging and positioning
   - Supplement with insights from PDP (20%) and about page (20%)
   - If different pages show different aspects, synthesize them into a complete picture
   - Use evidence from all pages to support your description

2. **Brand Personality Words**:
   - Select 4 words that best represent the brand across all pages
   - Prioritize homepage personality (60% weight) but consider consistency across all pages
   - If there are variations, lean toward the homepage interpretation
   - Choose words that capture the overall brand personality

3. **Brand Trait Scores**:
   - For each trait, calculate a weighted average using these weights:
     * HOMEPAGE: 60% weight (primary brand positioning)
     * PDP: 20% weight (product quality and pricing insights)
     * ABOUT: 20% weight (brand story and trust signals)
   - Look for patterns and consistency across pages
   - If there are conflicts, explain your reasoning for the final score
   - Provide detailed explanations that reference evidence from multiple pages
   - Example calculation: If homepage scores 80, PDP scores 60, about scores 40, then final score = (80×0.6) + (60×0.2) + (40×0.2) = 68

4. **Brand Colors**:
   - Identify the STANDARDIZED brand color palette that should be consistent across all pages
   - Use the HOMEPAGE as the primary source (60% weight) since it represents the main brand design system
   - Verify consistency across other pages - if colors differ significantly, flag this as a brand inconsistency
   - Focus on the core UI design colors (navigation, buttons, headers, backgrounds, text)
   - The final palette should represent the brand's official design system, not a combination
   - If other pages show different colors, note this as a brand consistency issue

5. **Synthesis Notes** (optional):
   - Highlight any significant differences between pages
   - Note any inconsistencies in brand presentation
   - Mention which pages provided the strongest evidence for each trait

Be thorough, analytical, and evidence-based in your synthesis. The final report should feel like a comprehensive brand analysis that only comes from analyzing multiple touchpoints.`;
}
</file>

<file path="src/features/conflict_guard/index.ts">
/**
 * Conflict Guard - Prevents overlapping experiments
 */

import { createHash } from 'crypto';
import { normalizeUrlToPattern, urlOverlap } from '@shared/normalization/url';

export interface ActiveTarget {
  experimentId: string;
  urlPattern: string;           // e.g., "/products/*"
  targetKey?: string;          // sha256 of canonical selector
  roleKey?: string;            // "role:primary-cta"
  label: string;               // e.g., "primary-cta / Add to cart"
}

export interface CandidateTarget {
  url: string;
  selector?: string;
  role?: string;
}

/**
 * Generate SHA256 hash of a string
 */
export function sha256(input: string): string {
  return createHash('sha256').update(input).digest('hex');
}

/**
 * Canonicalize a CSS selector for consistent comparison
 * - Normalize whitespace
 * - Lowercase tag names
 * - Sort class names
 */
export function canonicalizeSelector(selector: string): string {
  if (!selector) return '';

  return selector
    .trim()
    .replace(/\s+/g, ' ')
    // Lowercase HTML tag names
    .replace(/(^|[\s>+~])([A-Z][A-Za-z0-9-]*)/g, (_, prefix, tag) =>
      prefix + tag.toLowerCase()
    )
    // Sort class names within each selector part
    .split(/(\s*[>+~,]\s*)/)
    .map(part => {
      if (part.match(/^[>+~,]$/)) return part;

      // Extract and sort classes
      const classMatch = part.match(/\.([\w-]+(?:\s*\.\s*[\w-]+)*)/);
      if (classMatch) {
        const classes = classMatch[1].split(/\s*\.\s*/).sort().join('.');
        return part.replace(/\.([\w-]+(?:\s*\.\s*[\w-]+)*)/, '.' + classes);
      }
      return part;
    })
    .join('');
}

/**
 * Generate target keys for comparison
 */
export function targetKeys(selector?: string, role?: string) {
  const targetKey = selector ? sha256(canonicalizeSelector(selector)) : undefined;
  const roleKey = role ? `role:${role.toLowerCase().trim()}` : undefined;
  return { targetKey, roleKey };
}

/**
 * Convert active targets to a reserved payload for LLM prompts
 */
export function toReservedPayload(
  contextUrl: string,
  active: ActiveTarget[],
  maxItems: number = 10
) {
  const scope = normalizeUrlToPattern(contextUrl);

  const reserved = active
    .filter(t => urlOverlap(scope, t.urlPattern))
    .slice(0, maxItems) // Keep token budget small
    .map(t => ({
      scope: t.urlPattern,
      role: t.roleKey?.replace(/^role:/, '') ?? null,
      selector_hint: t.targetKey ? '[selector-protected]' : null,
      semantics: [t.label],
      experiment_id: t.experimentId
    }));

  return {
    context_url: contextUrl,
    context_pattern: scope,
    reserved_targets: reserved,
    rules: {
      strict: true,
      check_overlaps: true,
      prevent_indirect_changes: true
    }
  };
}

/**
 * Find conflicts between active experiments and a candidate
 */
export function findConflicts(
  active: ActiveTarget[],
  candidate: CandidateTarget
): ActiveTarget[] {
  const candidatePattern = normalizeUrlToPattern(candidate.url);
  const { targetKey, roleKey } = targetKeys(candidate.selector, candidate.role);

  return active.filter(target => {
    // First check URL overlap
    if (!urlOverlap(candidatePattern, target.urlPattern)) {
      return false;
    }

    // Then check target conflicts
    // Conflict if same selector hash
    if (targetKey && target.targetKey && targetKey === target.targetKey) {
      return true;
    }

    // Conflict if same role
    if (roleKey && target.roleKey && roleKey === target.roleKey) {
      return true;
    }

    // No conflict if different targets on overlapping URLs
    return false;
  });
}

/**
 * Check if a proposal might indirectly affect a reserved target
 * This is a heuristic check for things like:
 * - Parent/child relationships
 * - Adjacent elements that might shift
 * - Global styles that might cascade
 */
export function mightIndirectlyAffect(
  proposalSelector: string | undefined,
  reservedSelector: string | undefined
): boolean {
  if (!proposalSelector || !reservedSelector) {
    return false;
  }

  const proposal = proposalSelector.toLowerCase();
  const reserved = reservedSelector.toLowerCase();

  // Check if one is a parent/ancestor of the other
  if (proposal.includes(reserved) || reserved.includes(proposal)) {
    return true;
  }

  // Check for common parent selectors
  const getParentSelector = (sel: string) => {
    const parts = sel.split(/\s+/);
    return parts.slice(0, -1).join(' ');
  };

  const proposalParent = getParentSelector(proposal);
  const reservedParent = getParentSelector(reserved);

  if (proposalParent && reservedParent && proposalParent === reservedParent) {
    return true; // Same parent, might affect layout
  }

  // Check for body/html level changes that affect everything
  if (proposal.match(/^(body|html|:root)/)) {
    return true;
  }

  return false;
}

/**
 * Format conflict information for error messages
 */
export function formatConflictError(conflicts: ActiveTarget[]): string {
  if (conflicts.length === 0) {
    return 'No conflicts found';
  }

  const conflictList = conflicts
    .map(c => `  - Experiment ${c.experimentId}: ${c.label} on ${c.urlPattern}`)
    .join('\n');

  return `Conflicts detected with active experiments:\n${conflictList}`;
}

/**
 * Domain error class for conflict-related errors
 */
export class ConflictError extends Error {
  constructor(
    public code: string,
    public conflicts: ActiveTarget[],
    message?: string
  ) {
    super(message || formatConflictError(conflicts));
    this.name = 'ConflictError';
  }
}
</file>

<file path="src/features/crawler/index.ts">
// Web Crawler External Service
export { PlaywrightCrawlerService, createPlaywrightCrawler } from './playwright';
export type { CrawlerService, CrawlResult, CrawlOptions, CrawlerConfig } from './types';
</file>

<file path="src/features/variant_generation/selector-generator.ts">
// Rule-based CSS Selector Generator
// Implements industry best practices for stable, valid selectors
import { Page } from 'playwright';
import * as cheerio from 'cheerio';

export interface SelectorCandidate {
  selector: string;
  confidence: number; // 0-1
  strategy: string;
  reasoning: string;
  isValid?: boolean;
}

export interface SelectorGenerationResult {
  primary: string;
  fallbacks: string[];
  allCandidates: SelectorCandidate[];
}

export class SelectorGenerator {
  private $: cheerio.CheerioAPI;

  constructor(html: string) {
    this.$ = cheerio.load(html);
  }

  /**
   * Generate ranked selectors for an element based on description
   * Following industry best practices: ID > data-* > stable class > tag+position
   */
  generateSelectorsForElement(elementDescription: string): SelectorCandidate[] {
    const candidates: SelectorCandidate[] = [];

    // Strategy 1: ID-based selectors (highest priority)
    const idSelectors = this.generateIdSelectors(elementDescription);
    candidates.push(...idSelectors);

    // Strategy 2: Data attribute selectors
    const dataSelectors = this.generateDataAttributeSelectors(elementDescription);
    candidates.push(...dataSelectors);

    // Strategy 3: Stable class selectors
    const classSelectors = this.generateStableClassSelectors(elementDescription);
    candidates.push(...classSelectors);

    // Strategy 4: Role/ARIA selectors
    const ariaSelectors = this.generateAriaSelectors(elementDescription);
    candidates.push(...ariaSelectors);

    // Strategy 5: Text-based selectors (lower priority)
    const textSelectors = this.generateTextSelectors(elementDescription);
    candidates.push(...textSelectors);

    // Strategy 6: Position-based fallbacks (last resort)
    const positionSelectors = this.generatePositionSelectors(elementDescription);
    candidates.push(...positionSelectors);

    // Sort by confidence (highest first)
    return candidates.sort((a, b) => b.confidence - a.confidence);
  }

  private generateIdSelectors(description: string): SelectorCandidate[] {
    const candidates: SelectorCandidate[] = [];
    const keywords = this.extractKeywords(description);

    for (const keyword of keywords) {
      const elements = this.$(`[id*="${keyword}"]`);
      elements.each((_, el) => {
        const $el = this.$(el);
        const id = $el.attr('id');
        if (id && this.isStableId(id)) {
          candidates.push({
            selector: `#${id}`,
            confidence: 0.95,
            strategy: 'id',
            reasoning: `Stable ID attribute: ${id}`
          });
        }
      });
    }

    return candidates;
  }

  private generateDataAttributeSelectors(description: string): SelectorCandidate[] {
    const candidates: SelectorCandidate[] = [];
    const keywords = this.extractKeywords(description);

    // Look for data-testid, data-cy, data-test, etc.
    const dataAttrs = ['data-testid', 'data-cy', 'data-test', 'data-qa'];
    
    for (const attr of dataAttrs) {
      for (const keyword of keywords) {
        const elements = this.$(`[${attr}*="${keyword}"]`);
        elements.each((_, el) => {
          const $el = this.$(el);
          const value = $el.attr(attr);
          if (value) {
            candidates.push({
              selector: `[${attr}="${value}"]`,
              confidence: 0.90,
              strategy: 'data-attribute',
              reasoning: `Stable data attribute: ${attr}="${value}"`
            });
          }
        });
      }
    }

    return candidates;
  }

  private generateStableClassSelectors(description: string): SelectorCandidate[] {
    const candidates: SelectorCandidate[] = [];
    const keywords = this.extractKeywords(description);

    for (const keyword of keywords) {
      const elements = this.$(`[class*="${keyword}"]`);
      elements.each((_, el) => {
        const $el = this.$(el);
        const classes = $el.attr('class')?.split(' ') || [];
        const stableClasses = classes.filter(c => this.isStableClass(c));
        const tagName = (el as any).name;

        if (stableClasses.length > 0) {
          const selector = `${tagName}.${stableClasses[0]}`;
          candidates.push({
            selector,
            confidence: 0.75,
            strategy: 'stable-class',
            reasoning: `Stable class on ${tagName}: ${stableClasses[0]}`
          });
        }
      });
    }

    return candidates;
  }

  private generateAriaSelectors(description: string): SelectorCandidate[] {
    const candidates: SelectorCandidate[] = [];
    const keywords = this.extractKeywords(description);

    for (const keyword of keywords) {
      // aria-label
      const labelElements = this.$(`[aria-label*="${keyword}"]`);
      labelElements.each((_, el) => {
        const $el = this.$(el);
        const label = $el.attr('aria-label');
        if (label) {
          candidates.push({
            selector: `[aria-label="${label}"]`,
            confidence: 0.85,
            strategy: 'aria-label',
            reasoning: `ARIA label: ${label}`
          });
        }
      });

      // role
      const roleElements = this.$(`[role*="${keyword}"]`);
      roleElements.each((_, el) => {
        const $el = this.$(el);
        const role = $el.attr('role');
        if (role) {
          candidates.push({
            selector: `[role="${role}"]`,
            confidence: 0.80,
            strategy: 'role',
            reasoning: `ARIA role: ${role}`
          });
        }
      });
    }

    return candidates;
  }

  private generateTextSelectors(description: string): SelectorCandidate[] {
    const candidates: SelectorCandidate[] = [];
    const keywords = this.extractKeywords(description);

    for (const keyword of keywords) {
      // Button with text
      const buttons = this.$(`button`);
      buttons.each((_, el) => {
        const $el = this.$(el);
        const text = $el.text().trim().toLowerCase();
        if (text.includes(keyword.toLowerCase())) {
          const exactText = $el.text().trim();
          candidates.push({
            selector: `button:has-text("${exactText}")`,
            confidence: 0.65,
            strategy: 'text-content',
            reasoning: `Button with text: "${exactText}"`
          });
        }
      });

      // Link with text
      const links = this.$(`a`);
      links.each((_, el) => {
        const $el = this.$(el);
        const text = $el.text().trim().toLowerCase();
        if (text.includes(keyword.toLowerCase())) {
          const exactText = $el.text().trim();
          candidates.push({
            selector: `a:has-text("${exactText}")`,
            confidence: 0.65,
            strategy: 'text-content',
            reasoning: `Link with text: "${exactText}"`
          });
        }
      });
    }

    return candidates;
  }

  private generatePositionSelectors(description: string): SelectorCandidate[] {
    const candidates: SelectorCandidate[] = [];
    const keywords = this.extractKeywords(description);

    for (const keyword of keywords) {
      const elements = this.$(`[class*="${keyword}"]`);
      elements.each((_, el) => {
        const $el = this.$(el);
        const tagName = (el as any).name;
        const parent = $el.parent();
        
        if (parent.length > 0) {
          const parentTag = (parent[0] as any).name;
          const nthChild = $el.index() + 1;
          
          candidates.push({
            selector: `${parentTag} > ${tagName}:nth-child(${nthChild})`,
            confidence: 0.50,
            strategy: 'position',
            reasoning: `Position-based: ${nthChild}th child of ${parentTag}`
          });
        }
      });
    }

    return candidates;
  }

  /**
   * Validate selectors against live DOM using Playwright
   */
  async validateSelectors(page: Page, candidates: SelectorCandidate[]): Promise<SelectorCandidate[]> {
    const validated: SelectorCandidate[] = [];

    for (const candidate of candidates) {
      try {
        // Convert Playwright-specific syntax to standard CSS
        const cssSelector = candidate.selector.replace(/:has-text\("([^"]+)"\)/, '');
        
        const count = await page.locator(cssSelector).count();
        
        if (count === 0) {
          console.log(`[SELECTOR_VALIDATOR] ❌ ${candidate.selector} - matches 0 elements`);
          candidate.isValid = false;
          continue;
        }
        
        if (count > 1) {
          console.log(`[SELECTOR_VALIDATOR] ⚠️  ${candidate.selector} - matches ${count} elements (not unique)`);
          candidate.confidence = candidate.confidence * 0.5; // Penalize non-unique
          candidate.isValid = true;
          validated.push(candidate);
          continue;
        }

        // Check if visible
        const isVisible = await page.locator(cssSelector).isVisible();
        if (!isVisible) {
          console.log(`[SELECTOR_VALIDATOR] ⚠️  ${candidate.selector} - element not visible`);
          candidate.confidence = candidate.confidence * 0.7; // Penalize invisible
          candidate.isValid = true;
          validated.push(candidate);
          continue;
        }

        console.log(`[SELECTOR_VALIDATOR] ✅ ${candidate.selector} - valid unique visible element`);
        candidate.isValid = true;
        validated.push(candidate);

      } catch (error) {
        console.error(`[SELECTOR_VALIDATOR] ❌ ${candidate.selector} - invalid CSS:`, error);
        candidate.isValid = false;
      }
    }

    // Re-sort by confidence after validation adjustments
    return validated.sort((a, b) => b.confidence - a.confidence);
  }

  private extractKeywords(text: string): string[] {
    const stopWords = ['the', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'a', 'an'];
    return text.toLowerCase()
      .split(/\s+/)
      .filter(word => word.length > 2 && !stopWords.includes(word));
  }

  private isStableId(id: string): boolean {
    const generatedPatterns = [
      /^\d+$/,                    // Pure numbers
      /^[a-f0-9]{8,}$/i,         // Hex strings (IDs)
      /^[a-z0-9]{20,}$/i,        // Random strings
      /-\d{10,}$/,               // Timestamps
      /^[a-z]+-\d+-\d+/,         // Generated patterns
      /template--\d+/,           // Shopify templates
      /slide-\d+/,               // Dynamic slides
    ];
    
    return !generatedPatterns.some(pattern => pattern.test(id));
  }

  private isStableClass(className: string): boolean {
    const stablePatterns = [
      /^[a-z]+-[a-z]+$/,         // BEM-like
      /^[a-z]+__[a-z]+$/,        // BEM block__element
      /^[a-z]+--[a-z]+$/,        // BEM block--modifier
      /^[a-z]+$/,                // Simple words
    ];
    
    const generatedPatterns = [
      /^\d+$/,
      /^[a-f0-9]{8,}$/i,
      /^[a-z0-9]{20,}$/i,
      /-\d{10,}$/,
    ];
    
    return stablePatterns.some(p => p.test(className)) && 
           !generatedPatterns.some(p => p.test(className));
  }
}

// Factory function
export function createSelectorGenerator(html: string): SelectorGenerator {
  return new SelectorGenerator(html);
}
</file>

<file path="src/features/variant_generation/smart-screenshot-strategy.ts">
// Smart Screenshot Strategy
// Determines the best area to screenshot based on hypothesis and element context

import * as cheerio from 'cheerio';

export interface ScreenshotStrategy {
  type: 'element' | 'section' | 'viewport' | 'fullpage';
  selector?: string;
  description: string;
  confidence: number;
  reasoning: string;
}

export interface ElementContext {
  element: {
    tagName: string;
    text?: string;
    attributes: Record<string, string>;
  };
  parent?: {
    tagName: string;
    classes: string[];
    text?: string;
  };
  siblings?: Array<{
    tagName: string;
    text?: string;
    classes: string[];
  }>;
  section?: {
    heading?: string;
    classes: string[];
  };
}

export class SmartScreenshotStrategy {
  private $: cheerio.CheerioAPI;
  private hypothesis: string;

  constructor(html: string, hypothesis: string) {
    this.$ = cheerio.load(html);
    this.hypothesis = hypothesis;
  }

  // Main method to determine the best screenshot strategy
  async determineScreenshotStrategy(targetSelector?: string): Promise<ScreenshotStrategy[]> {
    const strategies: ScreenshotStrategy[] = [];

    // Strategy 1: Target element with context (highest priority)
    if (targetSelector) {
      const elementStrategy = this.createElementStrategy(targetSelector);
      if (elementStrategy) {
        strategies.push(elementStrategy);
      }
    }

    // Strategy 2: Section-based strategy (if we can identify a section)
    const sectionStrategy = this.createSectionStrategy();
    if (sectionStrategy) {
      strategies.push(sectionStrategy);
    }

    // Strategy 3: Hypothesis-based strategy (fallback)
    const hypothesisStrategy = this.createHypothesisStrategy();
    if (hypothesisStrategy) {
      strategies.push(hypothesisStrategy);
    }

    // Strategy 4: Viewport strategy (always available)
    strategies.push({
      type: 'viewport',
      description: 'Screenshot the current viewport',
      confidence: 0.5,
      reasoning: 'Fallback to viewport when other strategies fail'
    });

    // Strategy 5: Full page strategy (last resort)
    strategies.push({
      type: 'fullpage',
      description: 'Screenshot the entire page',
      confidence: 0.3,
      reasoning: 'Last resort when all other strategies fail'
    });

    // Sort by confidence (highest first)
    return strategies.sort((a, b) => b.confidence - a.confidence);
  }

  // Strategy 1: Target element with context
  private createElementStrategy(targetSelector: string): ScreenshotStrategy | null {
    try {
      const element = this.$(targetSelector).first();
      if (element.length === 0) {
        return null;
      }

      const context = this.getElementContext(element);
      const section = this.findContainingSection(element);

      // Determine the best screenshot approach based on context
      if (section) {
        return {
          type: 'section',
          selector: section.selector,
          description: `Screenshot the ${section.name} section containing the target element`,
          confidence: 0.9,
          reasoning: `Target element is within a clear section: ${section.name}`
        };
      } else if (context.parent) {
        return {
          type: 'element',
          selector: this.generateParentSelector(element),
          description: `Screenshot the parent container of the target element`,
          confidence: 0.8,
          reasoning: `Target element is within a parent container: ${context.parent.tagName}`
        };
      } else {
        return {
          type: 'element',
          selector: targetSelector,
          description: `Screenshot the target element directly`,
          confidence: 0.7,
          reasoning: 'Direct screenshot of target element'
        };
      }
    } catch (error) {
      console.warn(`[SCREENSHOT_STRATEGY] Failed to create element strategy:`, error);
      return null;
    }
  }

  // Strategy 2: Section-based strategy
  private createSectionStrategy(): ScreenshotStrategy | null {
    const sectionKeywords = this.extractSectionKeywords(this.hypothesis);
    
    for (const keyword of sectionKeywords) {
      // Look for headings containing the keyword
      const headings = this.$(`h1, h2, h3, h4, h5, h6:contains("${keyword}")`);
      
      if (headings.length > 0) {
        const heading = headings.first();
        const section = this.findSectionFromHeading(heading);
        
        if (section) {
          return {
            type: 'section',
            selector: section.selector,
            description: `Screenshot the '${keyword}' section`,
            confidence: 0.85,
            reasoning: `Found section with heading containing '${keyword}'`
          };
        }
      }
    }

    return null;
  }

  // Strategy 3: Hypothesis-based strategy
  private createHypothesisStrategy(): ScreenshotStrategy | null {
    const keywords = this.extractKeywords(this.hypothesis);
    
    // Look for elements that might be related to the hypothesis
    for (const keyword of keywords) {
      // Look for buttons, links, or interactive elements
      const interactiveElements = this.$(`button:contains("${keyword}"), a:contains("${keyword}"), input[value*="${keyword}"]`);
      
      if (interactiveElements.length > 0) {
        const element = interactiveElements.first();
        const context = this.getElementContext(element);
        
        if (context.parent) {
          return {
            type: 'element',
            selector: this.generateParentSelector(element),
            description: `Screenshot the area containing '${keyword}'`,
            confidence: 0.75,
            reasoning: `Found interactive element related to '${keyword}'`
          };
        }
      }
    }

    return null;
  }

  // Helper methods
  private getElementContext(element: cheerio.Cheerio<any>): ElementContext {
    const el = element[0];
    if (!el || el.type !== 'tag') {
      return { element: { tagName: 'unknown', attributes: {} } };
    }

    const tagName = el.name;
    const text = element.text().trim();
    const attributes: Record<string, string> = {};
    
    if (el.attribs) {
      Object.keys(el.attribs).forEach(key => {
        attributes[key] = el.attribs[key];
      });
    }

    // Get parent context
    const parent = element.parent();
    let parentContext;
    if (parent.length > 0 && parent[0].type === 'tag') {
      parentContext = {
        tagName: parent[0].name,
        classes: parent.attr('class')?.split(' ').filter(c => c.trim()) || [],
        text: parent.text().trim()
      };
    }

    // Get sibling context
    const siblings = element.siblings().slice(0, 3); // First 3 siblings
    const siblingContext: Array<{ tagName: string; text: string; classes: string[] }> = [];
    siblings.each((_, sibling) => {
      const $sibling = this.$(sibling);
      siblingContext.push({
        tagName: sibling.type === 'tag' ? (sibling as any).name : 'unknown',
        text: $sibling.text().trim(),
        classes: $sibling.attr('class')?.split(' ').filter(c => c.trim()) || []
      });
    });

    return {
      element: { tagName, text, attributes },
      parent: parentContext,
      siblings: siblingContext
    };
  }

  private findContainingSection(element: cheerio.Cheerio<any>): { name: string; selector: string } | null {
    // Look for common section containers, prioritizing more specific ones
    const sectionSelectors = [
      '.product-card',
      '.product-card-wrapper',
      '.card',
      '.product-item',
      '.product',
      '.featured-collection',
      '.collection',
      '.banner',
      '.hero',
      'section:not(.shopify-section)',
      '.section:not(.shopify-section)',
      '[class*="section"]:not(.shopify-section)',
      '.container',
      '.content',
      '.main'
    ];

    for (const selector of sectionSelectors) {
      const section = element.closest(selector);
      if (section.length > 0) {
        const sectionText = section.text().trim();
        const sectionName = this.extractSectionName(sectionText);
        
        // Skip overly broad sections like .shopify-section
        if (sectionName === 'Section' && selector.includes('shopify-section')) {
          continue;
        }
        
        return {
          name: sectionName,
          selector: this.generateSectionSelector(section)
        };
      }
    }

    return null;
  }

  private findSectionFromHeading(heading: cheerio.Cheerio<any>): { name: string; selector: string } | null {
    // Find the section that contains this heading, prioritizing specific containers
    const sectionSelectors = [
      '.product-card',
      '.product-card-wrapper',
      '.card',
      '.product-item',
      '.product',
      '.featured-collection',
      '.collection',
      '.banner',
      '.hero',
      'section:not(.shopify-section)',
      '.section:not(.shopify-section)',
      '[class*="section"]:not(.shopify-section)',
      '.container',
      '.content'
    ];
    
    for (const selector of sectionSelectors) {
      const section = heading.closest(selector);
      if (section.length > 0) {
        const sectionText = section.text().trim();
        const sectionName = this.extractSectionName(sectionText);
        
        // Skip overly broad sections
        if (sectionName === 'Section' && selector.includes('shopify-section')) {
          continue;
        }
        
        return {
          name: sectionName,
          selector: this.generateSectionSelector(section)
        };
      }
    }

    return null;
  }

  private extractSectionName(sectionText: string): string {
    // Extract a meaningful name from the section text
    const lines = sectionText.split('\n').filter(line => line.trim().length > 0);
    const firstLine = lines[0]?.trim();
    
    if (firstLine && firstLine.length < 50) {
      return firstLine;
    }
    
    return 'Section';
  }

  private generateSectionSelector(section: cheerio.Cheerio<any>): string {
    const el = section[0];
    if (!el || el.type !== 'tag') {
      return 'body';
    }

    // Try to create a stable selector for the section
    const id = section.attr('id');
    if (id && this.isStableId(id)) {
      return `#${id}`;
    }

    const classes = section.attr('class')?.split(' ').filter(c => c.trim()) || [];
    const stableClasses = classes.filter(c => this.isStableClass(c));
    
    if (stableClasses.length > 0) {
      return `.${stableClasses[0]}`;
    }

    return el.name;
  }

  private generateParentSelector(element: cheerio.Cheerio<any>): string {
    const parent = element.parent();
    if (parent.length === 0) {
      return 'body';
    }

    const el = parent[0];
    if (!el || el.type !== 'tag') {
      return 'body';
    }

    const id = parent.attr('id');
    if (id && this.isStableId(id)) {
      return `#${id}`;
    }

    const classes = parent.attr('class')?.split(' ').filter(c => c.trim()) || [];
    const stableClasses = classes.filter(c => this.isStableClass(c));
    
    if (stableClasses.length > 0) {
      return `.${stableClasses[0]}`;
    }

    return el.name;
  }

  private extractSectionKeywords(hypothesis: string): string[] {
    // Extract keywords that might indicate sections
    const sectionKeywords = ['section', 'area', 'part', 'zone', 'block', 'component'];
    const words = hypothesis.toLowerCase().split(/\s+/);
    
    return words.filter(word => 
      word.length > 3 && 
      (sectionKeywords.some(keyword => word.includes(keyword)) || 
       word.includes('price') || word.includes('button') || word.includes('header'))
    );
  }

  private extractKeywords(hypothesis: string): string[] {
    const words = hypothesis.toLowerCase().split(/\s+/);
    return words.filter(word => 
      word.length > 2 && 
      !['the', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'a', 'an'].includes(word)
    );
  }

  private isStableId(id: string): boolean {
    const generatedPatterns = [
      /template--\d+/,
      /slide-\d+/,
      /section-\d+/,
      /block-\d+/,
      /shopify-section-\w+/,
      /^\d+$/,
      /^[a-f0-9]{8,}$/i,
      /^[a-z0-9]{20,}$/i,
      /-\d{10,}$/,
      /^[a-z]+-\d+-\d+/
    ];
    
    return !generatedPatterns.some(pattern => pattern.test(id));
  }

  private isStableClass(className: string): boolean {
    const stablePatterns = [
      /^[a-z]+-[a-z]+$/,
      /^[a-z]+__[a-z]+$/,
      /^[a-z]+--[a-z]+$/,
      /^[a-z]+$/,
      /^[a-z]+-[a-z]+-[a-z]+$/
    ];
    
    const generatedPatterns = [
      /^\d+$/,
      /^[a-f0-9]{8,}$/i,
      /^[a-z0-9]{20,}$/i,
      /-\d{10,}$/,
      /^[a-z]+-\d+/,
      /template--\d+/
    ];
    
    return stablePatterns.some(pattern => pattern.test(className)) && 
           !generatedPatterns.some(pattern => pattern.test(className));
  }
}

// Factory function
export function createSmartScreenshotStrategy(html: string, hypothesis: string): SmartScreenshotStrategy {
  return new SmartScreenshotStrategy(html, hypothesis);
}
</file>

<file path="src/features/variant_generation/variant-improvement.ts">
import { generateObject } from 'ai';
import { google } from '@ai-sdk/google';
import { z } from 'zod';
import { getVariantGenerationAIConfig } from '@shared/ai-config';

const improvedVariantSchema = z.object({
    javascript_code: z.string().describe("The improved JavaScript code based on the feedback"),
    improvements_made: z.array(z.string()).describe("List of specific improvements made based on the feedback"),
    confidence: z.number().min(0).max(1).describe("Confidence that the improvements address the feedback (0-1)")
});

export interface VariantImprovementRequest {
    originalCode: string;
    targetSelector: string;
    variantDescription: string;
    userFeedback: string;
    screenshot?: string;
}

export class VariantImprovementService {
    async improveVariant(request: VariantImprovementRequest): Promise<{
        javascript_code: string;
        improvements_made: string[];
        confidence: number;
    }> {
        const aiConfig = getVariantGenerationAIConfig();

        const prompt = this.buildImprovementPrompt(request);

        const messages: any[] = [
            {
                role: 'user',
                content: request.screenshot ? [
                    { type: "text", text: prompt },
                    { type: "image", image: request.screenshot }
                ] : [
                    { type: "text", text: prompt }
                ]
            }
        ];

        const result = await generateObject({
            model: google(aiConfig.model),
            schema: improvedVariantSchema,
            messages
        });

        return result.object;
    }

    private buildImprovementPrompt(request: VariantImprovementRequest): string {
        return `You are a UX/UI design and frontend development expert specializing in A/B testing optimization.

## Current Variant
Description: ${request.variantDescription}
Target Selector: ${request.targetSelector}

## Current JavaScript Code
\`\`\`javascript
${request.originalCode}
\`\`\`

## User Feedback
"${request.userFeedback}"

## Your Task
Improve the variant's JavaScript code to address the user's feedback, focusing on both visual design and user experience.

## Design & UX Analysis Framework
1. **Visual Hierarchy**: Assess if the feedback relates to visual prominence, spacing, or layout issues
2. **Alignment & Positioning**: Check for centering, alignment, or positioning problems
3. **Typography**: Consider font sizes, weights, line-height, and readability
4. **Color & Contrast**: Evaluate if colors need adjustment for better visibility or brand consistency
5. **Spacing & Padding**: Analyze margin, padding, and whitespace issues
6. **Responsive Design**: Ensure the solution works across different screen sizes
7. **Interaction & Animation**: Consider hover states, transitions, and micro-interactions
8. **Accessibility**: Maintain WCAG compliance and keyboard navigation

## Common UX/Design Issues to Check
- **"Not centered"**: Use flexbox/grid, check parent containers, consider transform: translate
- **"Too small/large"**: Adjust font-size, padding, min-height/width
- **"Hard to see"**: Increase contrast, adjust colors, add shadows or borders
- **"Doesn't stand out"**: Enhance visual weight with color, size, or positioning
- **"Looks out of place"**: Match existing design patterns, check border-radius, shadows
- **"Not clickable looking"**: Add cursor:pointer, hover states, button-like appearance
- **"Moves other content"**: Use position:absolute/fixed, adjust margins carefully

## CSS Properties Commonly Needed
- Positioning: position, top, left, transform, z-index
- Layout: display, flex properties, grid properties, width, height
- Spacing: margin, padding, gap
- Typography: font-size, font-weight, line-height, text-transform, letter-spacing
- Visual: background, color, border, border-radius, box-shadow
- Animation: transition, animation, transform
- Responsive: media queries, viewport units (vw, vh), clamp()

## Implementation Requirements
1. PRESERVE the variant's core functionality
2. USE CSS best practices for the specific issue
3. INCLUDE smooth transitions (0.3s ease) for any state changes
4. ENSURE cross-browser compatibility (use prefixes if needed)
5. ADD comments explaining design decisions
6. TEST for common viewport sizes (mobile: 375px, tablet: 768px, desktop: 1920px)
7. MAINTAIN existing brand colors and fonts where possible

## Code Structure
\`\`\`javascript
(function() {
    'use strict';

    // Clear documentation of what the improvement addresses
    // E.g., "Fix: Center button horizontally and vertically within container"

    // Your improved code here
    // Include inline comments for complex CSS calculations

})();
\`\`\`

${request.screenshot ? '## Visual Context\nThe screenshot shows the current appearance. Focus on the specific visual/UX issue mentioned in the feedback and provide a precise CSS solution.' : ''}

Provide improved JavaScript that specifically addresses the design/UX feedback with appropriate CSS modifications.`;
    }
}

export function createVariantImprovementService(): VariantImprovementService {
    return new VariantImprovementService();
}
</file>

<file path="src/features/variant_generation/visual-refinement.ts">
// Visual Refinement Service - Second stage for polishing generated code
import { z } from 'zod';
import { generateObject } from 'ai';
import { google } from '@ai-sdk/google';
import { getVariantGenerationAIConfig } from '@shared/ai-config';
import { DesignSystem } from './design-system-extractor';

// Schema for refined code output
const refinedCodeSchema = z.object({
  javascript_code: z.string().describe('Refined JavaScript with professional CSS'),
  css_improvements: z.array(z.string()).describe('List of visual improvements made'),
  accessibility_fixes: z.array(z.string()).describe('Accessibility improvements applied')
});

export class VisualRefinementService {
  async refineVariantCode(
    originalCode: string,
    variantDescription: string,
    designSystem: DesignSystem,
    screenshot: string
  ): Promise<{ javascript_code: string; improvements: string[] }> {
    const prompt = `You are a SENIOR UI/UX ENGINEER specializing in creating pixel-perfect, high-converting web interfaces.

CURRENT VARIANT CODE:
${originalCode}

VARIANT DESCRIPTION:
${variantDescription}

DESIGN SYSTEM:
Typography:
- Primary Font: ${designSystem.typography.primary_font}
- Button Font Size: ${designSystem.typography.heading_sizes.button}
- Font Weight Bold: ${designSystem.typography.font_weights.bold}
- Text Transform: ${designSystem.typography.text_transform_buttons}

Colors:
- Primary Button: ${designSystem.colors.primary_button_bg}
- Button Text: ${designSystem.colors.primary_button_text}
- Hover BG: ${designSystem.colors.primary_button_hover_bg}
- Accent: ${designSystem.colors.accent_color}

Spacing:
- Button Padding: ${designSystem.spacing.button_padding}
- Button Margin: ${designSystem.spacing.button_margin}

Effects:
- Border Radius: ${designSystem.borders.button_radius}
- Shadow: ${designSystem.shadows.button_shadow}
- Hover Shadow: ${designSystem.shadows.button_hover_shadow}
- Transition: ${designSystem.animations.transition_duration} ${designSystem.animations.transition_timing}
- Hover Transform: ${designSystem.animations.button_hover_transform}

YOUR TASK:
Refine the provided JavaScript code to create a VISUALLY STUNNING implementation that:

1. VISUAL POLISH:
   - Add smooth transitions for ALL state changes (hover, focus, active)
   - Include professional box-shadows with proper layering
   - Implement subtle but effective micro-animations
   - Use the exact design system values provided
   - Add gradient effects if the brand uses them
   - Include proper :active and :focus states

2. MODERN CSS TECHNIQUES:
   - Use CSS custom properties for maintainable values
   - Add backdrop-filter effects where appropriate
   - Include transform3d for hardware acceleration
   - Use will-change for performance optimization
   - Add proper cubic-bezier easing functions

3. ACCESSIBILITY:
   - Ensure minimum 4.5:1 color contrast ratio
   - Add focus-visible styles for keyboard navigation
   - Include proper ARIA attributes
   - Respect prefers-reduced-motion
   - Maintain 44px minimum touch targets

4. RESPONSIVE DESIGN:
   - Add mobile-specific adjustments
   - Include proper touch states for mobile
   - Scale fonts and padding appropriately

5. CROSS-BROWSER:
   - Include vendor prefixes where needed
   - Add fallbacks for older browsers
   - Test for Safari-specific issues

CRITICAL REQUIREMENTS:
- The code must be a self-contained IIFE
- Use inline styles or inject a <style> tag - do NOT rely on existing CSS classes
- Include error handling with try-catch
- Make it work on both desktop and mobile
- The visual quality must be EXCEPTIONAL - like it was designed by a top agency

Return the refined JavaScript code with all visual improvements integrated.`;

    const aiConfig = getVariantGenerationAIConfig();

    try {
      const result = await generateObject({
        model: google(aiConfig.model),
        schema: refinedCodeSchema,
        messages: [
          {
            role: 'user',
            content: [
              { type: "text", text: prompt },
              { type: "image", image: this.toDataUrl(screenshot) }
            ]
          }
        ]
      });

      console.log('[VISUAL_REFINEMENT] Successfully refined variant code');
      console.log('[VISUAL_REFINEMENT] Improvements:', result.object.css_improvements.join(', '));
      console.log('[VISUAL_REFINEMENT] Accessibility fixes:', result.object.accessibility_fixes.join(', '));

      return {
        javascript_code: result.object.javascript_code,
        improvements: [
          ...result.object.css_improvements,
          ...result.object.accessibility_fixes
        ]
      };
    } catch (error) {
      console.error('[VISUAL_REFINEMENT] Failed to refine code:', error);
      // Return original code if refinement fails
      return {
        javascript_code: originalCode,
        improvements: ['Refinement failed - using original code']
      };
    }
  }

  private toDataUrl(b64: string): string {
    if (!b64) return '';
    if (b64.startsWith('data:')) return b64;
    return `data:image/png;base64,${b64}`;
  }
}
</file>

<file path="src/infra/config/langsmith.ts">
// LangSmith Configuration Service
import { wrapAISDK } from "langsmith/experimental/vercel";
import * as aiSDK from "ai";

export interface LangSmithConfig {
  enabled: boolean;
  apiKey?: string;
  project?: string;
  endpoint?: string;
}

export function getLangSmithConfig(): LangSmithConfig {
  const enabled = process.env.LANGCHAIN_TRACING_V2 === "true";
  
  return {
    enabled,
    apiKey: process.env.LANGCHAIN_API_KEY,
    project: process.env.LANGCHAIN_PROJECT || "omen-backend",
    endpoint: process.env.LANGCHAIN_ENDPOINT || "https://api.smith.langchain.com",
  };
}

export function createLangSmithWrapper() {
  const config = getLangSmithConfig();
  
  if (!config.enabled || !config.apiKey) {
    console.log("[LANGSMITH] Tracing disabled or API key not provided");
    return aiSDK;
  }

  console.log(`[LANGSMITH] Tracing enabled for project: ${config.project}`);
  return wrapAISDK(aiSDK);
}

// Export the wrapped AI SDK
export const ai = createLangSmithWrapper();
</file>

<file path="src/infra/dal/screenshot.ts">
// Screenshot Data Access Layer
import { prisma } from '@infra/prisma';

// Constants for variant identification
const NON_VARIANT_ID = '__NON_VARIANT__';

export interface ScreenshotOptions {
  viewport: { width: number; height: number };
  fullPage: boolean;
  quality: number;
}

export class ScreenshotDAL {
  /**
   * Get screenshot by ID
   */
  static async getById(screenshotId: string) {
    return await prisma.screenshot.findUnique({
      where: { id: screenshotId }
    });
  }

  /**
   * Get screenshot for project and page type
   */
  static async getScreenshot(
    projectId: string,
    pageType: 'home' | 'pdp' | 'about' | 'other',
    options: ScreenshotOptions
  ) {
    return await prisma.screenshot.findFirst({
      where: {
        projectId,
        pageType,
        variantId: NON_VARIANT_ID,
        viewportWidth: options.viewport.width,
        viewportHeight: options.viewport.height,
        fullPage: options.fullPage,
        quality: options.quality,
        expiresAt: { gt: new Date() }
      }
    });
  }

  /**
   * Save or update screenshot
   */
  static async upsertScreenshot(
    projectId: string,
    pageType: 'home' | 'pdp' | 'about' | 'other',
    url: string,
    options: ScreenshotOptions,
    screenshotData: string,
    htmlContent?: string,
    markdownContent?: string,
    variantId?: string,
    maxAge: number = 24 * 60 * 60 * 1000
  ) {
    const buffer = Buffer.from(screenshotData, 'base64');
    const expiresAt = new Date(Date.now() + maxAge);

    return await prisma.screenshot.upsert({
      where: {
        projectId_pageType_variantId_viewportWidth_viewportHeight_fullPage_quality: {
          projectId,
          pageType,
          variantId: variantId ?? NON_VARIANT_ID,
          viewportWidth: options.viewport.width,
          viewportHeight: options.viewport.height,
          fullPage: options.fullPage,
          quality: options.quality
        }
      },
      create: {
        projectId,
        url,
        pageType,
        variantId: variantId ?? NON_VARIANT_ID,
        viewportWidth: options.viewport.width,
        viewportHeight: options.viewport.height,
        fullPage: options.fullPage,
        quality: options.quality,
        data: buffer,
        htmlContent: htmlContent || null,
        markdownContent: markdownContent || null,
        fileSize: buffer.length,
        expiresAt
      },
      update: {
        data: buffer,
        htmlContent: htmlContent || undefined,
        markdownContent: markdownContent || undefined,
        fileSize: buffer.length,
        expiresAt,
        accessedAt: new Date()
      }
    });
  }

  /**
   * Update screenshot access tracking
   */
  static async updateAccessTracking(screenshotId: string) {
    return await prisma.screenshot.update({
      where: { id: screenshotId },
      data: {
        accessedAt: new Date(),
        accessCount: { increment: 1 }
      }
    });
  }

  /**
   * Delete expired screenshots
   */
  static async deleteExpired() {
    const result = await prisma.screenshot.deleteMany({
      where: { expiresAt: { lt: new Date() } }
    });
    return result.count;
  }

  /**
   * Get screenshot statistics for a project
   */
  static async getProjectStats(projectId: string) {
    const stats = await prisma.screenshot.aggregate({
      where: { projectId },
      _count: { id: true },
      _sum: { fileSize: true, accessCount: true }
    });

    return {
      totalScreenshots: stats._count.id || 0,
      totalSize: stats._sum.fileSize || 0,
      accessCount: stats._sum.accessCount || 0
    };
  }

  /**
   * Get detailed project screenshot stats with breakdown by type
   */
  static async getDetailedProjectStats(projectId: string) {
    const stats = await prisma.screenshot.aggregate({
      where: { projectId },
      _count: { id: true },
      _sum: { fileSize: true, accessCount: true },
      _max: { accessedAt: true }
    });

    const screenshotsByType = await prisma.screenshot.groupBy({
      by: ['pageType'],
      where: { projectId },
      _count: { id: true }
    });

    const totalScreenshots = stats._count.id || 0;
    const totalSize = stats._sum.fileSize || 0;
    const totalAccesses = stats._sum.accessCount || 0;

    return {
      totalScreenshots,
      totalSize,
      cacheHitRate: totalAccesses,
      screenshotsByType: screenshotsByType.reduce((acc, item) => {
        acc[item.pageType] = item._count.id;
        return acc;
      }, {} as Record<string, number>),
      averageSize: totalScreenshots > 0 ? totalSize / totalScreenshots : 0,
      lastAccessed: stats._max.accessedAt
    };
  }

  /**
   * Get global screenshot statistics
   */
  static async getGlobalStats() {
    const stats = await prisma.screenshot.aggregate({
      _count: { id: true },
      _sum: { fileSize: true, accessCount: true }
    });

    const projectCount = await prisma.screenshot.groupBy({
      by: ['projectId'],
      _count: { id: true }
    });

    const totalScreenshots = stats._count.id || 0;
    const totalSize = stats._sum.fileSize || 0;
    const totalProjects = projectCount.length;
    const totalAccesses = stats._sum.accessCount || 0;

    return {
      totalScreenshots,
      totalSize,
      totalProjects,
      averageScreenshotsPerProject: totalProjects > 0 ? totalScreenshots / totalProjects : 0,
      cacheHitRate: totalAccesses
    };
  }

  /**
   * Get screenshot usage trends over time
   */
  static async getUsageTrends(projectId: string, days: number) {
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);

    const trends = await prisma.screenshot.groupBy({
      by: ['createdAt'],
      where: {
        projectId,
        createdAt: { gte: startDate }
      },
      _count: { id: true },
      _sum: { accessCount: true }
    });

    // Group by date and calculate trends
    const trendsByDate = new Map<string, { screenshots: number; cacheHits: number }>();

    for (const trend of trends) {
      const date = trend.createdAt.toISOString().split('T')[0];
      const existing = trendsByDate.get(date) || { screenshots: 0, cacheHits: 0 };
      trendsByDate.set(date, {
        screenshots: existing.screenshots + trend._count.id,
        cacheHits: existing.cacheHits + (trend._sum.accessCount || 0)
      });
    }

    // Fill in missing dates with zeros
    const result = [];
    for (let i = days - 1; i >= 0; i--) {
      const date = new Date();
      date.setDate(date.getDate() - i);
      const dateStr = date.toISOString().split('T')[0];
      const trend = trendsByDate.get(dateStr) || { screenshots: 0, cacheHits: 0 };

      result.push({
        date: dateStr,
        screenshots: trend.screenshots,
        cacheHits: trend.cacheHits,
        cacheMisses: Math.max(0, trend.screenshots - trend.cacheHits)
      });
    }

    return result;
  }

  /**
   * Get top cached URLs by access count
   */
  static async getTopCachedUrls(projectId: string, limit: number) {
    const topUrls = await prisma.screenshot.findMany({
      where: { projectId },
      orderBy: { accessCount: 'desc' },
      take: limit,
      select: {
        url: true,
        pageType: true,
        accessCount: true,
        accessedAt: true,
        fileSize: true
      }
    });

    return topUrls.map(item => ({
      url: item.url,
      pageType: item.pageType,
      accessCount: item.accessCount,
      lastAccessed: item.accessedAt,
      fileSize: item.fileSize
    }));
  }
}
</file>

<file path="src/infra/dal/variant-job.ts">
import { prisma } from '@infra/prisma';
import { JobStatus } from '@prisma/client';

export interface CreateVariantJobData {
    projectId: string;
}

export interface UpdateVariantJobData {
    status?: JobStatus;
    progress?: number;
    result?: any;
    error?: string;
    startedAt?: Date;
    completedAt?: Date;
}

export interface VariantJob {
    id: string;
    projectId: string;
    status: JobStatus;
    progress: number | null;
    result: any;
    error: string | null;
    createdAt: Date;
    startedAt: Date | null;
    completedAt: Date | null;
}

export class VariantJobDAL {
    static async createJob(data: CreateVariantJobData): Promise<VariantJob> {
        return await prisma.variantJob.create({
            data: {
                projectId: data.projectId,
                status: 'PENDING',
                progress: 0,
            },
        });
    }

    static async getJobById(jobId: string): Promise<VariantJob | null> {
        return await prisma.variantJob.findUnique({
            where: { id: jobId },
        });
    }

    static async getJobsByProject(
        projectId: string,
        limit?: number,
        offset?: number
    ): Promise<VariantJob[]> {
        return await prisma.variantJob.findMany({
            where: { projectId },
            orderBy: { createdAt: 'desc' },
            ...(limit && { take: limit }),
            ...(offset && { skip: offset }),
        });
    }

    static async updateJob(jobId: string, data: UpdateVariantJobData): Promise<VariantJob> {
        return await prisma.variantJob.update({
            where: { id: jobId },
            data: {
                ...data,
                ...(data.status === 'RUNNING' && !data.startedAt && { startedAt: new Date() }),
                ...(data.status === 'COMPLETED' && !data.completedAt && { completedAt: new Date() }),
                ...(data.status === 'FAILED' && !data.completedAt && { completedAt: new Date() }),
            },
        });
    }

    static async deleteJob(jobId: string): Promise<void> {
        await prisma.variantJob.delete({
            where: { id: jobId },
        });
    }

    static async getJobsByStatus(status: JobStatus, limit?: number): Promise<VariantJob[]> {
        return await prisma.variantJob.findMany({
            where: { status },
            orderBy: { createdAt: 'asc' },
            ...(limit && { take: limit }),
        });
    }

    static async cleanupOldJobs(olderThanDays: number = 7): Promise<number> {
        const cutoffDate = new Date();
        cutoffDate.setDate(cutoffDate.getDate() - olderThanDays);

        const result = await prisma.variantJob.deleteMany({
            where: {
                status: {
                    in: ['COMPLETED', 'FAILED'],
                },
                completedAt: {
                    lt: cutoffDate,
                },
            },
        });

        return result.count;
    }
}
</file>

<file path="src/infra/external/auth0/index.ts">
export * from './auth0';
</file>

<file path="src/infra/external/posthog/config.ts">
/**
 * PostHog Configuration
 * 
 * Configuration for PostHog analytics integration with EU host support
 */

export interface PostHogConfig {
  apiKey: string;
  host: string;
  projectId: string;
  timeout?: number;
  retryAttempts?: number;
}

export function getPostHogConfig(): PostHogConfig {
  const apiKey = process.env.POSTHOG_API_KEY;
  if (!apiKey) {
    throw new Error('POSTHOG_API_KEY environment variable is required');
  }

  const projectId = process.env.POSTHOG_PROJECT_ID;
  if (!projectId) {
    throw new Error('POSTHOG_PROJECT_ID environment variable is required');
  }

  // Default to EU host for GDPR compliance
  const host = process.env.POSTHOG_HOST || 'https://eu.posthog.com';
  
  return {
    apiKey,
    host,
    projectId,
    timeout: parseInt(process.env.POSTHOG_TIMEOUT || '10000'),
    retryAttempts: parseInt(process.env.POSTHOG_RETRY_ATTEMPTS || '3'),
  };
}
</file>

<file path="src/infra/external/posthog/service.ts">
/**
 * PostHog Service
 * 
 * Service for querying PostHog analytics data for experiment status
 */

import { PostHog } from 'posthog-node';
import fetch from 'node-fetch';
import { getPostHogConfig } from './config';
import type {
  PostHogQueryParams,
  PostHogQueryResponse,
  PostHogEvent,
} from './types';
import type { ExperimentStatus, VariantMetrics } from '../../../shared/types';
import {
  PostHogConnectionError,
  PostHogQueryError,
  PostHogRateLimitError,
} from '../../errors';

export class PostHogService {
  private client: PostHog;
  private config: ReturnType<typeof getPostHogConfig>;

  constructor() {
    this.config = getPostHogConfig();
    this.client = new PostHog(this.config.apiKey, {
      host: this.config.host,
    });
  }

  /**
   * Query PostHog for experiment analytics data
   */
  async queryExperimentMetrics(params: PostHogQueryParams): Promise<ExperimentStatus> {
    try {
      const { projectId, experimentId, startDate, endDate, primaryKPI, guardrails = [] } = params;
      const configProjectId = this.config.projectId;

      // Query pageviews for denominator
      const pageviewEvents = await this.queryEvents({
        projectId: configProjectId,
        experimentId,
        startDate,
        endDate,
        eventName: '$pageview',
        properties: {
          experimentId,
          projectId,
        },
      });

      // Query primary KPI events
      const primaryKPIEvents = await this.queryEvents({
        projectId: configProjectId,
        experimentId,
        startDate,
        endDate,
        eventName: primaryKPI,
        properties: {
          experimentId,
          projectId,
        },
      });

      // Query guardrail events if specified
      const guardrailEvents = guardrails.length > 0 
        ? await this.queryGuardrailEvents({
            projectId: configProjectId,
            experimentId,
            startDate,
            endDate,
            guardrails,
          })
        : {};

      // Aggregate metrics by variant
      const variantMetrics = this.aggregateVariantMetrics(
        pageviewEvents,
        primaryKPIEvents,
        guardrailEvents,
        primaryKPI
      );

      // Calculate traffic distribution (this would come from experiment DSL)
      const traffic = this.calculateTrafficDistribution(variantMetrics);

      // Find leader and calculate lift vs A
      const leader = this.findLeader(variantMetrics);
      const liftVsA = this.calculateLiftVsA(variantMetrics);

      return {
        state: 'running', // This would come from experiment status
        traffic,
        variants: variantMetrics,
        leader,
        liftVsA,
        meta: {
          timeframe: {
            start: startDate,
            end: endDate,
          },
          denominator: 'pageviews',
          totalSessions: pageviewEvents.length,
        },
      };
    } catch (error) {
      if (error instanceof PostHogConnectionError || error instanceof PostHogQueryError || error instanceof PostHogRateLimitError) {
        throw error;
      }
      
      if (error && typeof error === 'object' && 'message' in error) {
        const message = typeof error.message === 'string' ? error.message : 'Unknown PostHog error';
        throw new PostHogConnectionError({ originalError: message });
      }
      
      throw new PostHogConnectionError();
    }
  }

  /**
   * Query PostHog events using the Query API
   */
  private async queryEvents(params: {
    projectId: string;
    experimentId: string;
    startDate: string;
    endDate: string;
    eventName: string;
    properties: Record<string, unknown>;
  }): Promise<PostHogEvent[]> {
    const { projectId, experimentId, startDate, endDate, eventName, properties } = params;
    
    let lastError: Error | null = null;
    
    for (let attempt = 1; attempt <= (this.config.retryAttempts || 3); attempt++) {
      try {
        // Build HogQL query for events
        const whereConditions = [
          `event = '${eventName}'`,
          `properties.experimentId = '${experimentId}'`,
          `properties.projectId = '${projectId}'`,
          `timestamp >= '${startDate}'`,
          `timestamp <= '${endDate}'`
        ];

        // Add additional property filters
        for (const [key, value] of Object.entries(properties)) {
          if (key !== 'experimentId' && key !== 'projectId') {
            whereConditions.push(`properties.${key} = '${value}'`);
          }
        }

        const hogqlQuery = `
          SELECT 
            event,
            properties,
            timestamp,
            distinct_id
          FROM events 
          WHERE ${whereConditions.join(' AND ')}
          ORDER BY timestamp DESC
          LIMIT 10000
        `;

        const response = await this.executeQuery(projectId, {
          kind: 'HogQLQuery',
          query: hogqlQuery
        });

        // Transform PostHog response to our event format
        const events: PostHogEvent[] = response.results?.map((row: Record<string, unknown>) => ({
          event: row.event as string,
          properties: (row.properties as Record<string, unknown>) || {},
          timestamp: row.timestamp as string,
          distinct_id: row.distinct_id as string
        })) || [];

        return events;
      } catch (error) {
        lastError = error as Error;
        
        if (attempt < (this.config.retryAttempts || 3)) {
          // Wait before retry (exponential backoff)
          await new Promise(resolve => global.setTimeout(resolve, Math.pow(2, attempt) * 1000));
          continue;
        }
        
        // Handle specific error types
        if (error && typeof error === 'object' && 'status' in error) {
          const status = (error as Record<string, unknown>).status;
          if (status === 429) {
            const headers = (error as Record<string, unknown>).headers as Record<string, unknown> | undefined;
            const retryAfter = headers?.['retry-after'];
            throw new PostHogRateLimitError(parseInt(String(retryAfter)), error);
          }
          if (typeof status === 'number' && status >= 400 && status < 500) {
            throw new PostHogQueryError(`PostHog query failed: ${lastError.message}`, error);
          }
        }
        
        throw new PostHogConnectionError({ originalError: lastError.message });
      }
    }
    
    throw new PostHogConnectionError({ originalError: lastError?.message });
  }

  /**
   * Execute a PostHog Query API request
   */
  private async executeQuery(projectId: string, query: { kind: string; query: string }): Promise<PostHogQueryResponse> {
    const url = `${this.config.host}/api/projects/${projectId}/query/`;
    
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.config.apiKey}`,
      },
      body: JSON.stringify({ query }),
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      const error = new Error(`PostHog API error: ${response.status} ${response.statusText}`);
      (error as Error & { status: number; headers: Record<string, string>; data: unknown }).status = response.status;
      (error as Error & { status: number; headers: Record<string, string>; data: unknown }).headers = Object.fromEntries(response.headers.entries());
      (error as Error & { status: number; headers: Record<string, string>; data: unknown }).data = errorData;
      throw error;
    }

    const data = await response.json() as Record<string, unknown>;
    
    // Handle query status
    if (data.query_status === 'error') {
      throw new PostHogQueryError(`PostHog query error: ${data.error || 'Unknown error'}`, data);
    }

    return {
      results: (data.results as Record<string, unknown>[]) || [],
      hasMore: (data.hasMore as boolean) || false,
      next: data.next as string | undefined
    };
  }

  /**
   * Query guardrail events
   */
  private async queryGuardrailEvents(params: {
    projectId: string;
    experimentId: string;
    startDate: string;
    endDate: string;
    guardrails: string[];
  }): Promise<Record<string, PostHogEvent[]>> {
    const { experimentId, startDate, endDate, guardrails } = params;
    const configProjectId = this.config.projectId;
    const results: Record<string, PostHogEvent[]> = {};

    for (const guardrail of guardrails) {
      try {
        const events = await this.queryEvents({
          projectId: configProjectId,
          experimentId,
          startDate,
          endDate,
          eventName: guardrail,
          properties: {
            experimentId,
            projectId: params.projectId, // Keep the original projectId for filtering
          },
        });
        results[guardrail] = events;
      } catch (error) {
        // Log error but continue with other guardrails
        console.warn(`Failed to query guardrail ${guardrail}:`, error);
        results[guardrail] = [];
      }
    }

    return results;
  }

  /**
   * Aggregate metrics by variant
   */
  private aggregateVariantMetrics(
    pageviewEvents: PostHogEvent[],
    primaryKPIEvents: PostHogEvent[],
    guardrailEvents: Record<string, PostHogEvent[]>,
    primaryKPI: string
  ): VariantMetrics[] {
    const variantMap = new Map<string, {
      sessions: Set<string>;
      primaryKPICount: number;
      guardrails: Record<string, number>;
    }>();

    // Process pageview events for sessions
    for (const event of pageviewEvents) {
      const variantId = event.properties.variantId as string;
      const distinctId = event.distinct_id;
      
        if (variantId && distinctId) {
          if (!variantMap.has(variantId)) {
            variantMap.set(variantId, {
              sessions: new Set(),
              primaryKPICount: 0,
              guardrails: {},
            });
          }
          
          const variantData = variantMap.get(variantId);
          if (variantData) {
            variantData.sessions.add(distinctId);
          }
        }
    }

    // Process primary KPI events
    for (const event of primaryKPIEvents) {
      const variantId = event.properties.variantId as string;
      
      if (variantId && variantMap.has(variantId)) {
        const variantData = variantMap.get(variantId);
        if (variantData) {
          variantData.primaryKPICount++;
        }
      }
    }

    // Process guardrail events
    for (const [guardrail, events] of Object.entries(guardrailEvents)) {
      for (const event of events) {
        const variantId = event.properties.variantId as string;
        
        if (variantId && variantMap.has(variantId)) {
          const variant = variantMap.get(variantId);
          if (variant) {
            variant.guardrails[guardrail] = (variant.guardrails[guardrail] || 0) + 1;
          }
        }
      }
    }

    // Convert to VariantMetrics array
    const metrics: VariantMetrics[] = [];
    
    for (const [variantId, data] of variantMap.entries()) {
      const sessions = data.sessions.size;
      const primaryKPICount = data.primaryKPICount;
      const rate = sessions > 0 ? primaryKPICount / sessions : 0;

      const guardrails = this.calculateGuardrailLabels(data.guardrails, sessions);

      metrics.push({
        variantId,
        sessions,
        primaryKPI: {
          name: primaryKPI,
          count: primaryKPICount,
          rate,
        },
        guardrails: Object.keys(guardrails).length > 0 ? guardrails : undefined,
      });
    }

    return metrics.sort((a, b) => a.variantId.localeCompare(b.variantId));
  }

  /**
   * Calculate guardrail labels based on thresholds
   */
  private calculateGuardrailLabels(
    guardrailCounts: Record<string, number>,
    sessions: number
  ): Record<string, 'normal' | 'elevated'> {
    const labels: Record<string, 'normal' | 'elevated'> = {};
    
    for (const [guardrail, count] of Object.entries(guardrailCounts)) {
      // Simple threshold logic - in production, you'd want more sophisticated analysis
      const rate = sessions > 0 ? count / sessions : 0;
      
      switch (guardrail) {
        case 'lcp':
          // LCP > 2.5s is considered elevated
          labels.lcp = rate > 0.1 ? 'elevated' : 'normal';
          break;
        case 'js_errors':
          // JS error rate > 1% is considered elevated
          labels.jsErrors = rate > 0.01 ? 'elevated' : 'normal';
          break;
        case 'cls':
          // CLS > 0.1 is considered elevated
          labels.cls = rate > 0.1 ? 'elevated' : 'normal';
          break;
      }
    }
    
    return labels;
  }

  /**
   * Calculate traffic distribution from variant metrics
   */
  private calculateTrafficDistribution(metrics: VariantMetrics[]): Record<string, number> {
    const totalSessions = metrics.reduce((sum, m) => sum + m.sessions, 0);
    
    if (totalSessions === 0) {
      return {};
    }

    const distribution: Record<string, number> = {};
    for (const metric of metrics) {
      distribution[metric.variantId] = metric.sessions / totalSessions;
    }

    return distribution;
  }

  /**
   * Find the leading variant
   */
  private findLeader(metrics: VariantMetrics[]): string | undefined {
    if (metrics.length === 0) return undefined;

    return metrics.reduce((leader, current) => 
      current.primaryKPI.rate > leader.primaryKPI.rate ? current : leader
    ).variantId;
  }

  /**
   * Calculate lift vs variant A
   */
  private calculateLiftVsA(metrics: VariantMetrics[]): number | undefined {
    const variantA = metrics.find(m => m.variantId === 'A');
    if (!variantA || variantA.primaryKPI.rate === 0) return undefined;

    const otherVariants = metrics.filter(m => m.variantId !== 'A');
    if (otherVariants.length === 0) return undefined;

    // Calculate average lift of other variants vs A
    const totalLift = otherVariants.reduce((sum, variant) => {
      const lift = ((variant.primaryKPI.rate - variantA.primaryKPI.rate) / variantA.primaryKPI.rate) * 100;
      return sum + lift;
    }, 0);

    return totalLift / otherVariants.length;
  }

  /**
   * Close the PostHog client
   */
  async close(): Promise<void> {
    await this.client.shutdown();
  }
}
</file>

<file path="src/infra/external/shopify/config.ts">
/**
 * Shopify configuration module
 * Handles Shopify API configuration and validation
 */

export const shopifyConfig = {
  apiKey: process.env.SHOPIFY_API_KEY!,
  apiSecret: process.env.SHOPIFY_API_SECRET!,
  scopes: process.env.SHOPIFY_SCOPES || 'read_products,write_products,read_orders,write_orders, write_themes, read_themes',
  redirectUri: process.env.SHOPIFY_REDIRECT_URI!,
  encryptionKey: process.env.ENCRYPTION_KEY!,
};

// Validate required environment variables
const requiredEnvVars = [
  'SHOPIFY_API_KEY',
  'SHOPIFY_API_SECRET',
  'SHOPIFY_REDIRECT_URI',
  'ENCRYPTION_KEY',
];

for (const envVar of requiredEnvVars) {
  if (!process.env[envVar]) {
    throw new Error(`Missing required environment variable: ${envVar}`);
  }
}

// Validate encryption key length (should be 32 or 64 characters for AES-256)
if (shopifyConfig.encryptionKey.length !== 32 && shopifyConfig.encryptionKey.length !== 64) {
  throw new Error('ENCRYPTION_KEY must be exactly 32 or 64 characters long for AES-256 encryption');
}
</file>

<file path="src/infra/auth.ts">
import { betterAuth } from "better-auth";
import { bearer, openAPI, organization } from "better-auth/plugins";
import { prismaAdapter } from "better-auth/adapters/prisma";
import { prisma } from "./prisma";

export const auth = betterAuth({
  secret: process.env.BETTER_AUTH_SECRET!,
  baseURL: process.env.BETTER_AUTH_URL!,
  database: prismaAdapter(prisma, {
    provider: "postgresql",
  }),
  emailAndPassword: {
    enabled: true,
    autoSignIn: true, // Enable automatic session creation after sign-up/sign-in
    maxPasswordLength: 20,
    minPasswordLength: 8,
  },
  session: {
    expiresIn: 60 * 60 * 24 * 7, // 7 days
    updateAge: 60 * 60 * 24, // 1 day
  },
  plugins: [bearer(), organization(), openAPI()],
});

export type Auth = typeof auth;
</file>

<file path="src/interfaces/http/middleware/validation.ts">
import type { FastifyRequest, FastifyReply } from 'fastify';
import { ZodSchema } from 'zod';

/**
 * Generic validation middleware using Zod schemas
 */
export function validateBody<T>(schema: ZodSchema<T>) {
    return async (request: FastifyRequest, reply: FastifyReply) => {
        try {
            const validatedData = schema.parse(request.body);
            request.body = validatedData;
        } catch (error) {
            if (error instanceof Error) {
                return reply.status(400).send({
                    error: 'VALIDATION_ERROR',
                    message: error.message,
                });
            }
            return reply.status(400).send({
                error: 'VALIDATION_ERROR',
                message: 'Invalid request data',
            });
        }
    };
}
</file>

<file path="src/interfaces/http/plugins/better-auth-plugin.ts">
import { FastifyPluginAsync, FastifyRequest, FastifyReply } from "fastify";
import fp from "fastify-plugin";
import { auth } from "@infra/auth";

// Extend Fastify types for custom decorations
declare module "fastify" {
  interface FastifyInstance {
    authenticate: (
      request: FastifyRequest,
      reply: FastifyReply
    ) => Promise<void>;
  }

  interface FastifyRequest {
    session?: any;
  }
}

const betterAuthPlugin: FastifyPluginAsync = fp(async (fastify) => {
  fastify.decorate(
    "authenticate",
    async (request: FastifyRequest, reply: FastifyReply) => {
      try {
        const fetchHeaders = new Headers(request.headers as HeadersInit);

        // Verify session using Better Auth
        const sessionData = await auth.api.getSession({
          headers: fetchHeaders,
        });

        if (!sessionData || !sessionData.session || !sessionData.user) {
          return reply.code(401).send({ error: "Invalid or expired session" });
        }

        // Get user with project data from our database
        const { userService } = await import('@infra/dal/user');
        const user = await userService.getUserById(sessionData.user.id);

        // Attach session details to the request for later use
        request.session = sessionData.session;
        request.user = {
          sub: sessionData.user.id,
          email: sessionData.user.email,
          email_verified: sessionData.user.emailVerified,
          project: user?.project ? {
            id: user.project.id,
            shopDomain: user.project.shopDomain,
            brandAnalysis: user.project.brandAnalysis,
          } : null,
        };
      } catch (err) {
        return reply.code(500).send({ error: "Authentication error" });
      }
    }
  );
});

export default fp(betterAuthPlugin);
</file>

<file path="src/interfaces/http/schemas/chat.schema.ts">
import { z } from 'zod';

/**
 * Schema for UIMessage parts
 */
const UIMessagePartSchema = z.object({
    type: z.literal('text'),
    text: z.string(),
});

/**
 * Schema for UIMessage
 */
const UIMessageSchema = z.object({
    id: z.string().optional(),
    role: z.enum(['user', 'assistant', 'system']),
    parts: z.array(UIMessagePartSchema).min(1, 'Message must have at least one part'),
});

/**
 * Schema for chat request body
 */
export const ChatRequestSchema = z.object({
    messages: z.array(UIMessageSchema).min(1, 'At least one message is required'),
});

export type ChatRequest = z.infer<typeof ChatRequestSchema>;
</file>

<file path="src/interfaces/http/user/schemas.ts">
import { z } from 'zod';

/**
 * Base user schema derived from Prisma User model
 * This ensures consistency between database and validation
 */
const BaseUserSchema = z.object({
  id: z.string().cuid(),
  auth0Id: z.string(),
  email: z.string().email(),
  firstName: z.string(),
  lastName: z.string(),
  createdAt: z.date(),
  updatedAt: z.date(),
});

/**
 * Schema for user registration request body
 * Only includes fields that can be provided during registration
 */
export const UserRegistrationSchema = z.object({
  email: z.string()
    .email('Invalid email format')
    .min(1, 'Email is required'),
  shop: z.string()
    .min(1, 'Shop domain is required')
    .regex(/^[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]*\.myshopify\.com$/, 'Invalid Shopify domain format'),
  password: z.string()
    .min(8, 'Password must be at least 8 characters')
    .optional(),
  firstName: z.string()
    .min(1, 'First name is required')
    .max(50, 'First name must be less than 50 characters')
    .optional()
    .default(''),
  lastName: z.string()
    .min(1, 'Last name is required')
    .max(50, 'Last name must be less than 50 characters')
    .optional()
    .default(''),
});

/**
 * Schema for user creation (internal use)
 * Used when creating users in the database
 */
export const UserCreateSchema = z.object({
  auth0Id: z.string(),
  email: z.string().email(),
  firstName: z.string(),
  lastName: z.string(),
});

// Export types
export type UserRegistrationRequest = z.infer<typeof UserRegistrationSchema>;
export type UserCreateRequest = z.infer<typeof UserCreateSchema>;
export type User = z.infer<typeof BaseUserSchema>;
</file>

<file path="src/services/background-services.ts">
import { serviceContainer } from '@app/container';

export class BackgroundServicesManager {
  private services: Map<string, any> = new Map();
  private isRunning = false;

  async start(): Promise<void> {
    if (this.isRunning) {
      console.log('Background services are already running');
      return;
    }

    console.log('Starting background services...');

    try {
      // Start SQS Consumer
      const sqsConsumer = serviceContainer.getSQSConsumerService();
      await sqsConsumer.start();
      this.services.set('sqsConsumer', sqsConsumer);

      this.isRunning = true;
      console.log('Background services started successfully');
    } catch (error) {
      console.error('Failed to start background services:', error);
      throw error;
    }
  }

  async stop(): Promise<void> {
    if (!this.isRunning) {
      console.log('Background services are not running');
      return;
    }

    console.log('Stopping background services...');

    try {
      // Stop all services
      for (const [name, service] of this.services.entries()) {
        if (service && typeof service.stop === 'function') {
          await service.stop();
          console.log(`Stopped ${name}`);
        }
      }

      this.services.clear();
      this.isRunning = false;
      console.log('Background services stopped successfully');
    } catch (error) {
      console.error('Failed to stop background services:', error);
      throw error;
    }
  }

  isServicesRunning(): boolean {
    return this.isRunning;
  }

  getService(name: string): any {
    return this.services.get(name);
  }
}

// Singleton instance
export const backgroundServicesManager = new BackgroundServicesManager();
</file>

<file path="src/shared/normalization/url.ts">
/**
 * URL normalization and overlap detection utilities
 */

/**
 * Normalize a URL to a pattern for matching
 * This function intelligently converts URLs to patterns based on their structure
 *
 * Examples:
 * - https://example.com/ -> "/"
 * - https://example.com/products/shoe-123 -> "/products/[wildcard]"
 * - https://example.com/blog/2024/03/post -> "/blog/[wildcard]/[wildcard]/[wildcard]"
 * - /products/item -> "/products/[wildcard]"
 */
export function normalizeUrlToPattern(url: string): string {
  try {
    let pathname: string;

    // Handle full URLs
    if (url.startsWith('http://') || url.startsWith('https://')) {
      const u = new URL(url);
      pathname = u.pathname;
    } else {
      // Handle path-only strings
      pathname = url;
    }

    // Clean up the pathname
    pathname = pathname.replace(/\/+/g, '/'); // Replace multiple slashes with single
    pathname = pathname.replace(/\/$/, ''); // Remove trailing slash

    // Root path
    if (pathname === '' || pathname === '/') {
      return '/';
    }

    // Split path into segments
    const segments = pathname.split('/').filter(s => s.length > 0);

    if (segments.length === 0) {
      return '/';
    }

    // If URL already contains wildcards, return as-is
    if (pathname.includes('*')) {
      return pathname;
    }

    // For dynamic segments (containing IDs, slugs, etc), replace with wildcards
    // We keep the first segment as-is (usually the resource type)
    // and replace subsequent segments with wildcards if they look dynamic
    const pattern = segments.map((segment, index) => {
      // Keep the first segment (resource type) as-is
      if (index === 0) {
        return segment;
      }

      // Check if segment looks like a dynamic value
      // - Contains numbers mixed with letters (like IDs)
      // - Contains dashes or underscores (like slugs)
      // - Is a date-like pattern
      // - Is a UUID pattern
      const isDynamic =
        /\d/.test(segment) || // Contains numbers
        /[-_]/.test(segment) || // Contains dashes or underscores
        /^\d{4}$/.test(segment) || // Year-like
        /^[a-f0-9]{8}-?[a-f0-9]{4}-?[a-f0-9]{4}-?[a-f0-9]{4}-?[a-f0-9]{12}$/i.test(segment); // UUID-like

      return isDynamic ? '*' : segment;
    });

    return '/' + pattern.join('/');
  } catch (error) {
    // If parsing fails, return the original string
    return url;
  }
}

/**
 * Check if two URL patterns overlap
 * Handles both exact paths and wildcard patterns
 *
 * Examples:
 * - "/" and "/products" -> false
 * - "/products/[wildcard]" and "/products/shoe" -> true
 * - "/products/[wildcard]" and "/products/[wildcard]" -> true
 * - "/products/[wildcard]/reviews" and "/products/123/reviews" -> true
 */
export function urlOverlap(a: string, b: string): boolean {
  // Normalize both patterns
  const normalizedA = a.replace(/\/+$/, '') || '/';
  const normalizedB = b.replace(/\/+$/, '') || '/';

  // Exact match
  if (normalizedA === normalizedB) {
    return true;
  }

  // Convert patterns to regex for matching
  const patternToRegex = (pattern: string): RegExp => {
    // Escape special regex characters except *
    const escaped = pattern.replace(/[.+?^${}()|[\]\\]/g, '\\$&');
    // Replace * with regex equivalent
    const regexStr = '^' + escaped.replace(/\*/g, '[^/]+') + '(?:/|$)';
    return new RegExp(regexStr);
  };

  // Check if patterns have wildcards
  const aHasWildcard = normalizedA.includes('*');
  const bHasWildcard = normalizedB.includes('*');

  if (aHasWildcard && bHasWildcard) {
    // Both have wildcards - check if they could match the same URL
    // For simplicity, if they have the same prefix before first *, they overlap
    const aPrefix = normalizedA.split('*')[0];
    const bPrefix = normalizedB.split('*')[0];
    return aPrefix === bPrefix || aPrefix.startsWith(bPrefix) || bPrefix.startsWith(aPrefix);
  }

  if (aHasWildcard) {
    // Check if b matches pattern a
    const aRegex = patternToRegex(normalizedA);
    return aRegex.test(normalizedB + '/');
  }

  if (bHasWildcard) {
    // Check if a matches pattern b
    const bRegex = patternToRegex(normalizedB);
    return bRegex.test(normalizedA + '/');
  }

  // No wildcards, check if one is a prefix of the other
  return normalizedA.startsWith(normalizedB + '/') || normalizedB.startsWith(normalizedA + '/');
}

/**
 * Check if a specific URL matches a pattern
 */
export function urlMatchesPattern(url: string, pattern: string): boolean {
  const normalizedUrl = normalizeUrlToPattern(url);
  return urlOverlap(normalizedUrl, pattern);
}

/**
 * Extract URL pattern from experiment configuration
 * Handles various URL formats that might be stored in the database
 */
export function extractUrlPattern(urlConfig: string | { url?: string; pattern?: string } | undefined): string {
  if (!urlConfig) {
    return '/*'; // Default to all pages
  }

  if (typeof urlConfig === 'string') {
    return normalizeUrlToPattern(urlConfig);
  }

  if (typeof urlConfig === 'object') {
    return normalizeUrlToPattern(urlConfig.pattern || urlConfig.url || '/*');
  }

  return '/*';
}
</file>

<file path="src/shared/utils/url-utils.ts">
// URL Utilities
import * as cheerio from 'cheerio';

export function extractUrlsFromHtml(html: string, baseUrl: string): string[] {
  const candidates = [baseUrl];
  
  try {
    // Parse HTML with cheerio for better URL extraction
    const $ = cheerio.load(html);
    const baseUrlObj = new URL(baseUrl);
    
    // Extract all href attributes from anchor tags
    $('a[href]').each((_, element) => {
      const href = $(element).attr('href');
      if (!href) return;
      
      try {
        // Handle relative URLs
        if (href.startsWith('/')) {
          const fullUrl = `${baseUrlObj.origin}${href}`;
          if (!candidates.includes(fullUrl)) {
            candidates.push(fullUrl);
          }
        }
        // Handle absolute URLs on the same domain
        else if (href.startsWith('http')) {
          const hrefUrl = new URL(href);
          if (hrefUrl.hostname === baseUrlObj.hostname) {
            if (!candidates.includes(href)) {
              candidates.push(href);
            }
          }
        }
        // Handle protocol-relative URLs
        else if (href.startsWith('//')) {
          const fullUrl = `${baseUrlObj.protocol}${href}`;
          const hrefUrl = new URL(fullUrl);
          if (hrefUrl.hostname === baseUrlObj.hostname) {
            if (!candidates.includes(fullUrl)) {
              candidates.push(fullUrl);
            }
          }
        }
      } catch (urlError) {
        // Skip invalid URLs
        console.warn(`[URL_UTILS] Skipping invalid URL: ${href}`, urlError);
      }
    });
    
    console.log(`[URL_UTILS] Found ${candidates.length} candidate URLs from HTML parsing`);
    
    // Log some examples for debugging
    if (candidates.length > 1) {
      console.log(`[URL_UTILS] Sample URLs found:`, candidates.slice(0, 10));
    }
    
  } catch (error) {
    console.warn(`[URL_UTILS] Error extracting URLs from HTML:`, error);
    
    // Fallback to regex-based extraction
    try {
      const regex = /href="([^"]+)"/g;
      let m: RegExpExecArray | null;
      while ((m = regex.exec(html)) !== null) {
        const href = m[1];
        if (href.startsWith('/') && !candidates.includes(`${baseUrl}${href}`)) {
          candidates.push(`${baseUrl}${href}`);
        }
      }
      console.log(`[URL_UTILS] Fallback regex found ${candidates.length} candidate URLs`);
    } catch (regexError) {
      console.warn(`[URL_UTILS] Fallback regex extraction also failed:`, regexError);
    }
  }
  
  return candidates;
}
</file>

<file path="src/shared/validation/schemas/experiment.schema.ts">
/**
 * Zod Schemas for Experiment DSL Validation
 * 
 * Type-safe schema validation using Zod
 */

import { z } from 'zod';

// Base types
export const ExperimentStatusSchema = z.enum(['draft', 'running', 'paused', 'finished']);
export const VariantIdSchema = z.enum(['A', 'B', 'C']);
export const RenderPositionSchema = z.enum(['inner', 'outer', 'before', 'after', 'append', 'prepend']);
export const ApplyModeSchema = z.enum(['first', 'all']);

// Match configuration
export const ExperimentMatchSchema = z.object({
  host: z.string().optional(),
  path: z.string().min(1, 'Path is required')
});

// Traffic distribution with tolerance validation
export const ExperimentTrafficSchema = z.object({
  A: z.number().min(0).max(1),
  B: z.number().min(0).max(1),
  C: z.number().min(0).max(1)
}).refine(
  (traffic) => {
    const sum = traffic.A + traffic.B + traffic.C;
    return Math.abs(sum - 1.0) <= 0.005; // ±0.5% tolerance
  },
  {
    message: 'Traffic distribution must sum to 1.0 (±0.5%)',
    path: ['traffic']
  }
);

// Assignment configuration
export const ExperimentAssignmentSchema = z.object({
  cookieName: z.string()
    .min(1, 'Cookie name is required')
    .max(50, 'Cookie name must be 50 characters or less')
    .regex(/^[a-zA-Z0-9_-]+$/, 'Cookie name must contain only alphanumeric characters, hyphens, and underscores'),
  ttlDays: z.number().positive('TTL must be positive')
});

// Runtime configuration
export const ExperimentRuntimeSchema = z.object({
  minDays: z.number().positive('Minimum days must be positive'),
  minSessionsPerVariant: z.number().positive('Minimum sessions per variant must be positive'),
  endAt: z.string().datetime().optional()
});

// Analytics configuration
export const ExperimentAnalyticsSchema = z.object({
  posthog: z.object({
    enabled: z.boolean(),
    host: z.enum(['app.posthog.com', 'eu.posthog.com', 'us.posthog.com'], {
      message: 'Invalid PostHog host'
    })
  }),
  eventProps: z.array(z.string()).min(1, 'At least one event property is required')
});

// KPI configuration
export const ExperimentKPISchema = z.object({
  primary: z.string().min(1, 'Primary KPI is required'),
  secondary: z.array(z.string()).optional()
});

// Guardrails configuration
export const ExperimentGuardrailsSchema = z.object({
  watch: z.array(z.enum(['lcp', 'js_errors', 'cls'])).optional()
});

// Variant render configuration
export const VariantRenderSchema = z.object({
  position: RenderPositionSchema,
  html: z.string()
    .min(1, 'HTML content is required')
    .max(5 * 1024, 'HTML content exceeds 5KB limit'), // 5KB limit
  css: z.string()
    .max(10 * 1024, 'CSS content exceeds 10KB limit') // 10KB limit
    .optional(),
  oncePerResponse: z.boolean().optional().default(true)
});

// Variant configuration
export const VariantSchema = z.object({
  mode: z.literal('render'),
  render: VariantRenderSchema
});

// Target configuration
export const ExperimentTargetSchema = z.object({
  selector: z.string()
    .min(1, 'Selector is required')
    .refine(
      (selector) => !selector.includes('{') && !selector.includes('}') && !selector.includes(';'),
      'Invalid CSS selector syntax'
    ),
  apply: ApplyModeSchema.default('first'),
  variants: z.record(VariantIdSchema, VariantSchema)
    .refine(
      (variants) => Object.keys(variants).length >= 1,
      'At least one variant is required'
    )
    .refine(
      (variants) => Object.keys(variants).length <= 3,
      'Maximum 3 variants allowed'
    )
});

// Main experiment schema
export const ExperimentDSLSchema = z.object({
  experimentId: z.string().min(1, 'Experiment ID is required'),
  projectId: z.string().min(1, 'Project ID is required'),
  name: z.string().min(1, 'Name is required'),
  status: ExperimentStatusSchema,
  match: ExperimentMatchSchema,
  traffic: ExperimentTrafficSchema,
  assignment: ExperimentAssignmentSchema,
  targets: z.array(ExperimentTargetSchema)
    .min(1, 'At least one target is required')
    .max(3, 'Maximum 3 targets allowed'),
  kpi: ExperimentKPISchema,
  runtime: ExperimentRuntimeSchema,
  analytics: ExperimentAnalyticsSchema,
  guardrails: ExperimentGuardrailsSchema.optional()
}).refine(
  (experiment) => {
    // Check total DSL size (100KB limit)
    const dslString = JSON.stringify(experiment);
    const sizeKB = Buffer.byteLength(dslString, 'utf8') / 1024;
    return sizeKB <= 100;
  },
  {
    message: 'DSL exceeds 100KB limit',
    path: ['dsl']
  }
).refine(
  (experiment) => {
    // Check total CSS size across all variants (10KB limit)
    let totalCSSSize = 0;
    for (const target of experiment.targets) {
      for (const variant of Object.values(target.variants)) {
        if (variant.render.css) {
          totalCSSSize += Buffer.byteLength(variant.render.css, 'utf8');
        }
      }
    }
    return totalCSSSize <= 10 * 1024; // 10KB
  },
  {
    message: 'Total CSS size exceeds 10KB limit',
    path: ['css']
  }
);

// Type inference
export type ExperimentDSL = z.infer<typeof ExperimentDSLSchema>;
export type ExperimentMatch = z.infer<typeof ExperimentMatchSchema>;
export type ExperimentTraffic = z.infer<typeof ExperimentTrafficSchema>;
export type ExperimentAssignment = z.infer<typeof ExperimentAssignmentSchema>;
export type ExperimentRuntime = z.infer<typeof ExperimentRuntimeSchema>;
export type ExperimentAnalytics = z.infer<typeof ExperimentAnalyticsSchema>;
export type ExperimentKPI = z.infer<typeof ExperimentKPISchema>;
export type ExperimentGuardrails = z.infer<typeof ExperimentGuardrailsSchema>;
export type VariantRender = z.infer<typeof VariantRenderSchema>;
export type Variant = z.infer<typeof VariantSchema>;
export type ExperimentTarget = z.infer<typeof ExperimentTargetSchema>;
</file>

<file path="src/shared/demo-config.ts">
/**
 * Demo Configuration
 *
 * This file contains configuration for demo mode features.
 * Set DEMO_CONDITION to true to enable hardcoded demo behavior.
 */

/**
 * Main demo condition flag
 * When true, enables hardcoded demo features like:
 * - Specific element targeting (buttons/selectors)
 * - Predefined hypotheses focus
 * - Demo-specific variant generation
 */
export const DEMO_CONDITION = false;

/**
 * Demo target element configuration
 * Used when DEMO_CONDITION is true to focus on specific elements
 */
export const DEMO_TARGET_ELEMENT = {
    selector: 'a[href="/collections/all"]',
    description: 'Shop all button/link',
    html: '<a href="/collections/all">Shop all</a>',
    // Alternative selector for hypotheses generation (with more specific classes)
    hypothesesSelector: 'a[href="/collections/all"].size-style.link',
    hypothesesHtml: '<a href="/collections/all" class="size-style link link--ARGpDamJzVW9Gd2JMa__button_nazDaa" style="--size-style-width: fit-content;--size-style-height: ;--size-style-width-mobile: fit-content; --size-style-width-mobile-min: fit-content;">Shop all →</a>'
};

/**
 * Helper function to check if demo mode is enabled
 */
export function isDemoMode(): boolean {
    return DEMO_CONDITION;
}

/**
 * Get the appropriate selector based on context
 */
export function getDemoSelector(context: 'variants' | 'hypotheses' = 'variants'): string {
    if (!DEMO_CONDITION) {
        return '';
    }
    return context === 'hypotheses'
        ? DEMO_TARGET_ELEMENT.hypothesesSelector
        : DEMO_TARGET_ELEMENT.selector;
}

/**
 * Get the appropriate HTML based on context
 */
export function getDemoHtml(context: 'variants' | 'hypotheses' = 'variants'): string {
    if (!DEMO_CONDITION) {
        return '';
    }
    return context === 'hypotheses'
        ? DEMO_TARGET_ELEMENT.hypothesesHtml
        : DEMO_TARGET_ELEMENT.html;
}
</file>

<file path="src/index.ts">
import { startServer } from './app/server.js';

// Start the application
startServer();
</file>

<file path="src/test-variant-pipeline.ts">
#!/usr/bin/env ts-node

/**
 * Test script for the hypothesis → variant → code generation pipeline
 *
 * Usage:
 *   # Test with a specific project from database
 *   TEST_PROJECT_ID=your-project-id npx ts-node src/test-variant-pipeline.ts
 *
 *   # List available projects and pick one
 *   npx ts-node src/test-variant-pipeline.ts
 *
 * This script tests the complete pipeline using real projects from the database
 */

import { createVariantGenerationService } from './features/variant_generation/variant-generation';
import { createHypothesesGenerationService } from './features/hypotheses_generation/hypotheses-generation';
import { createPlaywrightCrawler } from './features/crawler';
import { createScreenshotStorageService } from './services/screenshot-storage';
import { getServiceConfig } from './infra/config/services';
import { prisma } from './infra/prisma';
import { ProjectDAL } from './infra/dal';
import { DEMO_CONDITION } from './shared/demo-config';

async function selectProject(): Promise<string> {
    // If project ID is provided via env, use it
    if (process.env.TEST_PROJECT_ID) {
        console.log(`📌 Using project ID from environment: ${process.env.TEST_PROJECT_ID}`);
        return process.env.TEST_PROJECT_ID;
    }

    // Otherwise, list available projects
    console.log('📋 Fetching available projects from database...\n');
    const projects = await prisma.project.findMany({
        select: {
            id: true,
            shopDomain: true,
            createdAt: true
        },
        orderBy: {
            createdAt: 'desc'
        }
    });

    if (projects.length === 0) {
        throw new Error('No projects found in database. Please create a project first.');
    }

    console.log('Available projects:');
    console.log('─'.repeat(60));
    projects.forEach((project, index) => {
        console.log(`${index + 1}. ${project.shopDomain}`);
        console.log(`   ID: ${project.id}`);
        console.log(`   Created: ${project.createdAt.toLocaleDateString()}`);
        console.log('');
    });

    // Use the most recent project by default
    const selectedProject = projects[0];
    console.log(`➡️  Auto-selecting most recent project: ${selectedProject.shopDomain}`);
    console.log(`   (Set TEST_PROJECT_ID env variable to use a specific project)\n`);

    return selectedProject.id;
}

async function testPipeline() {
    console.log('🚀 Starting Variant Generation Pipeline Test\n');
    console.log('='.repeat(60));

    try {
        // Step 1: Select project
        console.log('\n📁 Step 1: Selecting project...');
        const projectId = await selectProject();

        // Fetch full project details
        const project = await ProjectDAL.getProjectById(projectId);
        if (!project) {
            throw new Error(`Project not found: ${projectId}`);
        }

        console.log('✅ Project loaded:');
        console.log(`  • Domain: ${project.shopDomain}`);
        console.log(`  • ID: ${project.id}`);

        // Check if brand analysis exists
        const brandAnalysis = await ProjectDAL.getProjectBrandAnalysis(projectId);
        if (!brandAnalysis) {
            console.log('\n⚠️  Warning: No brand analysis found for this project');
            console.log('   Run brand analysis first for better results');
        } else {
            console.log(`  • Brand Analysis: ✅ Available (${brandAnalysis.length} chars)`);
        }

        // Step 2: Initialize services
        console.log('\n📦 Step 2: Initializing services...');
        const config = getServiceConfig();
        const crawler = createPlaywrightCrawler(config.crawler);
        const screenshotStorage = createScreenshotStorageService();
        const variantService = createVariantGenerationService(crawler, screenshotStorage, prisma);
        const hypothesesService = createHypothesesGenerationService(crawler, prisma);

        console.log('✅ Services initialized');
        console.log(`  • Demo Mode: ${DEMO_CONDITION ? 'ENABLED' : 'DISABLED'}`);

        // Step 3: Generate hypothesis from the project URL
        console.log('\n🎯 Step 3: Generating hypothesis...');

        // Build URL from shop domain
        const url = project.shopDomain.startsWith('http')
            ? project.shopDomain
            : `https://${project.shopDomain}`;

        console.log(`  • URL: ${url}`);
        console.log('  • Generating hypothesis from homepage...');

        const hypothesisResult = await hypothesesService.generateHypotheses(url, projectId);
        const hypotheses = JSON.parse(hypothesisResult.hypothesesSchema);
        const hypothesis = hypotheses.hypotheses[0];

        console.log('\n✅ Generated hypothesis:');
        console.log(`  • Title: ${hypothesis.title}`);
        console.log(`  • Description: ${hypothesis.description}`);
        console.log(`  • Problem: ${hypothesis.current_problem}`);
        console.log(`  • Expected Lift: ${hypothesis.predicted_lift_range.min}-${hypothesis.predicted_lift_range.max}%`);

        // Display all generated hypotheses
        if (hypotheses.hypotheses.length > 1) {
            console.log(`\n  (Generated ${hypotheses.hypotheses.length} total hypotheses, using the first one)`);
        }

        // Step 4: Generate variants
        console.log('\n🎨 Step 4: Generating variants...');

        const variantResult = await variantService.generateVariants(hypothesis, projectId);
        const variants = JSON.parse(variantResult.variantsSchema).variants;

        console.log(`✅ Generated ${variants.length} variants`);

        // Step 5: Display results and save JavaScript code
        console.log('\n📊 Step 5: Results\n');
        console.log('='.repeat(60));

        // Create output directory if it doesn't exist
        const fs = require('fs');
        const path = require('path');
        const outputDir = path.join(process.cwd(), 'test-output');
        if (!fs.existsSync(outputDir)) {
            fs.mkdirSync(outputDir, { recursive: true });
        }

        // Generate timestamp for unique filenames
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');

        variants.forEach((variant: any, index: number) => {
            console.log(`\n🔹 Variant ${index + 1}: ${variant.variant_label}`);
            console.log('  Description:', variant.description);
            console.log('  Rationale:', variant.rationale);
            console.log('  Target Selector:', variant.target_selector || 'Not specified');
            console.log('  Execution Timing:', variant.execution_timing || 'dom_ready');

            if (variant.javascript_code) {
                console.log('\n  📄 JavaScript Code Preview:');
                console.log('  ' + '─'.repeat(40));
                const codePreview = variant.javascript_code
                    .split('\n')
                    .slice(0, 10)
                    .map((line: string) => '  ' + line)
                    .join('\n');
                console.log(codePreview);
                if (variant.javascript_code.split('\n').length > 10) {
                    console.log('  ... (truncated, ' + variant.javascript_code.length + ' chars total)');
                }
                console.log('  ' + '─'.repeat(40));
            } else {
                console.log('\n  ⚠️  No JavaScript code generated');
            }
        });

        // Step 6: Save results to file
        console.log('\n💾 Step 6: Saving results...');
        const outputFile = `${outputDir}/variant-test-${timestamp}.json`;

        const testResults = {
            timestamp: new Date().toISOString(),
            project: {
                id: project.id,
                shopDomain: project.shopDomain,
                hasBrandAnalysis: !!brandAnalysis
            },
            demoMode: DEMO_CONDITION,
            hypothesis,
            variants,
            summary: {
                totalVariants: variants.length,
                hasJavaScriptCode: variants.every((v: any) => v.javascript_code),
                targetSelectors: variants.map((v: any) => v.target_selector).filter(Boolean),
                averageCodeLength: Math.round(
                    variants.reduce((sum: number, v: any) => sum + (v.javascript_code?.length || 0), 0) / variants.length
                )
            }
        };

        fs.writeFileSync(outputFile, JSON.stringify(testResults, null, 2));
        console.log(`✅ Results saved to: ${outputFile}`);

        // Step 7: Validate JavaScript code
        console.log('\n✅ Step 7: Validating JavaScript...');
        let validCount = 0;
        let invalidCount = 0;

        variants.forEach((variant: any, index: number) => {
            if (variant.javascript_code) {
                try {
                    // Basic syntax check
                    new Function(variant.javascript_code);
                    validCount++;
                    console.log(`  ✓ Variant ${index + 1} JavaScript is valid`);
                } catch (error: any) {
                    invalidCount++;
                    console.log(`  ✗ Variant ${index + 1} JavaScript has syntax error:`, error.message);
                }
            }
        });

        console.log(`\n  Summary: ${validCount} valid, ${invalidCount} invalid`);

        // Step 8: Save JavaScript code to separate file
        console.log('\n💾 Step 8: Saving JavaScript code...');
        const jsCodeContent = variants
            .filter((variant: any) => variant.javascript_code)
            .map((variant: any, index: number) => {
                return `// ========================================
// Variant ${index + 1}: ${variant.variant_label}
// ========================================
// Description: ${variant.description}
// Target Selector: ${variant.target_selector || 'Not specified'}
// Execution Timing: ${variant.execution_timing || 'dom_ready'}
// ========================================

${variant.javascript_code}

// ========================================
// End of Variant ${index + 1}
// ========================================

`;
            })
            .join('\n');

        if (jsCodeContent.trim()) {
            const jsOutputFile = `${outputDir}/variant-js-${timestamp}.js`;
            fs.writeFileSync(jsOutputFile, jsCodeContent);
            console.log(`✅ JavaScript code saved to: ${jsOutputFile}`);
            console.log('\n📋 You can copy and paste the JavaScript code from the file above!');
        } else {
            console.log('⚠️  No JavaScript code to save');
        }

        // Clean up
        console.log('\n🧹 Cleaning up...');
        await crawler.close();
        await prisma.$disconnect();

        console.log('\n' + '='.repeat(60));
        console.log('✨ Pipeline test completed successfully!');
        console.log('='.repeat(60));

        // Display quick stats
        console.log('\n📈 Quick Stats:');
        console.log(`  • Project: ${project.shopDomain}`);
        console.log(`  • Hypothesis: "${hypothesis.title}"`);
        console.log(`  • Variants Generated: ${variants.length}`);
        console.log(`  • Average Code Length: ${testResults.summary.averageCodeLength} chars`);
        console.log(`  • Demo Mode: ${DEMO_CONDITION ? 'ON' : 'OFF'}`);
        console.log(`  • Brand Analysis: ${brandAnalysis ? 'YES' : 'NO'}`);

    } catch (error) {
        console.error('\n❌ Pipeline test failed:', error);
        console.error('\nStack trace:', error instanceof Error ? error.stack : 'No stack trace available');

        // Clean up on error
        await prisma.$disconnect();
        process.exit(1);
    }
}

// Run the test
if (require.main === module) {
    console.log('Starting variant generation pipeline test...\n');

    testPipeline()
        .then(() => {
            console.log('\n👋 Test completed. Exiting...');
            process.exit(0);
        })
        .catch((error) => {
            console.error('Fatal error:', error);
            process.exit(1);
        });
}

// Export for use in other tests
export { testPipeline };
</file>

<file path="test-output/variant-js-2025-10-07T13-17-23-078Z.js">
// ========================================
// Variant 1: Solid Black Uppercase Category Buttons
// ========================================
// Description: This variant transforms the category name text overlays within the image slider into visually distinct, solid rectangular buttons. Each button has a solid black background (#000000), features uppercase text in the brand's accent gold color (#f4a70e), and uses the 'Poppins' font. On hover, the button's background subtly shifts to a darker gray (#222222) and lifts upwards slightly with a smooth animation, enhancing interactivity.
// Target Selector: div.shopbrand .item h3
// Execution Timing: dom_ready
// ========================================

(function() {
    'use strict';

    function initVariant() {
        try {
            const variantStyleId = 'variant-pro-category-buttons';
            if (document.getElementById(variantStyleId)) {
                return; // Prevent re-injection
            }

            const selector = 'div.shopbrand .item'; // Target the parent for better context
            const elements = document.querySelectorAll(selector);

            if (!elements.length) {
                console.warn('Variant "Pro Category Buttons": Target elements not found using selector:', selector);
                return;
            }

            // Define a professional CSS implementation
            const css = `
                :root {
                    --btn-bg: #000000;
                    --btn-text: #f4a70e;
                    --btn-hover-bg: #1a1a1a;
                    --btn-font-family: 'Poppins', sans-serif;
                    --btn-font-size: 14px;
                    --btn-font-weight: 700;
                    --btn-padding: 15px 24px;
                    --btn-margin: 16px 0;
                    --btn-transition-duration: 0.3s;
                    --btn-easing: cubic-bezier(0.25, 0.8, 0.25, 1);
                    --btn-shadow: 0 2px 5px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08);
                    --btn-hover-shadow: 0 6px 12px rgba(0, 0, 0, 0.15), 0 3px 6px rgba(0, 0, 0, 0.1);
                    --btn-active-shadow: 0 1px 2px rgba(0, 0, 0, 0.12);
                }

                /* Parent anchor setup for interaction and layout */
                ${selector} a {
                    text-decoration: none !important;
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    -webkit-tap-highlight-color: transparent; /* Remove tap flash on mobile */
                }
                
                /* Core button styles applied to the H3 element */
                ${selector} h3 {
                    background-color: var(--btn-bg);
                    color: var(--btn-text);
                    font-family: var(--btn-font-family);
                    font-size: var(--btn-font-size);
                    font-weight: var(--btn-font-weight);
                    text-transform: uppercase;
                    letter-spacing: 0.05em; /* Add slight letter spacing for uppercase text */
                    padding: var(--btn-padding);
                    margin: var(--btn-margin) !important;
                    border-radius: 0px;
                    box-shadow: var(--btn-shadow);
                    line-height: 1.2;
                    text-align: center;
                    display: inline-block;
                    min-height: 44px; /* Ensure minimum touch target size */
                    min-width: 44px;
                    box-sizing: border-box;

                    /* Performance optimizations */
                    will-change: transform, box-shadow, background-color;
                    transform: translateZ(0); /* Promote to own layer for hardware acceleration */
                    transition: 
                        transform var(--btn-transition-duration) var(--btn-easing),
                        box-shadow var(--btn-transition-duration) var(--btn-easing),
                        background-color var(--btn-transition-duration) var(--btn-easing);
                }

                /* Hover state */
                ${selector} a:hover > h3 {
                    background-color: var(--btn-hover-bg);
                    box-shadow: var(--btn-hover-shadow);
                    transform: translateY(-3px) translateZ(0);
                    color: var(--btn-text); /* Ensure color persistence */
                }

                /* Focus state for keyboard accessibility */
                ${selector} a:focus-visible > h3 {
                    outline: 2px solid var(--btn-text);
                    outline-offset: 3px;
                    background-color: var(--btn-hover-bg);
                    box-shadow: var(--btn-hover-shadow);
                    transform: translateY(-3px) translateZ(0);
                }

                /* Active (click/tap) state for immediate feedback */
                ${selector} a:active > h3 {
                    transform: translateY(1px) translateZ(0);
                    box-shadow: var(--btn-active-shadow);
                    transition-duration: 0.1s; /* Make the press feel faster */
                }

                /* Accessibility: Respect user's motion preferences */
                @media (prefers-reduced-motion: reduce) {
                    ${selector} h3 {
                        transition: none;
                        transform: none !important;
                    }
                }

                /* Responsive adjustments for smaller screens */
                @media (max-width: 768px) {
                    ${selector} h3 {
                        font-size: 13px;
                        padding: 12px 20px;
                    }
                }
            `;

            const styleElement = document.createElement('style');
            styleElement.id = variantStyleId;
            styleElement.textContent = css;
            document.head.appendChild(styleElement);

        } catch (error) {
            console.error('Error in variant "Pro Category Buttons":', error);
        }
    }

    // Standard initialization logic
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initVariant);
    } else {
        initVariant();
    }
})();

// ========================================
// End of Variant 1
// ========================================
</file>

<file path="test-output/variant-test-2025-10-07T13-17-23-078Z.json">
{
  "timestamp": "2025-10-07T13:17:23.079Z",
  "project": {
    "id": "cmgdwc7hb0000qv2eekxo49o9",
    "shopDomain": "https://tallasextrasmexico.com",
    "hasBrandAnalysis": true
  },
  "demoMode": false,
  "hypothesis": {
    "title": "Improve Category Slider Clickability",
    "description": "Styling the category names in the image slider as clear, high-contrast buttons will encourage more users to explore product collections.",
    "primary_outcome": "Click-through rate",
    "current_problem": "The category names are simple text overlays on images, which may not be immediately perceived as clickable navigation elements.",
    "why_it_works": [
      {
        "reason": "Creates a clearer call-to-action"
      },
      {
        "reason": "Improves visual affordance"
      },
      {
        "reason": "Reduces user hesitation"
      }
    ],
    "baseline_performance": 16.5,
    "predicted_lift_range": {
      "min": 0.05,
      "max": 0.15
    }
  },
  "variants": [
    {
      "variant_label": "Solid Black Uppercase Category Buttons",
      "description": "This variant transforms the category name text overlays within the image slider into visually distinct, solid rectangular buttons. Each button has a solid black background (#000000), features uppercase text in the brand's accent gold color (#f4a70e), and uses the 'Poppins' font. On hover, the button's background subtly shifts to a darker gray (#222222) and lifts upwards slightly with a smooth animation, enhancing interactivity.",
      "rationale": "By converting simple text overlays into clear, high-contrast buttons, this design significantly improves visual affordance, making it immediately obvious that these are clickable elements. This change reduces user hesitation and directly guides them to explore product collections, addressing the core hypothesis that a stronger call-to-action will increase click-through rates.",
      "javascript_code": "(function() {\n    'use strict';\n\n    function initVariant() {\n        try {\n            const variantStyleId = 'variant-pro-category-buttons';\n            if (document.getElementById(variantStyleId)) {\n                return; // Prevent re-injection\n            }\n\n            const selector = 'div.shopbrand .item'; // Target the parent for better context\n            const elements = document.querySelectorAll(selector);\n\n            if (!elements.length) {\n                console.warn('Variant \"Pro Category Buttons\": Target elements not found using selector:', selector);\n                return;\n            }\n\n            // Define a professional CSS implementation\n            const css = `\n                :root {\n                    --btn-bg: #000000;\n                    --btn-text: #f4a70e;\n                    --btn-hover-bg: #1a1a1a;\n                    --btn-font-family: 'Poppins', sans-serif;\n                    --btn-font-size: 14px;\n                    --btn-font-weight: 700;\n                    --btn-padding: 15px 24px;\n                    --btn-margin: 16px 0;\n                    --btn-transition-duration: 0.3s;\n                    --btn-easing: cubic-bezier(0.25, 0.8, 0.25, 1);\n                    --btn-shadow: 0 2px 5px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08);\n                    --btn-hover-shadow: 0 6px 12px rgba(0, 0, 0, 0.15), 0 3px 6px rgba(0, 0, 0, 0.1);\n                    --btn-active-shadow: 0 1px 2px rgba(0, 0, 0, 0.12);\n                }\n\n                /* Parent anchor setup for interaction and layout */\n                ${selector} a {\n                    text-decoration: none !important;\n                    display: flex;\n                    justify-content: center;\n                    align-items: center;\n                    -webkit-tap-highlight-color: transparent; /* Remove tap flash on mobile */\n                }\n                \n                /* Core button styles applied to the H3 element */\n                ${selector} h3 {\n                    background-color: var(--btn-bg);\n                    color: var(--btn-text);\n                    font-family: var(--btn-font-family);\n                    font-size: var(--btn-font-size);\n                    font-weight: var(--btn-font-weight);\n                    text-transform: uppercase;\n                    letter-spacing: 0.05em; /* Add slight letter spacing for uppercase text */\n                    padding: var(--btn-padding);\n                    margin: var(--btn-margin) !important;\n                    border-radius: 0px;\n                    box-shadow: var(--btn-shadow);\n                    line-height: 1.2;\n                    text-align: center;\n                    display: inline-block;\n                    min-height: 44px; /* Ensure minimum touch target size */\n                    min-width: 44px;\n                    box-sizing: border-box;\n\n                    /* Performance optimizations */\n                    will-change: transform, box-shadow, background-color;\n                    transform: translateZ(0); /* Promote to own layer for hardware acceleration */\n                    transition: \n                        transform var(--btn-transition-duration) var(--btn-easing),\n                        box-shadow var(--btn-transition-duration) var(--btn-easing),\n                        background-color var(--btn-transition-duration) var(--btn-easing);\n                }\n\n                /* Hover state */\n                ${selector} a:hover > h3 {\n                    background-color: var(--btn-hover-bg);\n                    box-shadow: var(--btn-hover-shadow);\n                    transform: translateY(-3px) translateZ(0);\n                    color: var(--btn-text); /* Ensure color persistence */\n                }\n\n                /* Focus state for keyboard accessibility */\n                ${selector} a:focus-visible > h3 {\n                    outline: 2px solid var(--btn-text);\n                    outline-offset: 3px;\n                    background-color: var(--btn-hover-bg);\n                    box-shadow: var(--btn-hover-shadow);\n                    transform: translateY(-3px) translateZ(0);\n                }\n\n                /* Active (click/tap) state for immediate feedback */\n                ${selector} a:active > h3 {\n                    transform: translateY(1px) translateZ(0);\n                    box-shadow: var(--btn-active-shadow);\n                    transition-duration: 0.1s; /* Make the press feel faster */\n                }\n\n                /* Accessibility: Respect user's motion preferences */\n                @media (prefers-reduced-motion: reduce) {\n                    ${selector} h3 {\n                        transition: none;\n                        transform: none !important;\n                    }\n                }\n\n                /* Responsive adjustments for smaller screens */\n                @media (max-width: 768px) {\n                    ${selector} h3 {\n                        font-size: 13px;\n                        padding: 12px 20px;\n                    }\n                }\n            `;\n\n            const styleElement = document.createElement('style');\n            styleElement.id = variantStyleId;\n            styleElement.textContent = css;\n            document.head.appendChild(styleElement);\n\n        } catch (error) {\n            console.error('Error in variant \"Pro Category Buttons\":', error);\n        }\n    }\n\n    // Standard initialization logic\n    if (document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', initVariant);\n    } else {\n        initVariant();\n    }\n})();",
      "target_selector": "div.shopbrand .item h3",
      "execution_timing": "dom_ready",
      "implementation_instructions": "This code targets all category name headings within the image slider and transforms them into high-contrast buttons. It injects a CSS stylesheet into the page's <head> to apply the new styles. This method efficiently restyles all target elements, including their hover and focus states, to match the variant's design system values for a polished, professional appearance and improved user interaction."
    }
  ],
  "summary": {
    "totalVariants": 1,
    "hasJavaScriptCode": true,
    "targetSelectors": [
      "div.shopbrand .item h3"
    ],
    "averageCodeLength": 5626
  }
}
</file>

<file path="tests/integration/variant-pipeline.test.ts">
#!/usr/bin/env ts-node

/**
 * Test script for the hypothesis → variant → code generation pipeline
 *
 * Usage:
 *   # Test with a specific project from database
 *   TEST_PROJECT_ID=your-project-id npx ts-node src/test-variant-pipeline.ts
 *
 *   # List available projects and pick one
 *   npx ts-node src/test-variant-pipeline.ts
 *
 * This script tests the complete pipeline using real projects from the database
 */

import { createVariantGenerationService } from './features/variant_generation/variant-generation';
import { createHypothesesGenerationService } from './features/hypotheses_generation/hypotheses-generation';
import { createPlaywrightCrawler } from './features/crawler';
import { createScreenshotStorageService } from './services/screenshot-storage';
import { getServiceConfig } from './infra/config/services';
import { prisma } from './infra/prisma';
import { ProjectDAL } from './infra/dal';
import { DEMO_CONDITION } from './shared/demo-config';

async function selectProject(): Promise<string> {
    // If project ID is provided via env, use it
    if (process.env.TEST_PROJECT_ID) {
        console.log(`📌 Using project ID from environment: ${process.env.TEST_PROJECT_ID}`);
        return process.env.TEST_PROJECT_ID;
    }

    // Otherwise, list available projects
    console.log('📋 Fetching available projects from database...\n');
    const projects = await prisma.project.findMany({
        select: {
            id: true,
            shopDomain: true,
            createdAt: true
        },
        orderBy: {
            createdAt: 'desc'
        }
    });

    if (projects.length === 0) {
        throw new Error('No projects found in database. Please create a project first.');
    }

    console.log('Available projects:');
    console.log('─'.repeat(60));
    projects.forEach((project, index) => {
        console.log(`${index + 1}. ${project.shopDomain}`);
        console.log(`   ID: ${project.id}`);
        console.log(`   Created: ${project.createdAt.toLocaleDateString()}`);
        console.log('');
    });

    // Use the most recent project by default
    const selectedProject = projects[0];
    console.log(`➡️  Auto-selecting most recent project: ${selectedProject.shopDomain}`);
    console.log(`   (Set TEST_PROJECT_ID env variable to use a specific project)\n`);

    return selectedProject.id;
}

async function testPipeline() {
    console.log('🚀 Starting Variant Generation Pipeline Test\n');
    console.log('='.repeat(60));

    try {
        // Step 1: Select project
        console.log('\n📁 Step 1: Selecting project...');
        const projectId = await selectProject();

        // Fetch full project details
        const project = await ProjectDAL.getProjectById(projectId);
        if (!project) {
            throw new Error(`Project not found: ${projectId}`);
        }

        console.log('✅ Project loaded:');
        console.log(`  • Domain: ${project.shopDomain}`);
        console.log(`  • ID: ${project.id}`);

        // Check if brand analysis exists
        const brandAnalysis = await ProjectDAL.getProjectBrandAnalysis(projectId);
        if (!brandAnalysis) {
            console.log('\n⚠️  Warning: No brand analysis found for this project');
            console.log('   Run brand analysis first for better results');
        } else {
            console.log(`  • Brand Analysis: ✅ Available (${brandAnalysis.length} chars)`);
        }

        // Step 2: Initialize services
        console.log('\n📦 Step 2: Initializing services...');
        const config = getServiceConfig();
        const crawler = createPlaywrightCrawler(config.crawler);
        const screenshotStorage = createScreenshotStorageService();
        const variantService = createVariantGenerationService(crawler, screenshotStorage, prisma);
        const hypothesesService = createHypothesesGenerationService(crawler, prisma);

        console.log('✅ Services initialized');
        console.log(`  • Demo Mode: ${DEMO_CONDITION ? 'ENABLED' : 'DISABLED'}`);

        // Step 3: Generate hypothesis from the project URL
        console.log('\n🎯 Step 3: Generating hypothesis...');

        // Build URL from shop domain
        const url = project.shopDomain.startsWith('http')
            ? project.shopDomain
            : `https://${project.shopDomain}`;

        console.log(`  • URL: ${url}`);
        console.log('  • Generating hypothesis from homepage...');

        const hypothesisResult = await hypothesesService.generateHypotheses(url, projectId);
        const hypotheses = JSON.parse(hypothesisResult.hypothesesSchema);
        const hypothesis = hypotheses.hypotheses[0];

        console.log('\n✅ Generated hypothesis:');
        console.log(`  • Title: ${hypothesis.title}`);
        console.log(`  • Description: ${hypothesis.description}`);
        console.log(`  • Problem: ${hypothesis.current_problem}`);
        console.log(`  • Expected Lift: ${hypothesis.predicted_lift_range.min}-${hypothesis.predicted_lift_range.max}%`);

        // Display all generated hypotheses
        if (hypotheses.hypotheses.length > 1) {
            console.log(`\n  (Generated ${hypotheses.hypotheses.length} total hypotheses, using the first one)`);
        }

        // Step 4: Generate variants
        console.log('\n🎨 Step 4: Generating variants...');

        const variantResult = await variantService.generateVariants(hypothesis, projectId);
        const variants = JSON.parse(variantResult.variantsSchema).variants;

        console.log(`✅ Generated ${variants.length} variants`);

        // Step 5: Display results and save JavaScript code
        console.log('\n📊 Step 5: Results\n');
        console.log('='.repeat(60));

        // Create output directory if it doesn't exist
        const fs = require('fs');
        const path = require('path');
        const outputDir = path.join(process.cwd(), 'test-output');
        if (!fs.existsSync(outputDir)) {
            fs.mkdirSync(outputDir, { recursive: true });
        }

        // Generate timestamp for unique filenames
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const jsOutputFile = path.join(outputDir, `variant-js-${timestamp}.js`);

        variants.forEach((variant: any, index: number) => {
            console.log(`\n🔹 Variant ${index + 1}: ${variant.variant_label}`);
            console.log('  Description:', variant.description);
            console.log('  Rationale:', variant.rationale);
            console.log('  Target Selector:', variant.target_selector || 'Not specified');
            console.log('  Execution Timing:', variant.execution_timing || 'dom_ready');

            if (variant.javascript_code) {
                console.log('\n  📄 JavaScript Code Preview:');
                console.log('  ' + '─'.repeat(40));
                const codePreview = variant.javascript_code
                    .split('\n')
                    .slice(0, 10)
                    .map((line: string) => '  ' + line)
                    .join('\n');
                console.log(codePreview);
                if (variant.javascript_code.split('\n').length > 10) {
                    console.log('  ... (truncated, ' + variant.javascript_code.length + ' chars total)');
                }
                console.log('  ' + '─'.repeat(40));
            } else {
                console.log('\n  ⚠️  No JavaScript code generated');
            }
        });

        // Step 6: Save results to file
        console.log('\n💾 Step 6: Saving results...');
        const outputFile = `${outputDir}/variant-test-${timestamp}.json`;

        const testResults = {
            timestamp: new Date().toISOString(),
            project: {
                id: project.id,
                shopDomain: project.shopDomain,
                hasBrandAnalysis: !!brandAnalysis
            },
            demoMode: DEMO_CONDITION,
            hypothesis,
            variants,
            summary: {
                totalVariants: variants.length,
                hasJavaScriptCode: variants.every((v: any) => v.javascript_code),
                targetSelectors: variants.map((v: any) => v.target_selector).filter(Boolean),
                averageCodeLength: Math.round(
                    variants.reduce((sum: number, v: any) => sum + (v.javascript_code?.length || 0), 0) / variants.length
                )
            }
        };

        fs.writeFileSync(outputFile, JSON.stringify(testResults, null, 2));
        console.log(`✅ Results saved to: ${outputFile}`);

        // Step 7: Validate JavaScript code
        console.log('\n✅ Step 7: Validating JavaScript...');
        let validCount = 0;
        let invalidCount = 0;

        variants.forEach((variant: any, index: number) => {
            if (variant.javascript_code) {
                try {
                    // Basic syntax check
                    new Function(variant.javascript_code);
                    validCount++;
                    console.log(`  ✓ Variant ${index + 1} JavaScript is valid`);
                } catch (error: any) {
                    invalidCount++;
                    console.log(`  ✗ Variant ${index + 1} JavaScript has syntax error:`, error.message);
                }
            }
        });

        console.log(`\n  Summary: ${validCount} valid, ${invalidCount} invalid`);

        // Step 8: Save JavaScript code to separate file
        console.log('\n💾 Step 8: Saving JavaScript code...');
        const jsCodeContent = variants
            .filter((variant: any) => variant.javascript_code)
            .map((variant: any, index: number) => {
                return `// ========================================
// Variant ${index + 1}: ${variant.variant_label}
// ========================================
// Description: ${variant.description}
// Target Selector: ${variant.target_selector || 'Not specified'}
// Execution Timing: ${variant.execution_timing || 'dom_ready'}
// ========================================

${variant.javascript_code}

// ========================================
// End of Variant ${index + 1}
// ========================================

`;
            })
            .join('\n');

        if (jsCodeContent.trim()) {
            const jsOutputFile = `${outputDir}/variant-js-${timestamp}.js`;
            fs.writeFileSync(jsOutputFile, jsCodeContent);
            console.log(`✅ JavaScript code saved to: ${jsOutputFile}`);
            console.log('\n📋 You can copy and paste the JavaScript code from the file above!');
        } else {
            console.log('⚠️  No JavaScript code to save');
        }

        // Clean up
        console.log('\n🧹 Cleaning up...');
        await crawler.close();
        await prisma.$disconnect();

        console.log('\n' + '='.repeat(60));
        console.log('✨ Pipeline test completed successfully!');
        console.log('='.repeat(60));

        // Display quick stats
        console.log('\n📈 Quick Stats:');
        console.log(`  • Project: ${project.shopDomain}`);
        console.log(`  • Hypothesis: "${hypothesis.title}"`);
        console.log(`  • Variants Generated: ${variants.length}`);
        console.log(`  • Average Code Length: ${testResults.summary.averageCodeLength} chars`);
        console.log(`  • Demo Mode: ${DEMO_CONDITION ? 'ON' : 'OFF'}`);
        console.log(`  • Brand Analysis: ${brandAnalysis ? 'YES' : 'NO'}`);

    } catch (error) {
        console.error('\n❌ Pipeline test failed:', error);
        console.error('\nStack trace:', error instanceof Error ? error.stack : 'No stack trace available');

        // Clean up on error
        await prisma.$disconnect();
        process.exit(1);
    }
}

// Run the test
if (require.main === module) {
    console.log('Starting variant generation pipeline test...\n');

    testPipeline()
        .then(() => {
            console.log('\n👋 Test completed. Exiting...');
            process.exit(0);
        })
        .catch((error) => {
            console.error('Fatal error:', error);
            process.exit(1);
        });
}

// Export for use in other tests
export { testPipeline };
</file>

<file path="tests/integration/variant-simple.test.ts">
#!/usr/bin/env ts-node

/**
 * Simple test script for variant generation
 *
 * Usage:
 *   npx ts-node src/test-variant-simple.ts
 *
 * This is a simpler version that tests individual components
 */

import { Hypothesis } from './features/hypotheses_generation/types';
import { buildVariantGenerationPrompt, buildButtonVariantGenerationPrompt } from './features/variant_generation/prompts';
import { generateObject } from 'ai';
import { google } from '@ai-sdk/google';
import { basicVariantsResponseSchema } from './features/variant_generation/types';
import { getVariantGenerationAIConfig } from './shared/ai-config';
import { DEMO_CONDITION } from './shared/demo-config';

// Sample hypothesis for testing
const TEST_HYPOTHESIS: Hypothesis = {
    title: "Improve CTA Button Conversion",
    description: "Making the main CTA button more prominent with urgency will increase conversions",
    primary_outcome: "Conversion rate",
    current_problem: "The CTA button doesn't stand out and lacks urgency",
    why_it_works: [
        { reason: "Urgency creates FOMO" },
        { reason: "Prominent buttons get more clicks" },
        { reason: "Dynamic elements attract attention" }
    ],
    baseline_performance: 3.2,
    predicted_lift_range: { min: 10, max: 25 }
};

async function testVariantGeneration() {
    console.log('🧪 Testing Variant Generation\n');
    console.log('Current Configuration:');
    console.log('  Demo Mode:', DEMO_CONDITION ? 'ENABLED' : 'DISABLED');
    console.log('');

    try {
        // Test 1: Generate variant ideas
        console.log('📝 Test 1: Generating Variant Ideas');
        console.log('-'.repeat(40));

        const prompt = DEMO_CONDITION
            ? buildButtonVariantGenerationPrompt(TEST_HYPOTHESIS)
            : buildVariantGenerationPrompt(TEST_HYPOTHESIS);

        console.log('Using prompt type:', DEMO_CONDITION ? 'Button-specific' : 'General');

        const aiConfig = getVariantGenerationAIConfig();
        const response = await generateObject({
            model: google(aiConfig.model),
            schema: basicVariantsResponseSchema,
            prompt: prompt,
            temperature: 0.8
        });

        const variants = response.object.variants;
        console.log(`✅ Generated ${variants.length} variant ideas\n`);

        variants.forEach((variant, index) => {
            console.log(`Variant ${index + 1}: ${variant.variant_label}`);
            console.log(`  Description: ${variant.description}`);
            console.log(`  Rationale: ${variant.rationale}\n`);
        });

        // Test 2: Generate JavaScript code for first variant
        console.log('💻 Test 2: Generating JavaScript Code');
        console.log('-'.repeat(40));

        const firstVariant = variants[0];
        const codePrompt = `Generate JavaScript code for this A/B test variant:

VARIANT: ${firstVariant.variant_label}
DESCRIPTION: ${firstVariant.description}
RATIONALE: ${firstVariant.rationale}

Generate self-contained JavaScript that:
1. Targets the main CTA button
2. Implements the variant changes
3. Includes error handling
4. Works on mobile and desktop

Use this structure:
(function() {
  'use strict';

  function initVariant() {
    try {
      // Find target element
      const button = document.querySelector('button, a.button, [class*="btn"]');
      if (!button) return;

      // Apply variant changes
      // [Your implementation here based on: ${firstVariant.description}]

    } catch (error) {
      console.error('[Variant Error]:', error);
    }
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initVariant);
  } else {
    initVariant();
  }
})();

Return a JSON object with:
- javascript_code: The complete JavaScript
- target_selector: The CSS selector used
- execution_timing: "dom_ready"`;

        const codeResponse = await generateObject({
            model: google(aiConfig.model),
            schema: {
                type: 'object',
                properties: {
                    javascript_code: { type: 'string' },
                    target_selector: { type: 'string' },
                    execution_timing: { type: 'string' }
                }
            } as any,
            prompt: codePrompt,
            temperature: 0.7
        });

        console.log('✅ Generated JavaScript code\n');
        console.log('Target Selector:', codeResponse.object.target_selector);
        console.log('Execution Timing:', codeResponse.object.execution_timing);
        console.log('\nCode Preview (first 500 chars):');
        console.log(codeResponse.object.javascript_code.substring(0, 500) + '...\n');

        // Test 3: Validate the JavaScript
        console.log('✔️  Test 3: Validating JavaScript');
        console.log('-'.repeat(40));

        try {
            new Function(codeResponse.object.javascript_code);
            console.log('✅ JavaScript syntax is valid!\n');
        } catch (error: any) {
            console.log('❌ JavaScript syntax error:', error.message, '\n');
        }

        // Summary
        console.log('📊 Test Summary');
        console.log('='.repeat(40));
        console.log('✅ All tests completed successfully!');
        console.log(`  • Generated ${variants.length} variant ideas`);
        console.log(`  • Generated JavaScript code (${codeResponse.object.javascript_code.length} chars)`);
        console.log(`  • Code targets: ${codeResponse.object.target_selector}`);
        console.log(`  • Demo mode: ${DEMO_CONDITION ? 'ON' : 'OFF'}`);

    } catch (error) {
        console.error('❌ Test failed:', error);
        process.exit(1);
    }
}

// Run the test
if (require.main === module) {
    console.log('Starting simple variant test...\n');

    testVariantGeneration()
        .then(() => {
            console.log('\n✨ Test completed successfully!');
            process.exit(0);
        })
        .catch((error) => {
            console.error('Fatal error:', error);
            process.exit(1);
        });
}
</file>

<file path="AGENTS.md">
# AGENTS.md

This file provides guidance to Agents when working with code in this repository.

## Important

- Be as lean as possible with your code, the user really wants elegancy in their code
- Respect file structureA 


## Common Commands

### Development
- The user already has the platform running with docker, on port 3001. You don't need to turn it on yourself.

### Code Quality
- `npm run lint` - Run ESLint on source files
- `npm run lint:fix` - Auto-fix ESLint issues
- `npm run check:types` - Run TypeScript type checking
- `npm run check:unused` - Check for unused exports
- `npm run check:all` - Run all checks (types, unused exports, lint)

### Database
-- If you need to check contents of the database locally, query the database in docker with prisma, such as: `docker exec omen-backend-postgres-1 psql -U postgres -d omen_db -c "SELECT \"projectId\", \"experimentId\", \"sessionId\", \"viewId\", properties, \"createdAt\" FROM analytics_events WHERE \"eventType\" = 'PAGEVIEW' ORDER BY \"createdAt\" DESC LIMIT 10;"`
- `npm run db:generate` - Generate Prisma client
- `npm run db:migrate` - Run database migrations in development
- `npm run db:deploy` - Deploy migrations to production
- `npm run db:studio` - Open Prisma Studio GUI
- `npm run seed` - Run database seeding
- `npm run seed:reset` - Reset and reseed database

## Architecture Overview

This is a Node.js TypeScript backend for an e-commerce optimization platform that generates AI-powered A/B test variants for Shopify stores.

### Core Architecture Pattern
The codebase follows a layered architecture with clear separation of concerns:

**Domain Layer** (`src/domain/`): Business logic and core entities
- Agent system for chat interactions
- Analytics domain services
- Core business rules and types

**Features Layer** (`src/features/`): Self-contained feature modules
- `brand_analysis/`: Analyzes e-commerce sites using Firecrawl
- `variant_generation/`: Creates A/B test variants using AI
- `hypotheses_generation/`: Generates experiment hypotheses
- `crawler/`: Web crawling with Playwright
- `conflict_guard/`: Prevents conflicting experiments

**Infrastructure Layer** (`src/infra/`): External integrations and data access
- `dal/`: Data Access Layer with Prisma
- `external/`: External service integrations (Cloudflare, AWS SQS)
- `config/`: Service configuration management

**Interface Layer** (`src/interfaces/`): HTTP API endpoints using Fastify
- Authentication middleware (Better Auth)
- Route handlers and validation schemas
- API versioning and documentation

**Services Layer** (`src/services/`): Application services and orchestration
- Background job management
- Screenshot services
- Analytics processing
- SQS message processing

### Key Technologies
- **Framework**: Fastify (high-performance HTTP server)
- **Database**: PostgreSQL with Prisma ORM
- **AI/ML**: Google Gemini, OpenAI (AI SDK)
- **Authentication**: Better Auth (replacing Auth0)
- **Web Crawling**: Playwright, Firecrawl
- **Message Queue**: AWS SQS
- **Analytics**: PostHog integration
- **Image Storage**: Cloudflare R2

### Dependency Injection
The application uses a custom service container (`src/app/container.ts`) for dependency injection. Services are lazily loaded and cached as singletons. The container manages cleanup and resource disposal.

### Path Mapping
TypeScript paths are configured in `tsconfig.json` for clean imports:
- `@app/*` → `src/app/*`
- `@config/*` → `src/config/*`
- `@domain/*` → `src/domain/*`
- `@features/*` → `src/features/*`
- `@infra/*` → `src/infra/*`
- `@interfaces/*` → `src/interfaces/*`
- `@services/*` → `src/services/*`
- `@shared/*` → `src/shared/*`

### Database Schema
The Prisma schema (`prisma/schema.prisma`) defines the core entities:
- **User**: Authentication and user management
- **Project**: Shopify store connections and configurations
- **Experiment**: A/B test definitions and targeting
- **Screenshot**: Visual assets for experiments
- **AnalyticsEvent**: Event tracking for experiments
- **ChatMessage**: Agent conversation history

### Background Services
The application runs several background services:
- **Job Cleanup**: Removes stale background jobs
- **SQS Consumer**: Processes analytics events from queue
- **Background Services Manager**: Coordinates service lifecycle

## Development Notes

### Environment Setup
The application requires a `.env` file with configuration for:
- Database connection (PostgreSQL)
- AI providers (Google Gemini, OpenAI)
- External services (PostHog, Cloudflare, AWS SQS)
- Authentication (Better Auth)
- Shopify API credentials

### AI Integration
The codebase heavily uses the Vercel AI SDK for LLM interactions. Different features use different AI providers optimized for their use case:
- Brand analysis: Firecrawl + Google Gemini
- Variant generation: Google Gemini with structured output
- Chat agent: Multi-provider support with tool calling

### Web Crawling Strategy
The crawler service supports multiple strategies:
- Playwright for dynamic content and screenshots
- Firecrawl for content extraction and analysis
- Smart screenshot strategies for optimal visual capture

### Analytics Architecture
Event tracking uses a dual approach:
- Real-time events via HTTP API
- Batch processing via AWS SQS for high-volume events
- PostgreSQL for storage with optimized queries for analytics

### Security Considerations
- Better Auth handles authentication with session management
- Project-level authorization middleware
- Environment variables for all sensitive configuration
- SQL injection protection via Prisma's type-safe queries
</file>

<file path="check-experiment-status.ts">
import { prisma } from './src/infra/prisma';

async function checkExperimentStatus() {
  const experiments = await prisma.experiment.findMany({
    orderBy: { createdAt: 'desc' },
    take: 10,
    select: {
      id: true,
      name: true,
      status: true,
      createdAt: true,
      publishedAt: true,
      finishedAt: true,
    }
  });

  console.log('\n📊 Recent Experiments:');
  console.log('='.repeat(100));

  experiments.forEach((exp) => {
    console.log(`\nID: ${exp.id}`);
    console.log(`Name: ${exp.name}`);
    console.log(`Status: ${exp.status}`);
    console.log(`Created: ${exp.createdAt}`);
    console.log(`Published: ${exp.publishedAt || 'N/A'}`);
    console.log(`Finished: ${exp.finishedAt || 'N/A'}`);
    console.log('-'.repeat(100));
  });

  await prisma.$disconnect();
}

checkExperimentStatus().catch(console.error);
</file>

<file path="eslint.config.js">
import js from '@eslint/js';
import tseslint from '@typescript-eslint/eslint-plugin';
import tsparser from '@typescript-eslint/parser';

export default [
  js.configs.recommended,
  {
    files: ['src/**/*.ts'],
    languageOptions: {
      parser: tsparser,
      parserOptions: {
        ecmaVersion: 2020,
        sourceType: 'module',
        project: './tsconfig.json',
      },
      globals: {
        console: 'readonly',
        process: 'readonly',
        Buffer: 'readonly',
        __dirname: 'readonly',
        __filename: 'readonly',
        global: 'readonly',
        module: 'readonly',
        require: 'readonly',
        exports: 'readonly',
      },
    },
    plugins: {
      '@typescript-eslint': tseslint,
    },
    rules: {
      // Basic rules
      'no-console': 'off', // Allow console.log in Node.js
      'no-unused-vars': 'off', // Use TypeScript version instead
      '@typescript-eslint/no-unused-vars': ['error', { 
        argsIgnorePattern: '^_',
        varsIgnorePattern: '^_',
        caughtErrorsIgnorePattern: '^_',
        destructuredArrayIgnorePattern: '^_'
      }],
      '@typescript-eslint/explicit-function-return-type': 'off',
      '@typescript-eslint/explicit-module-boundary-types': 'off',
      '@typescript-eslint/no-explicit-any': 'warn',
      '@typescript-eslint/no-inferrable-types': 'off',
      'prefer-const': 'error',
      'no-var': 'error',
    },
  },
  {
    ignores: ['dist/', 'node_modules/', '*.js'],
  },
];
</file>

<file path="test-variant-feedback.ts">
/**
 * Test script for variant feedback improvement system
 */

import { createVariantImprovementService } from './src/features/variant_generation/variant-improvement';

async function testVariantImprovement() {
    console.log('Testing Variant Feedback Improvement System\n');
    console.log('=' .repeat(50));

    const improvementService = createVariantImprovementService();

    // Test case: Button not centered
    const testCase1 = {
        originalCode: `
(function() {
    'use strict';

    const selector = 'div.shopbrand .item h3';
    const elements = document.querySelectorAll(selector);

    elements.forEach(h3 => {
        h3.style.backgroundColor = '#000000';
        h3.style.color = '#f4a70e';
        h3.style.fontFamily = 'Poppins, sans-serif';
        h3.style.fontSize = '14px';
        h3.style.fontWeight = '700';
        h3.style.textTransform = 'uppercase';
        h3.style.letterSpacing = '0.05em';
        h3.style.padding = '15px 24px';
        h3.style.margin = '16px 0';
    });
})();`,
        targetSelector: 'div.shopbrand .item h3',
        variantDescription: 'Transform category buttons to solid black with gold text',
        userFeedback: 'The buttons are not centered horizontally within their container'
    };

    console.log('\nTest Case 1: Button Centering Issue');
    console.log('User Feedback:', testCase1.userFeedback);
    console.log('\nImproving variant...\n');

    try {
        const result1 = await improvementService.improveVariant(testCase1);

        console.log('✅ Improvement Successful!');
        console.log('Confidence:', (result1.confidence * 100).toFixed(0) + '%');
        console.log('\nImprovements Made:');
        result1.improvements_made.forEach((improvement, i) => {
            console.log(`${i + 1}. ${improvement}`);
        });
        console.log('\nImproved Code:');
        console.log(result1.javascript_code);
    } catch (error) {
        console.error('❌ Test Case 1 Failed:', error);
    }

    console.log('\n' + '=' .repeat(50));

    // Test case: Button too small
    const testCase2 = {
        originalCode: `
(function() {
    'use strict';

    const buttons = document.querySelectorAll('.product-card .buy-btn');

    buttons.forEach(btn => {
        btn.style.backgroundColor = '#ff6b6b';
        btn.style.color = 'white';
        btn.style.padding = '8px 16px';
        btn.style.fontSize = '14px';
    });
})();`,
        targetSelector: '.product-card .buy-btn',
        variantDescription: 'Make buy buttons more prominent with red background',
        userFeedback: 'The button is too small and hard to click on mobile devices'
    };

    console.log('\nTest Case 2: Button Size Issue');
    console.log('User Feedback:', testCase2.userFeedback);
    console.log('\nImproving variant...\n');

    try {
        const result2 = await improvementService.improveVariant(testCase2);

        console.log('✅ Improvement Successful!');
        console.log('Confidence:', (result2.confidence * 100).toFixed(0) + '%');
        console.log('\nImprovements Made:');
        result2.improvements_made.forEach((improvement, i) => {
            console.log(`${i + 1}. ${improvement}`);
        });
        console.log('\nImproved Code:');
        console.log(result2.javascript_code);
    } catch (error) {
        console.error('❌ Test Case 2 Failed:', error);
    }

    console.log('\n' + '=' .repeat(50));
    console.log('\n✨ Testing Complete!');
}

// Run the test
testVariantImprovement().catch(console.error);
</file>

<file path="prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"
</file>

<file path="src/domain/agent/tools/get-brand-sources.ts">
// @ts-nocheck
// Brand Sources Tool - Get stored page content for reference
import { tool } from 'ai';
import { prisma } from '@infra/prisma';
import { getBrandAnalysisSchema } from './schemas';

class GetBrandSourcesExecutor {
  private projectId: string;

  constructor(projectId: string) {
    this.projectId = projectId;
  }

  async execute(input: { projectId?: string }) {
    try {
      console.log(`[BRAND_SOURCES] Using project ID: ${this.projectId}`);
      
      // Get screenshots with markdown content from database
      const screenshots = await prisma.screenshot.findMany({
        where: {
          projectId: this.projectId,
          markdownContent: { not: null }
        },
        select: {
          pageType: true,
          url: true,
          markdownContent: true
        },
        orderBy: {
          createdAt: 'desc'
        }
      });

      console.log(`[BRAND_SOURCES] Found ${screenshots.length} screenshots with markdown content`);
      
      if (screenshots.length === 0) {
        return {
          success: false,
          error: 'No page sources found for this project. Please run a brand analysis first.',
          data: null
        };
      }

      // Map to the expected format (markdown only)
      const markdownSources = screenshots.map(screenshot => ({
        pageType: screenshot.pageType,
        url: screenshot.url,
        markdown: screenshot.markdownContent
      }));
      
      return {
        success: true,
        data: markdownSources,
        message: `Retrieved ${markdownSources.length} page markdown sources for reference. Use this content to answer questions about what informed the analysis.`
      };
    } catch (error) {
      console.error('Error getting brand sources:', error);
      return {
        success: false,
        error: `Failed to retrieve brand sources: ${error instanceof Error ? error.message : 'Unknown error'}`,
        data: null
      };
    }
  }
}

export function createGetBrandSourcesTool(projectId: string) {
  const executor = new GetBrandSourcesExecutor(projectId);

  return tool({
    description: 'Get the stored page content (HTML/markdown) that was used for brand analysis. Use this to reference specific content when explaining analysis results.',
    inputSchema: getBrandAnalysisSchema,
    execute: async (input) => {
      try {
        return await executor.execute(input);
      } catch (error) {
        throw new Error(error instanceof Error ? error.message : 'Failed to fetch brand sources');
      }
    },
  });
}
</file>

<file path="src/features/brand_analysis/firecrawl-service.ts">
import Firecrawl from '@mendable/firecrawl-js';
import { getPageSpecificPrompt, type PageType } from './prompts';
import { brandIntelligenceSchema, type BrandIntelligenceData } from './types';


export interface FirecrawlScrapeResult {
    success: boolean;
    data?: BrandIntelligenceData;
    screenshot?: string;
    html?: string;
    markdown?: string;
    error?: string;
}


export interface PageAnalysisResult {
    pageType: PageType;
    url: string;
    data?: BrandIntelligenceData;
    screenshot?: string;
    html?: string;
    markdown?: string;
    error?: string;
}

export class FirecrawlService {
    private firecrawl: Firecrawl;

    constructor() {
        const apiKey = process.env.FIRECRAWL_API_KEY;
        if (!apiKey) {
            throw new Error('FIRECRAWL_API_KEY environment variable is required');
        }
        this.firecrawl = new Firecrawl({ apiKey });
    }

  /**
   * Convert screenshot URL to base64 data
   */
  private async convertScreenshotToBase64(screenshot: string): Promise<string | undefined> {
    if (!screenshot) {
      return undefined;
    }

    if (screenshot.startsWith('http')) {
      // If it's a URL, fetch the image and convert to base64
      try {
        const response = await fetch(screenshot);
        const arrayBuffer = await response.arrayBuffer();
        const base64 = Buffer.from(arrayBuffer).toString('base64');
        console.log(`[FIRECRAWL] Converted screenshot URL to base64 (${base64.length} chars)`);
        return base64;
      } catch (error) {
        console.warn(`[FIRECRAWL] Failed to fetch screenshot from URL: ${error}`);
        return undefined;
      }
    } else {
      // Assume it's already base64
      return screenshot;
    }
  }

  /**
   * Generate Shopify password authentication actions for Firecrawl
   * Currently only supports shop.omen.so with password 'reitri'
   */
  private getShopifyAuthActions(websiteUrl: string): any[] {
        // Check if this is the omen-mvp shop domain
        if (!websiteUrl.includes('shop.omen.so')) {
            return [];
        }

        console.log(`[FIRECRAWL] Detected omen-mvp domain, enabling authentication`);

    return [
      { "type": "wait", "milliseconds": 1000 },
      { 
        "type": "executeJavascript", 
        "script": `
          document.getElementById('password').value = 'reitri';
          document.querySelector('form').submit();
        `
      },
      { "type": "wait", "milliseconds": 2000 },
      { "type": "wait", "milliseconds": 5000 }
    ];
    }

  async analyzePage(websiteUrl: string, pageType: PageType): Promise<PageAnalysisResult> {
    try {
      console.log(`[FIRECRAWL] Starting ${pageType} page analysis for: ${websiteUrl}`);
      
      const pageSpecificPrompt = getPageSpecificPrompt(pageType);
      const authActions = this.getShopifyAuthActions(websiteUrl);
      
      const scrapeOptions: any = {
        onlyMainContent: true,
        formats: [
          {
            type: "json",
            schema: brandIntelligenceSchema,
            prompt: pageSpecificPrompt
          },
          {
            type: "screenshot",
            fullPage: true,
            quality: 100
          },
          "html",
          "markdown"
        ]
      };

      // Add authentication actions if enabled
      if (authActions.length > 0) {
        scrapeOptions.actions = authActions;
        console.log(`[FIRECRAWL] Using Shopify authentication for: ${websiteUrl}`);
      }
      
      const result = await this.firecrawl.scrape(websiteUrl, scrapeOptions);

      console.log(`[FIRECRAWL] ${pageType} page analysis completed for: ${websiteUrl}`);

      // Handle screenshot data - convert URL to base64 if needed
      const screenshotData = result.screenshot ? await this.convertScreenshotToBase64(result.screenshot) : undefined;

      return {
        pageType,
        url: websiteUrl,
        data: result.json as BrandIntelligenceData,
        screenshot: screenshotData,
        html: result.html,
        markdown: (result as any).markdown
      };
        } catch (error) {
            console.error(`[FIRECRAWL] Error analyzing ${pageType} page ${websiteUrl}:`, error);
            return {
                pageType,
                url: websiteUrl,
                error: error instanceof Error ? error.message : 'Unknown error occurred'
            };
        }
    }


    async scrapeWebsite(websiteUrl: string): Promise<FirecrawlScrapeResult> {
        try {
            console.log(`[FIRECRAWL] Starting scrape for: ${websiteUrl}`);

            const authActions = this.getShopifyAuthActions(websiteUrl);

            const scrapeOptions: any = {
                onlyMainContent: true,
                formats: [
                    {
                        type: "json",
                        schema: brandIntelligenceSchema,
                        prompt: getPageSpecificPrompt('home')
                    },
                    {
                        type: "screenshot",
                        fullPage: true,
                        quality: 100
                    },
                    "html"
                ]
            };

            // Add authentication actions if enabled
            if (authActions.length > 0) {
                scrapeOptions.actions = authActions;
                console.log(`[FIRECRAWL] Using Shopify authentication for: ${websiteUrl}`);
            }

            const result = await this.firecrawl.scrape(websiteUrl, scrapeOptions);

            console.log(`[FIRECRAWL] Scrape completed for: ${websiteUrl}`);

            // Handle screenshot data - convert URL to base64 if needed
            const screenshotData = result.screenshot ? await this.convertScreenshotToBase64(result.screenshot) : undefined;

            return {
                success: true,
                data: result.json as BrandIntelligenceData,
                screenshot: screenshotData,
                html: result.html
            };
        } catch (error) {
            console.error(`[FIRECRAWL] Error scraping ${websiteUrl}:`, error);
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Unknown error occurred'
            };
        }
    }
}
</file>

<file path="src/features/hypotheses_generation/types.ts">
// Types for hypotheses generation
export interface Hypothesis {
  title: string;
  description: string;
  primary_outcome: string;
  current_problem: string;
  why_it_works: Array<{
    reason: string;
  }>;
  baseline_performance: number;
  predicted_lift_range: {
    min: number;
    max: number;
  };
}
</file>

<file path="src/features/variant_generation/css-path-generator.ts">
/**
 * CSS Path Generator
 * Generates unique, specific CSS selectors for elements
 * Based on best practices for A/B testing selector generation
 */

import * as cheerio from 'cheerio';

export class CSSPathGenerator {
  private $: cheerio.CheerioAPI;

  constructor(html: string) {
    this.$ = cheerio.load(html);
  }

  /**
   * Generate a unique CSS selector for an element
   * Priority order:
   * 1. ID (if unique and not auto-generated)
   * 2. Data attributes (data-testid, data-test, etc.)
   * 3. Unique class combinations
   * 4. Semantic attributes (aria-label, name, etc.)
   * 5. Full path with nth-child
   */
  generateSelector(element: cheerio.Cheerio<any>): string {
    // Try ID first (only if really unique and not generated)
    const id = element.attr('id');
    if (id && this.isValidId(id) && id.length > 5) {
      const selector = `#${id}`;
      if (this.isUniqueSelector(selector)) {
        return selector;
      }
    }

    // Try data attributes
    const dataSelector = this.tryDataAttributes(element);
    if (dataSelector) return dataSelector;

    // For generic elements (button, link, li, etc.), always use full path
    const tagName = element[0].name;
    const genericTags = ['button', 'a', 'li', 'div', 'span', 'p', 'ul', 'ol', 'section', 'article', 'input'];
    if (genericTags.includes(tagName)) {
      return this.generateFullPath(element);
    }

    // Try unique class combinations only for non-generic elements
    const classSelector = this.tryUniqueClasses(element);
    if (classSelector) {
      // Even if we find a unique class, prefer full path for better specificity
      const classes = element.attr('class')?.split(' ') || [];
      const hasSemanticClass = classes.some((cls: string) =>
        cls.includes('-') || cls.includes('_') || cls.includes('__')
      );

      // Only use class selector if it has semantic classes
      if (hasSemanticClass) {
        return classSelector;
      }
    }

    // Try semantic attributes
    const semanticSelector = this.trySemanticAttributes(element);
    if (semanticSelector) return semanticSelector;

    // Default to full path for maximum specificity
    return this.generateFullPath(element);
  }

  /**
   * Generate the full CSS path with nth-child selectors
   * This always generates a unique selector
   */
  generateFullPath(element: cheerio.Cheerio<any>): string {
    const path: string[] = [];
    let current = element;

    while (current.length && current[0].name !== 'html') {
      const tagName = current[0].name;

      // Get the element's position among siblings of the same type
      const siblings = current.parent().children(tagName);
      const index = siblings.index(current[0]) + 1;

      let selector = tagName;

      // Add ID if available and valid
      const id = current.attr('id');
      if (id && this.isValidId(id)) {
        selector = `${tagName}#${id}`;
      }
      // Add important classes
      else if (current.attr('class')) {
        const classes = this.getImportantClasses(current);
        if (classes.length > 0) {
          selector = `${tagName}.${classes.join('.')}`;
        }
      }

      // Add nth-child if there are multiple siblings
      if (siblings.length > 1) {
        selector += `:nth-child(${index})`;
      }

      path.unshift(selector);

      // Stop at unique identifier
      if (id && this.isValidId(id)) {
        break;
      }

      current = current.parent();
    }

    return path.join(' > ');
  }

  /**
   * Check if an ID is valid (not auto-generated)
   */
  private isValidId(id: string): boolean {
    // Skip IDs that look auto-generated
    const invalidPatterns = [
      /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i, // UUID
      /^widget/i,
      /^ember/i,
      /^react/i,
      /^ng-/i,
      /^vue-/i,
      /^\d+$/, // Only numbers
      /^[a-z0-9]{32,}$/i // Long random strings
    ];

    return !invalidPatterns.some(pattern => pattern.test(id));
  }

  /**
   * Try to generate selector using data attributes
   */
  private tryDataAttributes(element: cheerio.Cheerio<any>): string | null {
    const dataAttrs = ['data-testid', 'data-test', 'data-cy', 'data-qa', 'data-id'];

    for (const attr of dataAttrs) {
      const value = element.attr(attr);
      if (value) {
        const selector = `[${attr}="${value}"]`;
        if (this.isUniqueSelector(selector)) {
          return selector;
        }
        // Add tag name for more specificity
        const tagSelector = `${element[0].name}[${attr}="${value}"]`;
        if (this.isUniqueSelector(tagSelector)) {
          return tagSelector;
        }
      }
    }

    return null;
  }

  /**
   * Try to generate selector using unique class combinations
   */
  private tryUniqueClasses(element: cheerio.Cheerio<any>): string | null {
    const classes = this.getImportantClasses(element);
    if (classes.length === 0) return null;

    const tagName = element[0].name;

    // Try single class
    for (const cls of classes) {
      const selector = `${tagName}.${cls}`;
      if (this.isUniqueSelector(selector)) {
        return selector;
      }
    }

    // Try combination of two classes
    if (classes.length >= 2) {
      const selector = `${tagName}.${classes.slice(0, 2).join('.')}`;
      if (this.isUniqueSelector(selector)) {
        return selector;
      }
    }

    // Try all classes
    const selector = `${tagName}.${classes.join('.')}`;
    if (this.isUniqueSelector(selector)) {
      return selector;
    }

    return null;
  }

  /**
   * Try semantic attributes like aria-label, name, etc.
   */
  private trySemanticAttributes(element: cheerio.Cheerio<any>): string | null {
    const attrs = ['aria-label', 'name', 'title', 'alt', 'placeholder'];
    const tagName = element[0].name;

    for (const attr of attrs) {
      const value = element.attr(attr);
      if (value && value.length < 50) { // Avoid very long values
        const selector = `${tagName}[${attr}="${value}"]`;
        if (this.isUniqueSelector(selector)) {
          return selector;
        }
      }
    }

    return null;
  }

  /**
   * Get important classes (filter out utility classes)
   */
  private getImportantClasses(element: cheerio.Cheerio<any>): string[] {
    const classStr = element.attr('class');
    if (!classStr) return [];

    const classes = classStr.split(/\s+/).filter((cls: string) => {
      // Filter out common utility classes
      const utilityPatterns = [
        /^m[tlrb]?-\d+$/,  // margin utilities
        /^p[tlrb]?-\d+$/,  // padding utilities
        /^text-/,          // text utilities
        /^bg-/,            // background utilities
        /^flex/,           // flex utilities
        /^grid/,           // grid utilities
        /^w-\d+$/,         // width utilities
        /^h-\d+$/,         // height utilities
        /^hidden$/,
        /^block$/,
        /^inline/,
        /^absolute$/,
        /^relative$/,
        /^fixed$/,
        /^sticky$/
      ];

      // Keep semantic classes
      return cls.length > 2 &&
             !utilityPatterns.some(pattern => pattern.test(cls));
    });

    return classes;
  }

  /**
   * Check if a selector uniquely identifies one element
   */
  private isUniqueSelector(selector: string): boolean {
    try {
      const elements = this.$(selector);
      return elements.length === 1;
    } catch {
      return false;
    }
  }

  /**
   * Generate selector for a specific text content
   */
  generateSelectorForText(text: string, tagName?: string): string | null {
    const searchTag = tagName || '*';
    const elements = this.$(searchTag).filter((_, el) => {
      const $el = this.$(el);
      return $el.text().trim() === text;
    });

    if (elements.length === 1) {
      return this.generateSelector(elements.eq(0));
    }

    // If multiple matches, try to find the most prominent one
    if (elements.length > 1) {
      // Prefer elements higher in the DOM
      const first = elements.eq(0);
      return this.generateSelector(first);
    }

    return null;
  }
}

/**
 * Generate a unique CSS selector for an element in HTML
 */
export function generateUniqueSelector(html: string, element: cheerio.Cheerio<any>): string {
  const generator = new CSSPathGenerator(html);
  return generator.generateSelector(element);
}

/**
 * Generate selector for text content
 */
export function generateSelectorForText(html: string, text: string, tagName?: string): string | null {
  const generator = new CSSPathGenerator(html);
  return generator.generateSelectorForText(text, tagName);
}
</file>

<file path="src/features/variant_generation/design-system-extractor.ts">
// Design System Extraction Service
import { z } from 'zod';
import { generateObject } from 'ai';
import { google } from '@ai-sdk/google';
import { getVariantGenerationAIConfig } from '@shared/ai-config';

// Simplified design system schema focused on practical CSS values
export const designSystemSchema = z.object({
  typography: z.object({
    primary_font: z.string().describe('Primary font family'),
    body_font: z.string().describe('Body text font family'),
    heading_sizes: z.object({
      h1: z.string().describe('H1 font size in px'),
      h2: z.string().describe('H2 font size in px'),
      button: z.string().describe('Button font size in px')
    }),
    font_weights: z.object({
      regular: z.string().describe('Regular weight (e.g., 400)'),
      bold: z.string().describe('Bold weight (e.g., 700)')
    }),
    text_transform_buttons: z.enum(['none', 'uppercase', 'capitalize']).describe('Button text transform')
  }),

  colors: z.object({
    primary_button_bg: z.string().describe('Primary button background color (hex)'),
    primary_button_text: z.string().describe('Primary button text color (hex)'),
    primary_button_hover_bg: z.string().describe('Primary button hover background (hex)'),
    accent_color: z.string().describe('Accent/highlight color (hex)'),
    text_primary: z.string().describe('Primary text color (hex)'),
    background: z.string().describe('Main background color (hex)')
  }),

  spacing: z.object({
    button_padding: z.string().describe('Button padding (e.g., "12px 24px")'),
    button_margin: z.string().describe('Button margin (e.g., "16px 0")'),
    section_spacing: z.string().describe('Space between sections (e.g., "48px")')
  }),

  borders: z.object({
    button_radius: z.string().describe('Button border radius (e.g., "4px", "9999px")'),
    card_radius: z.string().describe('Card border radius (e.g., "8px")'),
    button_border: z.string().describe('Button border style (e.g., "none", "1px solid #000")')
  }),

  shadows: z.object({
    button_shadow: z.string().describe('Button box shadow'),
    button_hover_shadow: z.string().describe('Button hover box shadow'),
    card_shadow: z.string().describe('Card box shadow')
  }),

  animations: z.object({
    transition_duration: z.string().describe('Default transition duration (e.g., "0.2s")'),
    transition_timing: z.string().describe('Default timing function (e.g., "ease-in-out")'),
    button_hover_transform: z.string().describe('Button hover transform (e.g., "scale(1.05)", "translateY(-2px)")')
  }),

  ui_patterns: z.object({
    uses_uppercase_buttons: z.boolean(),
    uses_rounded_corners: z.boolean(),
    uses_shadows: z.boolean(),
    uses_gradients: z.boolean(),
    uses_animations: z.boolean(),
    button_style: z.enum(['solid', 'outline', 'ghost', 'gradient']).describe('Primary button style')
  })
});

export type DesignSystem = z.infer<typeof designSystemSchema>;

export class DesignSystemExtractor {
  async extractDesignSystem(
    screenshot: string,
    htmlContent: string | null
  ): Promise<DesignSystem> {
    const prompt = `Analyze this website screenshot and HTML to extract the design system and visual patterns.

Focus on extracting EXACT CSS values that are currently being used in the site, particularly for:
- Buttons (primary CTA buttons, add to cart, shop now, etc.)
- Typography (font families, sizes, weights)
- Colors (exact hex codes from buttons and key elements)
- Spacing and padding patterns
- Border radius and shadows
- Animations and transitions

IMPORTANT: Extract the ACTUAL values from the site, not generic defaults. Look at:
1. The primary call-to-action buttons (Add to Cart, Shop Now, etc.)
2. The actual font families being used (inspect the CSS)
3. The exact colors in hex format
4. The specific padding, margins, and spacing
5. Any hover effects or animations present

Return a JSON object with the exact CSS values found in the site.`;

    const aiConfig = getVariantGenerationAIConfig();

    try {
      const messages: any[] = [
        {
          role: 'user',
          content: [
            { type: "text", text: prompt },
            { type: "image", image: this.toDataUrl(screenshot) }
          ]
        }
      ];

      // Add HTML content if available
      if (htmlContent) {
        messages[0].content.push({
          type: "text",
          text: `HTML Content (first 10000 chars): ${htmlContent.substring(0, 10000)}`
        });
      }

      const result = await generateObject({
        model: google(aiConfig.model),
        schema: designSystemSchema,
        messages
      });

      console.log('[DESIGN_SYSTEM] Extracted design system successfully');
      return result.object;
    } catch (error) {
      console.error('[DESIGN_SYSTEM] Failed to extract design system:', error);
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`Failed to extract design system: ${errorMessage}`);
    }
  }

  private toDataUrl(b64: string): string {
    if (!b64) return '';
    if (b64.startsWith('data:')) return b64;
    return `data:image/png;base64,${b64}`;
  }
}
</file>

<file path="src/features/variant_generation/hypothesis-aware-selector.ts">
// Hypothesis-Aware Selector Generation
// This module provides intelligent selector generation based on hypothesis context

import * as cheerio from 'cheerio';
import { generateObject } from 'ai';
import { google } from '@ai-sdk/google';
import { z } from 'zod';
import { getAIConfig } from '@shared/ai-config';

export interface HypothesisSelector {
  selector: string;
  confidence: number;
  context: {
    elementText?: string;
    elementType: string;
    parentContext?: string;
    siblingContext?: string;
    htmlSnippet: string;
  };
  reasoning: string;
  alternativeSelectors: string[];
  validation: {
    exists: boolean;
    unique: boolean;
    stable: boolean;
  };
}

const selectorGenerationSchema = z.object({
  primary_selector: z.string().describe('The most specific CSS selector for the target element'),
  element_identifier: z.string().describe('Natural language description of what element we are looking for'),
  search_strategy: z.enum(['text_content', 'section_heading', 'structural', 'semantic']).describe('How to find this element'),
  alternative_selectors: z.array(z.string()).describe('Fallback selectors in order of preference'),
  confidence: z.number().min(0).max(1).describe('Confidence between 0 and 1 (e.g., 0.95 for 95% confidence)'),
  reasoning: z.string().describe('Why this selector was chosen')
});

export class HypothesisAwareSelectorGenerator {
  private $: cheerio.CheerioAPI;
  private html: string;

  constructor(html: string) {
    this.html = html;
    this.$ = cheerio.load(html);
  }

  async generateSelector(hypothesis: string): Promise<HypothesisSelector[]> {
    console.log(`[HYPOTHESIS_SELECTOR] Generating selector for: "${hypothesis}"`);

    // Step 1: Use AI to understand what element we're looking for
    const aiConfig = getAIConfig();
    const elementIdentification = await generateObject({
      model: google(aiConfig.model),
      schema: selectorGenerationSchema,
      messages: [{
        role: 'user',
        content: this.buildIdentificationPrompt(hypothesis)
      }]
    });

    const result = elementIdentification.object;
    console.log(`[HYPOTHESIS_SELECTOR] AI identified element: ${result.element_identifier}`);
    console.log(`[HYPOTHESIS_SELECTOR] Search strategy: ${result.search_strategy}`);

    // Step 2: Find the element based on the AI's understanding
    const candidates = await this.findElementCandidates(result);

    // Step 3: Validate and rank the candidates
    const validatedCandidates = this.validateAndRankCandidates(candidates, hypothesis);

    console.log(`[HYPOTHESIS_SELECTOR] Found ${validatedCandidates.length} validated candidates`);
    return validatedCandidates;
  }

  private buildIdentificationPrompt(hypothesis: string): string {
    return `Analyze this A/B test hypothesis and identify the exact DOM element that needs to be modified:

HYPOTHESIS: "${hypothesis}"

Based on this hypothesis, determine:
1. What specific element or section is being targeted (be very specific)
2. How to best find this element (text content, heading, structure, or semantic markup)
3. Generate CSS selectors that would target this element

IMPORTANT:
- If the hypothesis mentions a specific section name (e.g., "Engineered for Every Turn"), look for that exact text
- If it mentions a button or link, identify it by its text content
- Generate multiple selector strategies for reliability
- Avoid using generated IDs or classes with numbers
- Confidence must be a decimal between 0 and 1 (e.g., 0.95 for 95% confidence)

HTML STRUCTURE TO ANALYZE:
${this.getRelevantHtmlSnippet()}

Return selectors that precisely target the element mentioned in the hypothesis.
The confidence field must be a decimal value between 0 and 1.`;
  }

  private getRelevantHtmlSnippet(): string {
    // Extract relevant parts of HTML for analysis
    // Focus on main content areas, avoiding scripts and styles
    const mainContent = this.$('main, [role="main"], body').html() || this.html;

    // Truncate to reasonable size while preserving structure
    const maxLength = 30000;
    if (mainContent.length > maxLength) {
      // Try to find natural break points
      const truncated = mainContent.substring(0, maxLength);
      const lastCloseTag = truncated.lastIndexOf('</');
      if (lastCloseTag > maxLength * 0.8) {
        return truncated.substring(0, lastCloseTag);
      }
      return truncated;
    }

    return mainContent;
  }

  private async findElementCandidates(aiResult: any): Promise<HypothesisSelector[]> {
    const candidates: HypothesisSelector[] = [];

    // Try each selector suggested by AI (limit to first 10 to avoid infinite loops)
    const allSelectors = [aiResult.primary_selector, ...aiResult.alternative_selectors].slice(0, 10);

    for (const selector of allSelectors) {
      try {
        const elements = this.$(selector);

        if (elements.length === 0) {
          console.log(`[HYPOTHESIS_SELECTOR] Selector "${selector}" found no elements`);
          continue;
        }

        if (elements.length > 1) {
          console.log(`[HYPOTHESIS_SELECTOR] Selector "${selector}" found ${elements.length} elements - may need section-level targeting`);
          // For some hypotheses, we might want to target a section that contains multiple elements
          // Create a candidate anyway but with lower confidence
          const element = elements.first();
          const candidate = this.createCandidate(element, selector,
            `${aiResult.reasoning} (targets section with ${elements.length} elements)`);
          candidate.confidence = candidate.confidence * 0.5; // Lower confidence for multi-match
          candidates.push(candidate);
          continue;
        }

        // Found exactly one element - create candidate
        const element = elements.first();
        const candidate = this.createCandidate(element, selector, aiResult.reasoning);
        candidates.push(candidate);

      } catch (error) {
        console.log(`[HYPOTHESIS_SELECTOR] Invalid selector "${selector}": ${error}`);
      }
    }

    // If no candidates found, try text-based search
    if (candidates.length === 0 && aiResult.element_identifier) {
      console.log(`[HYPOTHESIS_SELECTOR] No candidates found, trying text-based search`);
      const textBasedCandidates = this.findByText(aiResult.element_identifier);
      candidates.push(...textBasedCandidates);
    }

    return candidates;
  }

  private findByText(searchText: string): HypothesisSelector[] {
    const candidates: HypothesisSelector[] = [];

    // Search for elements containing the text
    this.$('*').each((_, el) => {
      const $el = this.$(el);
      const text = $el.text().trim();

      // Look for exact or close matches
      if (text.toLowerCase().includes(searchText.toLowerCase())) {
        // Check if this is the most specific element with this text
        const children = $el.children();
        const hasTextDirectly = $el.clone().children().remove().end().text().trim()
          .toLowerCase().includes(searchText.toLowerCase());

        if (hasTextDirectly || children.length === 0) {
          // Generate a selector for this element
          const selector = this.generateSelectorForElement($el);
          if (selector) {
            const candidate = this.createCandidate($el, selector,
              `Found by text content: "${searchText}"`);
            candidates.push(candidate);
          }
        }
      }
    });

    return candidates;
  }

  private generateSelectorForElement($el: cheerio.Cheerio<any>): string | null {
    const element = $el[0];
    if (!element || element.type !== 'tag') return null;

    const tagName = element.name;
    const id = $el.attr('id');
    const classes = $el.attr('class');
    const dataTestId = $el.attr('data-testid');

    // Prefer data-testid
    if (dataTestId) {
      return `[data-testid="${dataTestId}"]`;
    }

    // Use ID if it looks stable
    if (id && !this.isGeneratedId(id)) {
      return `#${id}`;
    }

    // Use semantic classes
    if (classes) {
      const classList = classes.split(' ').filter(c => c.trim());
      const stableClasses = classList.filter(c => !this.isGeneratedClass(c));
      if (stableClasses.length > 0) {
        return `${tagName}.${stableClasses.join('.')}`;
      }
    }

    // Generate path-based selector
    return this.generatePathSelector($el);
  }

  private generatePathSelector($el: cheerio.Cheerio<any>): string {
    const path: string[] = [];
    let current = $el;

    while (current.length > 0 && current[0].name !== 'body') {
      const element = current[0];
      if (element.type !== 'tag') break;

      const tagName = element.name;
      const id = current.attr('id');
      const classes = current.attr('class');

      let selector = tagName;

      if (id && !this.isGeneratedId(id)) {
        path.unshift(`#${id}`);
        break; // ID is unique, no need to go further
      }

      if (classes) {
        const classList = classes.split(' ').filter(c => c.trim());
        const stableClasses = classList.filter(c => !this.isGeneratedClass(c));
        if (stableClasses.length > 0) {
          selector = `${tagName}.${stableClasses[0]}`;
        }
      }

      // Add index if there are siblings of same type
      const siblings = current.siblings(tagName);
      if (siblings.length > 0) {
        const index = current.index() + 1;
        selector = `${selector}:nth-of-type(${index})`;
      }

      path.unshift(selector);
      current = current.parent();
    }

    return path.join(' > ');
  }


  private createCandidate(
    $el: cheerio.Cheerio<any>,
    selector: string,
    reasoning: string
  ): HypothesisSelector {
    const element = $el[0];
    const parent = $el.parent();
    const htmlSnippet = this.$.html($el[0]).substring(0, 500);

    return {
      selector,
      confidence: 0.8,
      context: {
        elementText: $el.text().trim().substring(0, 100),
        elementType: element.type === 'tag' ? element.name : 'unknown',
        parentContext: parent.length > 0 ? parent[0].name : undefined,
        siblingContext: $el.siblings().length > 0 ? `${$el.siblings().length} siblings` : undefined,
        htmlSnippet
      },
      reasoning,
      alternativeSelectors: this.generateAlternativeSelectors($el),
      validation: {
        exists: true,
        unique: this.$(selector).length === 1,
        stable: !this.hasGeneratedPatterns(selector)
      }
    };
  }

  private generateAlternativeSelectors($el: cheerio.Cheerio<any>): string[] {
    const alternatives: string[] = [];

    // Try different selector strategies
    const strategies = [
      () => this.generatePathSelector($el),
      () => this.generateAttributeSelector($el),
      () => this.generateTextSelector($el),
      () => this.generateStructuralSelector($el)
    ];

    for (const strategy of strategies) {
      const selector = strategy();
      if (selector && !alternatives.includes(selector)) {
        alternatives.push(selector);
      }
    }

    return alternatives.slice(0, 5); // Limit to 5 alternatives
  }

  private generateAttributeSelector($el: cheerio.Cheerio<any>): string | null {
    const attrs = $el.attr();
    if (!attrs) return null;

    const tagName = $el[0].name;
    const stableAttrs = ['role', 'aria-label', 'type', 'name', 'placeholder'];

    for (const attr of stableAttrs) {
      if (attrs[attr]) {
        return `${tagName}[${attr}="${attrs[attr]}"]`;
      }
    }

    return null;
  }

  private generateTextSelector($el: cheerio.Cheerio<any>): string | null {
    const text = $el.text().trim();
    if (!text || text.length > 50) return null;

    const tagName = $el[0].name;
    // Note: :contains is not standard CSS but works with cheerio
    return `${tagName}:contains("${text.substring(0, 30)}")`;
  }

  private generateStructuralSelector($el: cheerio.Cheerio<any>): string | null {
    const parent = $el.parent();
    if (parent.length === 0) return null;

    const parentTag = parent[0].name;
    const tagName = $el[0].name;
    const index = $el.index() + 1;

    return `${parentTag} > ${tagName}:nth-child(${index})`;
  }

  private validateAndRankCandidates(
    candidates: HypothesisSelector[],
    hypothesis: string
  ): HypothesisSelector[] {
    // Score and rank candidates
    const scored = candidates.map(candidate => {
      let score = 0;

      // Validation scores
      if (candidate.validation.exists) score += 3;
      if (candidate.validation.unique) score += 3;
      if (candidate.validation.stable) score += 2;

      // Context relevance
      const hypWords = hypothesis.toLowerCase().split(/\s+/);
      const contextText = (candidate.context.elementText || '').toLowerCase();
      for (const word of hypWords) {
        if (contextText.includes(word)) score += 1;
      }

      // Confidence from AI
      score += candidate.confidence * 5;

      return { candidate, score };
    });

    // Sort by score and return
    scored.sort((a, b) => b.score - a.score);
    return scored.map(s => s.candidate);
  }

  private isGeneratedId(id: string): boolean {
    const patterns = [
      /template--\d+/,
      /\d{10,}/,
      /^[a-f0-9]{8,}$/i
    ];
    return patterns.some(p => p.test(id));
  }

  private isGeneratedClass(className: string): boolean {
    const patterns = [
      /^\d+$/,
      /^[a-f0-9]{8,}$/i,
      /-\d{10,}$/
    ];
    return patterns.some(p => p.test(className));
  }

  private hasGeneratedPatterns(selector: string): boolean {
    return this.isGeneratedId(selector) ||
           selector.includes('template--') ||
           selector.includes('shopify-section-');
  }
}

export function createHypothesisAwareSelector(html: string): HypothesisAwareSelectorGenerator {
  return new HypothesisAwareSelectorGenerator(html);
}
</file>

<file path="src/infra/dal/chat-message.ts">
// Chat Message Data Access Layer
import { ChatMessage, MessageRole, Prisma } from '@prisma/client';
import { prisma } from '../prisma';

export interface CreateChatMessageData {
    projectId: string;
    role: MessageRole;
    content: {
        text?: string;
        metadata?: Record<string, unknown>;
        toolCalls?: Array<{
            id: string;
            type: string;
            function: {
                name: string;
                arguments: string;
            };
        }>;
        toolCallId?: string;
    };
}

export interface UpdateChatMessageData {
    content?: {
        text?: string;
        metadata?: Record<string, unknown>;
        toolCalls?: Array<{
            id: string;
            type: string;
            function: {
                name: string;
                arguments: string;
            };
        }>;
        toolCallId?: string;
    };
}

export class ChatMessageDAL {
    static async createMessage(data: CreateChatMessageData): Promise<ChatMessage> {
        // Clean up content object to remove undefined values
        const cleanContent: Record<string, unknown> = {};
        
        if (data.content.text !== undefined) {
            cleanContent.text = data.content.text;
        }
        
        if (data.content.metadata !== undefined) {
            cleanContent.metadata = data.content.metadata;
        }
        
        if (data.content.toolCalls !== undefined && data.content.toolCalls.length > 0) {
            cleanContent.toolCalls = data.content.toolCalls;
        }
        
        if (data.content.toolCallId !== undefined) {
            cleanContent.toolCallId = data.content.toolCallId;
        }
        
        return await prisma.chatMessage.create({
            data: {
                projectId: data.projectId,
                role: data.role,
                content: cleanContent as Prisma.InputJsonValue,
            },
        });
    }

    static async getMessagesByProject(
        projectId: string,
        limit?: number,
        offset?: number
    ): Promise<ChatMessage[]> {
        return await prisma.chatMessage.findMany({
            where: { projectId },
            orderBy: { createdAt: 'asc' },
            ...(limit && { take: limit }),
            ...(offset && { skip: offset }),
        });
    }

    static async updateMessage(
        messageId: string,
        data: UpdateChatMessageData
    ): Promise<ChatMessage> {
        return await prisma.chatMessage.update({
            where: { id: messageId },
            data: {
                ...(data.content && { content: data.content as Prisma.InputJsonValue }),
            },
        });
    }

    static async deleteMessage(messageId: string): Promise<void> {
        await prisma.chatMessage.delete({
            where: { id: messageId },
        });
    }

    static async getMessageById(messageId: string): Promise<ChatMessage | null> {
        return await prisma.chatMessage.findUnique({
            where: { id: messageId },
        });
    }

    static async getLatestMessagesByProject(
        projectId: string,
        count: number = 10
    ): Promise<ChatMessage[]> {
        return await prisma.chatMessage.findMany({
            where: { projectId },
            orderBy: { createdAt: 'desc' },
            take: count,
        });
    }

    static async countMessagesByProject(projectId: string): Promise<number> {
        return await prisma.chatMessage.count({
            where: { projectId },
        });
    }
}
</file>

<file path="src/infra/dal/experiment.ts">
// Experiment Data Access Layer
import { prisma } from '@infra/prisma';
import type { Experiment, ExperimentWithProject, CreateExperimentData, UpdateExperimentStatusData } from './types';
import type { ActiveTarget } from '@features/conflict_guard';
import { sha256, canonicalizeSelector } from '@features/conflict_guard';

export class ExperimentDAL {
  /**
   * Create a new experiment
   */
  static async createExperiment(data: CreateExperimentData): Promise<Experiment> {
    return await prisma.experiment.create({
      data,
    });
  }

  /**
   * Get experiment by ID
   */
  static async getExperimentById(experimentId: string): Promise<Experiment | null> {
    return await prisma.experiment.findUnique({
      where: { id: experimentId },
    });
  }

  /**
   * Get experiment with project details
   */
  static async getExperimentWithProject(experimentId: string): Promise<ExperimentWithProject | null> {
    return await prisma.experiment.findUnique({
      where: { id: experimentId },
      include: {
        project: true,
      },
    });
  }

  /**
   * Get all experiments for a project
   */
  static async getExperimentsByProject(projectId: string): Promise<Experiment[]> {
    return await prisma.experiment.findMany({
      where: { projectId },
      orderBy: { createdAt: 'desc' },
    });
  }

  /**
   * Get experiments by project and status
   */
  static async getExperimentsByProjectAndStatus(
    projectId: string,
    status: string
  ): Promise<Experiment[]> {
    return await prisma.experiment.findMany({
      where: {
        projectId,
        status: status as any, // Type assertion for enum
      },
      orderBy: { createdAt: 'desc' },
    });
  }

  /**
   * Update experiment status and related timestamps
   */
  static async updateStatus(data: UpdateExperimentStatusData): Promise<Experiment> {
    const updateData: any = {
      status: data.status,
    };

    // Set publishedAt when transitioning to RUNNING
    if (data.status === 'RUNNING' && data.publishedAt) {
      updateData.publishedAt = data.publishedAt;
    }

    // Set finishedAt when transitioning to COMPLETED
    if (data.status === 'COMPLETED' && data.finishedAt) {
      updateData.finishedAt = data.finishedAt;
    }

    return await prisma.experiment.update({
      where: { id: data.experimentId },
      data: updateData,
    });
  }


  /**
   * Update experiment name
   */
  static async updateExperimentName(
    experimentId: string,
    name: string
  ): Promise<Experiment> {
    return await prisma.experiment.update({
      where: { id: experimentId },
      data: { name },
    });
  }

  /**
   * Delete experiment
   */
  static async deleteExperiment(experimentId: string): Promise<void> {
    await prisma.experiment.delete({
      where: { id: experimentId },
    });
  }

  /**
   * Get experiment count for a project
   */
  static async getExperimentCount(projectId: string): Promise<number> {
    return await prisma.experiment.count({
      where: { projectId },
    });
  }

  /**
   * Get experiments by status across all projects (admin function)
   */
  static async getExperimentsByStatus(status: string): Promise<Experiment[]> {
    return await prisma.experiment.findMany({
      where: {
        status: status as any, // Type assertion for enum
      },
      orderBy: { createdAt: 'desc' },
    });
  }

  /**
   * Get active experiment targets for conflict detection
   * Returns simplified target information for all running/ramping experiments
   */
  static async getActiveTargets(projectId: string): Promise<ActiveTarget[]> {
    // Get all active experiments with their variants
    const experiments = await prisma.experiment.findMany({
      where: {
        projectId,
        status: {
          in: ['RUNNING', 'PAUSED'] // Include paused if variants still live
        }
      },
      include: {
        variants: true,
        hypothesis: true
      }
    });

    // Transform to ActiveTarget format
    const activeTargets: ActiveTarget[] = [];

    for (const exp of experiments) {
      // For each experiment, extract target information from variants
      for (const variant of exp.variants) {
        // Create a target entry for each variant's selector
        if (variant.selector && variant.selector !== 'body') {
          activeTargets.push({
            experimentId: exp.id,
            urlPattern: '/*', // Default to all pages for now, can be enhanced
            targetKey: variant.selector ? sha256(canonicalizeSelector(variant.selector)) : undefined,
            roleKey: undefined, // Role extraction can be enhanced based on variant metadata
            label: exp.hypothesis?.hypothesis.substring(0, 50) || exp.name
          });
        }
      }
    }

    return activeTargets;
  }
}
</file>

<file path="src/infra/external/cloudflare/cloudflare-publisher.ts">
// Cloudflare Publisher Service
import { CloudflareConfig, PublishedExperiment, CloudflarePublishResult } from './types';

export interface CloudflarePublisher {
  publishExperiment(experiment: PublishedExperiment): Promise<CloudflarePublishResult>;
  unpublishExperiment(experimentId: string): Promise<CloudflarePublishResult>;
  getPublishedExperiments(): Promise<PublishedExperiment[]>;
}

export class CloudflarePublisherImpl implements CloudflarePublisher {
  private config: CloudflareConfig;
  private baseUrl: string;

  constructor(config: CloudflareConfig) {
    this.config = config;
    this.baseUrl = `https://api.cloudflare.com/client/v4/accounts/${config.accountId}/storage/kv/namespaces/${config.namespaceId}`;
  }

  async publishExperiment(experiment: PublishedExperiment): Promise<CloudflarePublishResult> {
    const key = `experiment:${experiment.id}`;
    console.log(`[CLOUDFLARE_PUBLISHER] Publishing experiment ${experiment.id} to Cloudflare KV`);
    console.log(`[CLOUDFLARE_PUBLISHER] Key: ${key}`);
    console.log(`[CLOUDFLARE_PUBLISHER] Experiment data:`, {
      id: experiment.id,
      name: experiment.name,
      status: experiment.status,
      variantCount: Object.keys(experiment.variants).length,
      trafficDistribution: experiment.traffic
    });

    try {
      const value = JSON.stringify(experiment);
      console.log(`[CLOUDFLARE_PUBLISHER] Payload size: ${value.length} bytes`);

      const response = await fetch(`${this.baseUrl}/values/${key}`, {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${this.config.apiToken}`,
          'Content-Type': 'application/json',
        },
        body: value,
      });

      console.log(`[CLOUDFLARE_PUBLISHER] Cloudflare API response: ${response.status} ${response.statusText}`);

      if (!response.ok) {
        const errorText = await response.text();
        console.error(`[CLOUDFLARE_PUBLISHER] Cloudflare API error response:`, errorText);
        throw new Error(`Cloudflare API error: ${response.status} - ${errorText}`);
      }

      const result = await response.json();
      console.log(`[CLOUDFLARE_PUBLISHER] Successfully published experiment ${experiment.id} to Cloudflare`);
      console.log(`[CLOUDFLARE_PUBLISHER] Cloudflare response:`, result);

      return {
        success: true,
        experimentId: experiment.id,
        key,
      };
    } catch (error) {
      console.error(`[CLOUDFLARE_PUBLISHER] Failed to publish experiment ${experiment.id}:`, error);
      console.error(`[CLOUDFLARE_PUBLISHER] Error details:`, {
        message: error instanceof Error ? error.message : 'Unknown error',
        stack: error instanceof Error ? error.stack : undefined,
        experimentId: experiment.id,
        key
      });
      return {
        success: false,
        experimentId: experiment.id,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  async unpublishExperiment(experimentId: string): Promise<CloudflarePublishResult> {
    const key = `experiment:${experimentId}`;
    console.log(`[CLOUDFLARE_PUBLISHER] Unpublishing experiment ${experimentId} from Cloudflare KV`);
    console.log(`[CLOUDFLARE_PUBLISHER] Key: ${key}`);

    try {
      const response = await fetch(`${this.baseUrl}/values/${key}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${this.config.apiToken}`,
        },
      });

      console.log(`[CLOUDFLARE_PUBLISHER] Cloudflare API response: ${response.status} ${response.statusText}`);

      if (!response.ok) {
        const errorText = await response.text();
        console.error(`[CLOUDFLARE_PUBLISHER] Cloudflare API error response:`, errorText);
        throw new Error(`Cloudflare API error: ${response.status} - ${errorText}`);
      }

      const result = await response.json();
      console.log(`[CLOUDFLARE_PUBLISHER] Successfully unpublished experiment ${experimentId} from Cloudflare`);
      console.log(`[CLOUDFLARE_PUBLISHER] Cloudflare response:`, result);

      return {
        success: true,
        experimentId,
        key,
      };
    } catch (error) {
      console.error(`[CLOUDFLARE_PUBLISHER] Failed to unpublish experiment ${experimentId}:`, error);
      console.error(`[CLOUDFLARE_PUBLISHER] Error details:`, {
        message: error instanceof Error ? error.message : 'Unknown error',
        stack: error instanceof Error ? error.stack : undefined,
        experimentId,
        key
      });
      return {
        success: false,
        experimentId,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  async getPublishedExperiments(): Promise<PublishedExperiment[]> {
    console.log(`[CLOUDFLARE_PUBLISHER] Fetching all published experiments from Cloudflare KV`);
    
    try {
      const response = await fetch(`${this.baseUrl}/keys?prefix=experiment:`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${this.config.apiToken}`,
        },
      });

      console.log(`[CLOUDFLARE_PUBLISHER] Keys API response: ${response.status} ${response.statusText}`);

      if (!response.ok) {
        const errorText = await response.text();
        console.error(`[CLOUDFLARE_PUBLISHER] Cloudflare API error response:`, errorText);
        throw new Error(`Cloudflare API error: ${response.status} - ${errorText}`);
      }

      const data = await response.json();
      console.log(`[CLOUDFLARE_PUBLISHER] Found ${data.result.length} experiment keys`);
      
      const experiments: PublishedExperiment[] = [];

      // Fetch each experiment's data
      for (const keyInfo of data.result) {
        console.log(`[CLOUDFLARE_PUBLISHER] Fetching experiment data for key: ${keyInfo.name}`);
        
        const experimentResponse = await fetch(`${this.baseUrl}/values/${keyInfo.name}`, {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${this.config.apiToken}`,
          },
        });

        if (experimentResponse.ok) {
          const experiment = await experimentResponse.json();
          experiments.push(experiment);
          console.log(`[CLOUDFLARE_PUBLISHER] Successfully loaded experiment: ${experiment.id}`);
        } else {
          console.error(`[CLOUDFLARE_PUBLISHER] Failed to fetch experiment data for key ${keyInfo.name}: ${experimentResponse.status}`);
        }
      }

      console.log(`[CLOUDFLARE_PUBLISHER] Successfully loaded ${experiments.length} experiments from Cloudflare`);
      return experiments;
    } catch (error) {
      console.error(`[CLOUDFLARE_PUBLISHER] Failed to get published experiments:`, error);
      console.error(`[CLOUDFLARE_PUBLISHER] Error details:`, {
        message: error instanceof Error ? error.message : 'Unknown error',
        stack: error instanceof Error ? error.stack : undefined
      });
      return [];
    }
  }
}

export function createCloudflarePublisher(config: CloudflareConfig): CloudflarePublisher {
  return new CloudflarePublisherImpl(config);
}
</file>

<file path="src/infra/external/cloudflare/index.ts">
// Cloudflare External Service
export * from './types';
export * from './cloudflare-publisher';
</file>

<file path="src/infra/external/posthog/index.ts">
/**
 * PostHog External Service Module
 * 
 * Exports PostHog service and related utilities
 */

export { PostHogService } from './service';
export { getPostHogConfig } from './config';
export type {
  PostHogQueryParams,
  PostHogQueryResponse,
  PostHogEvent,
  PostHogConfig,
} from './types';
export {
  PostHogError,
  PostHogConnectionError,
  PostHogQueryError,
  PostHogRateLimitError,
} from './types';
</file>

<file path="src/infra/external/posthog/types.ts">
/**
 * PostHog Types
 * 
 * Type definitions for PostHog analytics integration
 */

// PostHog query response types
export interface PostHogEvent {
  event: string;
  properties: Record<string, unknown>;
  timestamp: string;
  distinct_id: string;
}

export interface PostHogQueryResponse {
  results: Record<string, unknown>[];
  hasMore: boolean;
  next?: string;
}

// PostHog configuration
export interface PostHogConfig {
  apiKey: string;
  host: string;
  timeout?: number;
  retries?: number;
}

// Re-export shared types for convenience
export type { VariantMetrics, ExperimentStatus } from '../../../shared/types';

// PostHog query parameters
export interface PostHogQueryParams {
  projectId: string;
  experimentId: string;
  startDate: string;
  endDate: string;
  primaryKPI: string;
  guardrails?: string[];
}

// PostHog error types
export class PostHogError extends Error {
  constructor(
    public statusCode: number,
    public errorCode: string,
    message: string,
    public details?: unknown
  ) {
    super(message);
    this.name = 'PostHogError';
  }
}

export class PostHogConnectionError extends PostHogError {
  constructor(details?: unknown) {
    super(503, 'POSTHOG_CONNECTION_ERROR', 'Failed to connect to PostHog', details);
  }
}

export class PostHogQueryError extends PostHogError {
  constructor(message: string, details?: unknown) {
    super(400, 'POSTHOG_QUERY_ERROR', message, details);
  }
}

export class PostHogRateLimitError extends PostHogError {
  constructor(retryAfter?: number, details?: unknown) {
    const errorDetails = details && typeof details === 'object' ? { retryAfter, ...details } : { retryAfter, details };
    super(429, 'POSTHOG_RATE_LIMIT_ERROR', 'PostHog rate limit exceeded', errorDetails);
  }
}
</file>

<file path="src/infra/external/shopify/index.ts">
/**
 * Shopify external service module
 * Exports all Shopify-related functionality
 */

export { shopifyConfig } from './config';
export { shopify, type ShopifyShop, type ShopifyOAuthResponse } from './service';
export { shopifyOAuth } from './oauth';
</file>

<file path="src/infra/errors.ts">
import type { FastifyReply } from 'fastify/types/reply.js';
import { JsonWebTokenError, TokenExpiredError as JWTTokenExpiredError, NotBeforeError } from 'jsonwebtoken';

export class AuthError extends Error {
  constructor(
    public statusCode: number,
    public errorCode: string,
    message: string,
    public details?: unknown
  ) {
    super(message);
    this.name = 'AuthError';
  }
}

export class UnauthorizedError extends AuthError {
  constructor(message: string = 'Authentication required', details?: unknown) {
    super(401, 'UNAUTHORIZED', message, details);
  }
}

export class ForbiddenError extends AuthError {
  constructor(message: string = 'Access denied', details?: unknown) {
    super(403, 'FORBIDDEN', message, details);
  }
}

export class TokenExpiredError extends UnauthorizedError {
  constructor() {
    super('Token has expired. Please refresh your authentication.');
  }
}

export class InvalidTokenError extends UnauthorizedError {
  constructor() {
    super('Invalid token. Please authenticate again.');
  }
}

export class MissingTokenError extends UnauthorizedError {
  constructor() {
    super('No authentication token provided.');
  }
}

export class ProjectNotBoundError extends ForbiddenError {
  constructor() {
    super('No project bound to user. Please connect a project first.');
  }
}

export class ProjectOwnershipError extends ForbiddenError {
  constructor(projectId?: string) {
    super(
      projectId 
        ? `Access denied. You do not own project ${projectId}.`
        : 'Access denied. You do not own this project.'
    );
  }
}

// Cloudflare KV specific errors
export class CloudflareKVError extends Error {
  constructor(
    public statusCode: number,
    public errorCode: string,
    message: string,
    public details?: unknown
  ) {
    super(message);
    this.name = 'CloudflareKVError';
  }
}

export class KVValueWriteFailedError extends CloudflareKVError {
  constructor(experimentId: string, details?: unknown) {
    super(500, 'KV_VALUE_WRITE_FAILED', `Failed to write experiment ${experimentId} to KV store`, details);
  }
}

export class KVIndexWriteFailedError extends CloudflareKVError {
  constructor(experimentId: string, details?: unknown) {
    super(500, 'KV_INDEX_WRITE_FAILED', `Failed to update CONFIG_INDEX for experiment ${experimentId}`, details);
  }
}

export class KVConnectionError extends CloudflareKVError {
  constructor(details?: unknown) {
    super(503, 'KV_CONNECTION_ERROR', 'Failed to connect to Cloudflare KV', details);
  }
}

export class KVRateLimitError extends CloudflareKVError {
  constructor(retryAfter?: number, details?: unknown) {
    const errorDetails = details && typeof details === 'object' ? { retryAfter, ...details } : { retryAfter, details };
    super(429, 'KV_RATE_LIMIT_ERROR', 'Cloudflare KV rate limit exceeded', errorDetails);
  }
}

// PostHog specific errors
export class PostHogError extends Error {
  constructor(
    public statusCode: number,
    public errorCode: string,
    message: string,
    public details?: unknown
  ) {
    super(message);
    this.name = 'PostHogError';
  }
}

export class PostHogConnectionError extends PostHogError {
  constructor(details?: unknown) {
    super(503, 'POSTHOG_CONNECTION_ERROR', 'Failed to connect to PostHog', details);
  }
}

export class PostHogQueryError extends PostHogError {
  constructor(message: string, details?: unknown) {
    super(400, 'POSTHOG_QUERY_ERROR', message, details);
  }
}

export class PostHogRateLimitError extends PostHogError {
  constructor(retryAfter?: number, details?: unknown) {
    const errorDetails = details && typeof details === 'object' ? { retryAfter, ...details } : { retryAfter, details };
    super(429, 'POSTHOG_RATE_LIMIT_ERROR', 'PostHog rate limit exceeded', errorDetails);
  }
}

/**
 * Error handler for authentication and authorization errors
 */
export const handleAuthError = (error: unknown, reply: FastifyReply) => {
  if (error instanceof AuthError) {
    const response: Record<string, unknown> = {
      error: error.errorCode,
      message: error.message,
    };
    
    if (error.details && typeof error.details === 'object' && error.details !== null) {
      response.details = error.details;
    }
    
    return reply.status(error.statusCode).send(response);
  }

  // Handle JWT-specific errors using built-in classes
  if (error instanceof JWTTokenExpiredError) {
    return reply.status(401).send({
      error: 'UNAUTHORIZED',
      message: 'Token has expired. Please refresh your authentication.',
      details: {
        expiredAt: error.expiredAt,
      },
    });
  }

  if (error instanceof NotBeforeError) {
    return reply.status(401).send({
      error: 'UNAUTHORIZED',
      message: 'Token is not yet valid.',
      details: {
        notBefore: error.date,
      },
    });
  }

  if (error instanceof JsonWebTokenError) {
    return reply.status(401).send({
      error: 'UNAUTHORIZED',
      message: 'Invalid token. Please authenticate again.',
      details: {
        reason: error.message,
      },
    });
  }

  // Handle JWKS errors
  if (error && typeof error === 'object' && 'message' in error && typeof error.message === 'string' && error.message.includes('JWKS')) {
    return reply.status(500).send({
      error: 'INTERNAL_ERROR',
      message: 'Authentication service temporarily unavailable.',
    });
  }

  // Generic error fallback
  return reply.status(500).send({
    error: 'INTERNAL_ERROR',
    message: 'An unexpected error occurred.',
  });
};
</file>

<file path="src/interfaces/http/auth/index.ts">
import type { FastifyInstance } from 'fastify/types/instance.js';
import '@shared/fastify.d';
import { auth } from '@infra/auth';
import { betterAuthMiddleware } from '@interfaces/http/middleware/better-auth';

export async function authRoutes(fastify: FastifyInstance) {
  // Register Better Auth API routes
  fastify.all('/auth/*', async (request, reply) => {
    try {
      // Convert Fastify request to a format Better Auth expects
      const url = new URL(request.url, `http://${request.headers.host}`);
      const headers = new Headers();

      // Copy headers from Fastify request
      Object.entries(request.headers).forEach(([key, value]) => {
        if (value) {
          headers.set(key, Array.isArray(value) ? value.join(', ') : value);
        }
      });

      const betterAuthRequest = new Request(url.toString(), {
        method: request.method,
        headers,
        body: request.method !== 'GET' && request.method !== 'HEAD' ? JSON.stringify(request.body) : undefined,
      });

      const response = await auth.handler(betterAuthRequest);

      // Convert Response back to Fastify reply
      const responseBody = await response.text();
      reply.status(response.status);

      // Copy headers from response (including cookies)
      response.headers.forEach((value, key) => {
        reply.header(key, value);
      });

      return reply.send(responseBody);
    } catch (error: unknown) {
      fastify.log.error({ err: error }, 'Better Auth handler error:');
      return reply.status(500).send({
        error: 'INTERNAL_ERROR',
        message: 'Authentication service error',
      });
    }
  });

  // Get current session using Better Auth with enhanced project data
  fastify.get('/auth/get-session', async (request, reply) => {
    try {
      const headers = new Headers();

      // Copy headers from Fastify request
      Object.entries(request.headers).forEach(([key, value]) => {
        if (value) {
          headers.set(key, Array.isArray(value) ? value.join(', ') : value);
        }
      });

      const sessionData = await auth.api.getSession({
        headers,
      });

      if (!sessionData || !sessionData.session || !sessionData.user) {
        return reply.status(401).send({
          error: 'UNAUTHORIZED',
          message: 'No active session',
        });
      }

      // Get user with project data from our database
      const { userService } = await import('@infra/dal/user');
      const user = await userService.getUserById(sessionData.user.id);

      if (!user) {
        return reply.status(404).send({
          error: 'NOT_FOUND',
          message: 'User not found',
        });
      }

      // Return enhanced session data with project information
      return reply.send({
        session: sessionData.session,
        user: {
          id: user.id,
          email: user.email,
          name: user.name,
          emailVerified: user.emailVerified,
          project: user.project ? {
            id: user.project.id,
            shopDomain: user.project.shopDomain,
            brandAnalysis: user.project.brandAnalysis,
          } : null,
        },
      });
    } catch (error: unknown) {
      fastify.log.error({ err: error }, 'Get session error:');
      return reply.status(500).send({
        error: 'INTERNAL_ERROR',
        message: 'Failed to fetch session information',
      });
    }
  });

  // Get current session with user details (protected)
  fastify.get('/session', { preHandler: [betterAuthMiddleware] }, async (request, reply) => {
    try {
      const { userService } = await import('@infra/dal/user');
      const user = await userService.getUserById(request.userId!);

      if (!user) {
        return reply.status(404).send({
          error: 'NOT_FOUND',
          message: 'User not found',
        });
      }

      return {
        user: {
          id: user.id,
          email: user.email,
          name: user.name,
          emailVerified: user.emailVerified,
          project: user.project ? {
            id: user.project.id,
            shopDomain: user.project.shopDomain,
            brandAnalysis: user.project.brandAnalysis,
          } : null,
        },
      };
    } catch (error: unknown) {
      fastify.log.error({ err: error }, 'Get session error:');
      return reply.status(500).send({
        error: 'INTERNAL_ERROR',
        message: 'Failed to fetch session information',
      });
    }
  });

  // Sign out (protected)
  fastify.post('/signout', { preHandler: [betterAuthMiddleware] }, async (request, reply) => {
    try {
      const authHeader = request.headers.authorization;
      if (authHeader && authHeader.startsWith('Bearer ')) {
        const fetchHeaders = new Headers(request.headers as HeadersInit);

        await auth.api.signOut({
          headers: fetchHeaders,
        });
      }

      return {
        message: 'Signed out successfully',
      };
    } catch (error: unknown) {
      fastify.log.error({ err: error }, 'Sign out error:');
      return reply.status(500).send({
        error: 'INTERNAL_ERROR',
        message: 'Failed to sign out',
      });
    }
  });

  // Universal registration route for both Shopify and non-Shopify stores
  fastify.post('/auth/register', async (request, reply) => {
    try {
      const { email, password, name, websiteUrl, isShopify = false } = request.body as {
        email: string;
        password: string;
        name: string;
        websiteUrl: string;
        isShopify?: boolean;
      };

      // Validate website URL based on store type
      if (isShopify && !websiteUrl.endsWith('.myshopify.com')) {
        return reply.status(400).send({
          error: 'BAD_REQUEST',
          message: 'Invalid Shopify domain format. Must end with .myshopify.com',
        });
      }

      // Check if user already exists
      const { userService } = await import('@infra/dal/user');
      const existingUser = await userService.getUserByBetterAuthId(email);
      if (existingUser) {
        return reply.status(409).send({
          error: 'CONFLICT',
          message: 'User with this email already exists',
        });
      }

      // Step 1: Create user with Better Auth using the handler to get proper cookies
      const url = new URL('/api/auth/sign-up/email', `http://${request.headers.host}`);
      const headers = new Headers();

      // Copy headers from Fastify request
      Object.entries(request.headers).forEach(([key, value]) => {
        if (value) {
          headers.set(key, Array.isArray(value) ? value.join(', ') : value);
        }
      });

      const betterAuthRequest = new Request(url.toString(), {
        method: 'POST',
        headers,
        body: JSON.stringify({ email, password, name }),
      });

      const betterAuthResponse = await auth.handler(betterAuthRequest);
      const responseBody = await betterAuthResponse.text();

      if (!betterAuthResponse.ok) {
        return reply.status(betterAuthResponse.status).send(responseBody);
      }

      const signUpData = JSON.parse(responseBody);

      // Step 2: Create user in our database
      await userService.getOrCreateUser(
        signUpData.user.id,
        email,
        name
      );

      // Step 3: Handle based on store type
      if (isShopify) {
        // Generate Shopify OAuth URL for Shopify stores
        const { shopifyOAuth } = await import('@infra/external/shopify');
        const { oauthUrl, state } = shopifyOAuth.generateRegistrationOAuthUrl(websiteUrl, email);

        // Copy cookies from Better Auth response
        betterAuthResponse.headers.forEach((value, key) => {
          if (key.toLowerCase().includes('cookie') || key.toLowerCase().includes('set-')) {
            reply.header(key, value);
          }
        });

        return {
          message: 'User created successfully, proceed to Shopify OAuth',
          session: signUpData.session,
          user: signUpData.user,
          oauthUrl,
          state,
          websiteUrl,
          isShopify: true,
        };
      } else {
        // For non-Shopify stores, create project directly
        await userService.createProjectForUser(
          signUpData.user.id,
          websiteUrl,
          false // isShopify = false
        );

        // Copy cookies from Better Auth response
        betterAuthResponse.headers.forEach((value, key) => {
          if (key.toLowerCase().includes('cookie') || key.toLowerCase().includes('set-')) {
            reply.header(key, value);
          }
        });

        return {
          message: 'User and project created successfully',
          session: signUpData.session,
          user: signUpData.user,
          websiteUrl,
          isShopify: false,
        };
      }

    } catch (error: unknown) {
      fastify.log.error({ err: error }, 'Registration with Shopify error:');
      return reply.status(500).send({
        error: 'INTERNAL_ERROR',
        message: 'Failed to complete registration',
      });
    }
  });

  // Handle Shopify OAuth callback for Better Auth registration
  fastify.get('/auth/shopify/register-callback', async (request, reply) => {
    try {
      // Validate OAuth callback parameters
      const { shopify } = await import('@infra/external/shopify');
      const validation = shopify.validateCallbackParams(request.query as Record<string, string>);

      if (!validation.isValid) {
        return reply.status(400).send({
          error: 'BAD_REQUEST',
          message: validation.error,
        });
      }

      const { code, shop, hmac, state } = validation.params!;

      // Handle OAuth callback for registration
      const { shopifyOAuth } = await import('@infra/external/shopify');
      const { shopProfile, email, encryptedToken } = await shopifyOAuth.handleRegistrationCallback(
        code, shop, hmac, state
      );

      // Find the user by email and complete the registration
      const { userService } = await import('@infra/dal/user');
      const user = await userService.getUserByEmail(email);

      if (!user) {
        return reply.status(404).send({
          error: 'NOT_FOUND',
          message: 'User not found. Please try registration again.',
        });
      }

      // Create project and bind to user
      await userService.bindProjectToUser(
        user.id,
        shopProfile.myshopify_domain,
        encryptedToken
      );

      // Redirect to frontend with success
      const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:3000';
      const successUrl = `${frontendUrl}`;

      return reply.redirect(successUrl);

    } catch (error: unknown) {
      fastify.log.error({ err: error }, 'Better Auth Shopify registration callback error:');

      // Redirect to frontend with error
      const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:3000';
      const errorUrl = `${frontendUrl}/register?error=shopify_connection_failed`;

      return reply.redirect(errorUrl);
    }
  });
}
</file>

<file path="src/interfaces/http/project/jobs.ts">
import { FastifyInstance } from 'fastify';
import { VariantJobDAL } from '@infra/dal';
import { betterAuthMiddleware } from '../middleware/better-auth';
import { requireProject, requireProjectOwnership } from '../middleware/authorization';

export async function jobRoutes(fastify: FastifyInstance) {
    // Get job status by ID
    fastify.get('/project/:projectId/jobs/:jobId', { 
        preHandler: [betterAuthMiddleware, requireProject, requireProjectOwnership] 
    }, async (request, reply) => {
        try {
            const { projectId, jobId } = request.params as { projectId: string; jobId: string };

            // Get the job
            const job = await VariantJobDAL.getJobById(jobId);
            if (!job) {
                return reply.status(404).send({ 
                    error: 'Job not found',
                    message: `Job with ID ${jobId} not found`
                });
            }

            // Verify the job belongs to the project
            if (job.projectId !== projectId) {
                return reply.status(403).send({ 
                    error: 'Forbidden',
                    message: 'Job does not belong to this project'
                });
            }

            // Return job status
            return {
                jobId: job.id,
                status: job.status.toLowerCase(),
                result: job.result,
                error: job.error,
                progress: job.progress,
                createdAt: job.createdAt,
                startedAt: job.startedAt,
                completedAt: job.completedAt,
            };

        } catch (error) {
            fastify.log.error({ err: error, jobId: (request.params as any).jobId }, 'Get job status error:');
            return reply.status(500).send({ 
                error: 'Internal server error',
                message: 'Failed to get job status'
            });
        }
    });

    // Get all jobs for a project
    fastify.get('/project/:projectId/jobs', { 
        preHandler: [betterAuthMiddleware, requireProject, requireProjectOwnership] 
    }, async (request, reply) => {
        try {
            const { projectId } = request.params as { projectId: string };
            const { limit = 50, offset = 0 } = request.query as { limit?: number; offset?: number };

            const jobs = await VariantJobDAL.getJobsByProject(projectId, limit, offset);

            return {
                jobs: jobs.map(job => ({
                    jobId: job.id,
                    status: job.status.toLowerCase(),
                    progress: job.progress,
                    createdAt: job.createdAt,
                    startedAt: job.startedAt,
                    completedAt: job.completedAt,
                })),
                total: jobs.length,
            };

        } catch (error) {
            fastify.log.error({ err: error, projectId: (request.params as any).projectId }, 'Get project jobs error:');
            return reply.status(500).send({ 
                error: 'Internal server error',
                message: 'Failed to get project jobs'
            });
        }
    });
}
</file>

<file path="src/interfaces/http/project/reset.ts">
import { FastifyInstance } from 'fastify';
import { ProjectDAL } from '@infra/dal';
import { betterAuthMiddleware } from '../middleware/better-auth';
import { requireProject, requireProjectOwnership } from '../middleware/authorization';
import { prisma } from '@infra/prisma';
import { createCloudflarePublisher } from '@infra/external/cloudflare/cloudflare-publisher';
import { createExperimentPublisherService } from '@services/experiment-publisher';
import { getServiceConfig } from '@infra/config/services';

export async function projectResetRoutes(fastify: FastifyInstance) {
    // Reset project: clear brand analysis, delete all experiments, unpublish from Cloudflare, and remove all related data
    fastify.post('/project/:projectId/reset', { 
        preHandler: [betterAuthMiddleware, requireProject, requireProjectOwnership]
    }, async (request, reply) => {
        try {
            const { projectId } = request.params as { projectId: string };

            // Verify project exists and user owns it (already verified by requireProjectOwnership middleware)
            const project = await ProjectDAL.getProjectById(projectId);
            if (!project) {
                return reply.status(404).send({ 
                    error: 'Project not found',
                    message: `Project with ID ${projectId} not found`
                });
            }

            // Get all experiments for this project before deletion
            const experiments = await prisma.experiment.findMany({
                where: { projectId },
                select: { id: true, status: true }
            });

            // Unpublish all running experiments from Cloudflare
            const cloudflareUnpublishResults: Array<{
                experimentId: string;
                success: boolean;
                error?: string;
            }> = [];
            if (experiments.length > 0) {
                try {
                    const config = getServiceConfig();
                    const cloudflarePublisher = createCloudflarePublisher(config.cloudflare);
                    const experimentPublisher = createExperimentPublisherService(cloudflarePublisher);

                    for (const experiment of experiments) {
                        if (experiment.status === 'RUNNING') {
                            fastify.log.info({ experimentId: experiment.id }, 'Unpublishing experiment from Cloudflare');
                            const result = await experimentPublisher.unpublishExperiment(experiment.id);
                            cloudflareUnpublishResults.push({
                                experimentId: experiment.id,
                                success: result.success,
                                error: result.error
                            });
                        }
                    }
                } catch (error) {
                    fastify.log.error({ err: error }, 'Error unpublishing experiments from Cloudflare');
                    // Continue with database cleanup even if Cloudflare unpublish fails
                }
            }

            // Start a transaction to ensure atomicity
            await prisma.$transaction(async (tx) => {
                // 1. Clear brand analysis by setting it to null
                await tx.project.update({
                    where: { id: projectId },
                    data: { brandAnalysis: null as any }
                });

                // 2. Delete all experiments for this project (cascades to related tables)
                const deletedExperiments = await tx.experiment.deleteMany({
                    where: { projectId }
                });

                // 3. Delete all screenshots for this project
                const deletedScreenshots = await tx.screenshot.deleteMany({
                    where: { projectId }
                });

                // 4. Delete all variant jobs for this project
                const deletedVariantJobs = await tx.variantJob.deleteMany({
                    where: { projectId }
                });

                // 5. Delete all chat messages for this project
                const deletedChatMessages = await tx.chatMessage.deleteMany({
                    where: { projectId }
                });

                // 6. Delete all brand summary jobs for this project
                const deletedBrandSummaryJobs = await tx.brandSummaryJob.deleteMany({
                    where: { projectId }
                });

                fastify.log.info({ 
                    projectId, 
                    deletedExperiments: deletedExperiments.count,
                    deletedScreenshots: deletedScreenshots.count,
                    deletedVariantJobs: deletedVariantJobs.count,
                    deletedChatMessages: deletedChatMessages.count,
                    deletedBrandSummaryJobs: deletedBrandSummaryJobs.count,
                    cloudflareUnpublishResults
                }, 'Project reset completed');
            });

            return reply.status(200).send({
                success: true,
                message: 'Project reset successfully',
                projectId,
                resetData: {
                    brandAnalysis: 'cleared',
                    experiments: 'deleted',
                    screenshots: 'removed',
                    variantJobs: 'deleted',
                    chatMessages: 'deleted',
                    brandSummaryJobs: 'deleted',
                    cloudflareUnpublishResults
                }
            });

        } catch (error) {
            fastify.log.error({ 
                err: error, 
                projectId: (request.params as any).projectId 
            }, 'Project reset error:');
            
            return reply.status(500).send({ 
                error: 'Internal server error',
                message: 'Failed to reset project'
            });
        }
    });

    // Get project reset status (optional - shows what would be reset)
    fastify.get('/project/:projectId/reset/status', { 
        preHandler: [betterAuthMiddleware, requireProject, requireProjectOwnership] 
    }, async (request, reply) => {
        try {
            const { projectId } = request.params as { projectId: string };

            // Get project info
            const project = await ProjectDAL.getProjectById(projectId);
            if (!project) {
                return reply.status(404).send({ 
                    error: 'Project not found',
                    message: `Project with ID ${projectId} not found`
                });
            }

            // Count various data types
            const [screenshotCount, experimentCount, variantJobCount, chatMessageCount, brandSummaryJobCount] = await Promise.all([
                prisma.screenshot.count({ where: { projectId } }),
                prisma.experiment.count({ where: { projectId } }),
                prisma.variantJob.count({ where: { projectId } }),
                prisma.chatMessage.count({ where: { projectId } }),
                prisma.brandSummaryJob.count({ where: { projectId } })
            ]);

            // Get running experiments count
            const runningExperimentCount = await prisma.experiment.count({
                where: { 
                    projectId,
                    status: 'RUNNING'
                }
            });

            // Check if brand analysis exists
            const hasBrandAnalysis = project.brandAnalysis !== null;

            return reply.status(200).send({
                projectId,
                resetStatus: {
                    hasBrandAnalysis,
                    screenshotCount,
                    experimentCount,
                    runningExperimentCount,
                    variantJobCount,
                    chatMessageCount,
                    brandSummaryJobCount,
                    canReset: hasBrandAnalysis || screenshotCount > 0 || experimentCount > 0 || variantJobCount > 0 || chatMessageCount > 0 || brandSummaryJobCount > 0
                }
            });

        } catch (error) {
            fastify.log.error({ 
                err: error, 
                projectId: (request.params as any).projectId 
            }, 'Get reset status error:');
            
            return reply.status(500).send({ 
                error: 'Internal server error',
                message: 'Failed to get reset status'
            });
        }
    });
}
</file>

<file path="src/services/screenshot-analytics.ts">
// Screenshot Analytics Service - Refactored to use ScreenshotDAL
import { ScreenshotDAL } from '@infra/dal/screenshot';

export interface ScreenshotAnalyticsService {
  getProjectScreenshotStats(projectId: string): Promise<{
    totalScreenshots: number;
    totalSize: number;
    cacheHitRate: number;
    screenshotsByType: Record<string, number>;
    averageSize: number;
    lastAccessed: Date | null;
  }>;

  getGlobalScreenshotStats(): Promise<{
    totalScreenshots: number;
    totalSize: number;
    totalProjects: number;
    averageScreenshotsPerProject: number;
    cacheHitRate: number;
  }>;

  getScreenshotUsageTrends(projectId: string, days: number): Promise<{
    date: string;
    screenshots: number;
    cacheHits: number;
    cacheMisses: number;
  }[]>;

  getTopCachedUrls(projectId: string, limit: number): Promise<{
    url: string;
    pageType: string;
    accessCount: number;
    lastAccessed: Date;
    fileSize: number;
  }[]>;
}

export class ScreenshotAnalyticsServiceImpl implements ScreenshotAnalyticsService {
  async getProjectScreenshotStats(projectId: string): Promise<{
    totalScreenshots: number;
    totalSize: number;
    cacheHitRate: number;
    screenshotsByType: Record<string, number>;
    averageSize: number;
    lastAccessed: Date | null;
  }> {
    try {
      return await ScreenshotDAL.getDetailedProjectStats(projectId);
    } catch (error) {
      console.error('[SCREENSHOT_ANALYTICS] Error getting project stats:', error);
      return {
        totalScreenshots: 0,
        totalSize: 0,
        cacheHitRate: 0,
        screenshotsByType: {},
        averageSize: 0,
        lastAccessed: null
      };
    }
  }

  async getGlobalScreenshotStats(): Promise<{
    totalScreenshots: number;
    totalSize: number;
    totalProjects: number;
    averageScreenshotsPerProject: number;
    cacheHitRate: number;
  }> {
    try {
      return await ScreenshotDAL.getGlobalStats();
    } catch (error) {
      console.error('[SCREENSHOT_ANALYTICS] Error getting global stats:', error);
      return {
        totalScreenshots: 0,
        totalSize: 0,
        totalProjects: 0,
        averageScreenshotsPerProject: 0,
        cacheHitRate: 0
      };
    }
  }

  async getScreenshotUsageTrends(projectId: string, days: number): Promise<{
    date: string;
    screenshots: number;
    cacheHits: number;
    cacheMisses: number;
  }[]> {
    try {
      return await ScreenshotDAL.getUsageTrends(projectId, days);
    } catch (error) {
      console.error('[SCREENSHOT_ANALYTICS] Error getting usage trends:', error);
      return [];
    }
  }

  async getTopCachedUrls(projectId: string, limit: number): Promise<{
    url: string;
    pageType: string;
    accessCount: number;
    lastAccessed: Date;
    fileSize: number;
  }[]> {
    try {
      return await ScreenshotDAL.getTopCachedUrls(projectId, limit);
    } catch (error) {
      console.error('[SCREENSHOT_ANALYTICS] Error getting top cached URLs:', error);
      return [];
    }
  }
}

// Simplified factory function - no longer needs prisma parameter
export function createScreenshotAnalyticsService(): ScreenshotAnalyticsService {
  return new ScreenshotAnalyticsServiceImpl();
}
</file>

<file path="src/shared/utils/html-simplifier.ts">
/**
 * HTML Simplification Utility
 * Reduces HTML size by removing unnecessary elements and normalizing content
 */

export function simplifyHTML(html: string): string {
  if (!html || html.length === 0) {
    return '';
  }

  // Process with single-pass operations to minimize memory usage
  return html
    // Remove comments (single pass)
    .replace(/<!--[\s\S]*?-->/g, '')
    // Remove script tags (single pass)
    .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '')
    // Remove style tags (single pass)
    .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '')
    // Remove tracking scripts (single pass)
    .replace(/<script[^>]*src="[^"]*(?:google-analytics|gtag|facebook|twitter|linkedin|pinterest)[^"]*"[^>]*>[\s\S]*?<\/script>/gi, '')
    // Remove meta tags (single pass)
    .replace(/<meta[^>]*(?:property|name)="(?:og:|twitter:|article:|product:)[^"]*"[^>]*>/gi, '')
    // Remove non-essential data attributes but keep important ones for element selection
    .replace(/\sdata-(?!(?:testid|omen-id|id|role|label|name|value|type|state|selected|checked|disabled|hidden|aria-))[^=]*="[^"]*"/gi, '')
    // Remove only style attributes and event handlers, but KEEP class attributes for element selection
    .replace(/\sstyle="[^"]*"/gi, '')
    .replace(/\s(?:onclick|onload|onmouseover|onmouseout|onfocus|onblur|onchange|onsubmit)="[^"]*"/gi, '')
    // Normalize whitespace (single pass)
    .replace(/\s+/g, ' ')
    // Remove empty lines (single pass)
    .replace(/\n\s*\n/g, '\n')
    // Trim final result
    .trim();
}

export function splitIntoChunks(str: string, chunkSize: number): string[] {
  const chunks: string[] = [];
  for (let i = 0; i < str.length; i += chunkSize) {
    chunks.push(str.slice(i, i + chunkSize));
  }
  return chunks;
}

/**
 * HTML Simplification for DOM Forensics
 * Preserves all attributes needed for element selection while removing unnecessary content
 */
export function simplifyHTMLForForensics(html: string): string {
  if (!html || html.length === 0) {
    return '';
  }

  // Process with single-pass operations to minimize memory usage
  return html
    // Remove comments (single pass)
    .replace(/<!--[\s\S]*?-->/g, '')
    // Remove script tags (single pass)
    .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '')
    // Remove style tags (single pass)
    .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '')
    // Remove tracking scripts (single pass)
    .replace(/<script[^>]*src="[^"]*(?:google-analytics|gtag|facebook|twitter|linkedin|pinterest)[^"]*"[^>]*>[\s\S]*?<\/script>/gi, '')
    // Remove meta tags (single pass)
    .replace(/<meta[^>]*(?:property|name)="(?:og:|twitter:|article:|product:)[^"]*"[^>]*>/gi, '')
    // Remove only non-essential data attributes, keep all important ones for element selection
    .replace(/\sdata-(?!(?:testid|omen-id|id|role|label|name|value|type|state|selected|checked|disabled|hidden|aria-|cypress|qa|qa-id|test|automation|e2e))[^=]*="[^"]*"/gi, '')
    // Remove only style attributes (keep all other attributes for element selection)
    .replace(/\sstyle="[^"]*"/gi, '')
    // Remove event handlers (keep all other attributes)
    .replace(/\s(?:onclick|onload|onmouseover|onmouseout|onfocus|onblur|onchange|onsubmit|onkeydown|onkeyup|onkeypress)="[^"]*"/gi, '')
    // Normalize whitespace (single pass)
    .replace(/\s+/g, ' ')
    // Remove empty lines (single pass)
    .replace(/\n\s*\n/g, '\n')
    // Trim final result
    .trim();
}

export function getHtmlInfo(html: string | null | undefined): string {
  if (!html) return 'no HTML';
  const size = html.length;
  const preview = html.substring(0, 50).replace(/\s+/g, ' ').trim();
  return `${size} chars (${preview}${size > 50 ? '...' : ''})`;
}
</file>

<file path="app.json">
{
  "name": "omen-backend",
  "description": "Omen Backend API",
  "repository": "https://github.com/your-username/omen",
  "logo": "",
  "keywords": ["node", "fastify", "typescript", "prisma"],
  "image": "heroku/nodejs",
  "stack": "heroku-22",
  "region": "eu",
  "buildpacks": [
    {
      "url": "https://github.com/heroku/heroku-buildpack-chrome-for-testing"
    },
    {
      "url": "heroku/nodejs"
    }
  ],
  "env": {
    "NODE_ENV": {
      "description": "Environment",
      "value": "production"
    },
    "PORT": {
      "description": "Port for the web server",
      "value": "3000"
    },
    "PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD": {
      "description": "Skip Playwright browser download, use system Chrome",
      "value": "true"
    }
  },
  "formation": {
    "web": {
      "quantity": 1,
      "size": "basic"
    }
  },
  "addons": [
    {
      "plan": "heroku-postgresql:essential-0"
    }
  ]
}
</file>

<file path="src/domain/agent/tools/check-variants.ts">
// @ts-nocheck 
import { tool } from 'ai';
import { z } from 'zod';
import { variantStateManager } from '../variant-state-manager';
import { VariantJobDAL } from '@infra/dal';

const checkVariantsSchema = z.object({
  projectId: z.string().optional().describe('The project ID to check variants for - if not provided, will use the current project')
});

class CheckVariantsExecutor {
  private projectId: string;

  constructor(projectId: string) {
    this.projectId = projectId;
  }

  async execute(input: { projectId?: string }): Promise<{ 
    status: string; 
    message: string; 
    variantsFound: number;
    variants: any[];
    jobsStatus: any;
  }> {
    const projectId = input.projectId || this.projectId;
    
    console.log(`[CHECK_VARIANTS] ===== CHECKING VARIANTS STATUS =====`);
    console.log(`[CHECK_VARIANTS] Project ID: ${projectId}`);
    
    try {
      // Check current state manager status
      const currentVariants = variantStateManager.getCurrentVariants();
      const hasCurrentVariants = variantStateManager.hasCurrentVariants();
      const variantCount = variantStateManager.getCurrentVariantCount();
      
      console.log(`[CHECK_VARIANTS] State manager status:`);
      console.log(`[CHECK_VARIANTS] - Has current variants: ${hasCurrentVariants}`);
      console.log(`[CHECK_VARIANTS] - Current variant count: ${variantCount}`);
      console.log(`[CHECK_VARIANTS] - Current variants: ${currentVariants ? currentVariants.length : 'null'}`);
      
      // Check jobs status
      const jobs = await VariantJobDAL.getJobsByProject(projectId);
      const jobsByStatus = jobs.reduce((acc, job) => {
        acc[job.status] = (acc[job.status] || 0) + 1;
        return acc;
      }, {} as Record<string, number>);
      
      const completedJobs = jobs.filter(job => job.status === 'COMPLETED' && job.result);
      const runningJobs = jobs.filter(job => job.status === 'RUNNING');
      const pendingJobs = jobs.filter(job => job.status === 'PENDING');
      const failedJobs = jobs.filter(job => job.status === 'FAILED');
      
      console.log(`[CHECK_VARIANTS] Jobs status:`);
      console.log(`[CHECK_VARIANTS] - Total jobs: ${jobs.length}`);
      console.log(`[CHECK_VARIANTS] - Completed: ${completedJobs.length}`);
      console.log(`[CHECK_VARIANTS] - Running: ${runningJobs.length}`);
      console.log(`[CHECK_VARIANTS] - Pending: ${pendingJobs.length}`);
      console.log(`[CHECK_VARIANTS] - Failed: ${failedJobs.length}`);
      
      // Try to load variants from completed jobs
      let variantsFound = 0;
      let loadedVariants: any[] = [];
      let message = '';
      
      if (completedJobs.length > 0) {
        console.log(`[CHECK_VARIANTS] Attempting to load variants from completed jobs...`);
        
        // Try to load variants from specific job IDs first (most precise)
        const currentJobIds = variantStateManager.getCurrentJobIds();
        
        if (currentJobIds && currentJobIds.length > 0) {
          console.log(`[CHECK_VARIANTS] Loading variants from specific job IDs:`, currentJobIds);
          loadedVariants = await variantStateManager.loadVariantsFromJobIds(currentJobIds);
        } else {
          console.log(`[CHECK_VARIANTS] No specific job IDs found, loading from all completed jobs`);
          loadedVariants = await variantStateManager.loadVariantsFromJobs(projectId);
        }
        
        variantsFound = loadedVariants.length;
        
        if (variantsFound > 0) {
          message = `Successfully loaded ${variantsFound} variants from completed jobs. Variants are now available in the state manager.`;
          console.log(`[CHECK_VARIANTS] ${message}`);
        } else if (runningJobs.length > 0) {
          message = `Found ${runningJobs.length} running jobs. Variants are still being generated. Please wait for completion.`;
          console.log(`[CHECK_VARIANTS] ${message}`);
        } else {
          message = `Found ${completedJobs.length} completed jobs but no variants could be extracted. This might indicate an issue with the job results.`;
          console.log(`[CHECK_VARIANTS] ${message}`);
        }
      } else if (runningJobs.length > 0 || pendingJobs.length > 0) {
        message = `Found ${runningJobs.length} running and ${pendingJobs.length} pending jobs. Variants are still being processed. Please wait for completion.`;
        console.log(`[CHECK_VARIANTS] ${message}`);
      } else if (failedJobs.length > 0) {
        message = `Found ${failedJobs.length} failed jobs. No variants were generated successfully.`;
        console.log(`[CHECK_VARIANTS] ${message}`);
      } else {
        message = `No variant jobs found for this project. Please generate variants first using the generate_variants tool.`;
        console.log(`[CHECK_VARIANTS] ${message}`);
      }
      
      console.log(`[CHECK_VARIANTS] ======================================`);
      
      return {
        status: variantsFound > 0 ? 'SUCCESS' : 'NO_VARIANTS',
        message,
        variantsFound,
        variants: loadedVariants,
        jobsStatus: {
          total: jobs.length,
          completed: completedJobs.length,
          running: runningJobs.length,
          pending: pendingJobs.length,
          failed: failedJobs.length,
          byStatus: jobsByStatus
        }
      };
    } catch (error) {
      console.error(`[CHECK_VARIANTS] Failed to check variants:`, error);
      return {
        status: 'ERROR',
        message: `Failed to check variants: ${error instanceof Error ? error.message : 'Unknown error'}`,
        variantsFound: 0,
        variants: [],
        jobsStatus: {}
      };
    }
  }
}

export function checkVariants(projectId: string) {
  const executor = new CheckVariantsExecutor(projectId);

  return tool({
    description: 'Check the current status of variant generation jobs and load completed variants into the state manager',
    inputSchema: checkVariantsSchema,
    execute: async (input) => {
      try {
        const result = await executor.execute(input);
        return result;
      } catch (error) {
        console.error(`[CHECK_VARIANTS] Tool execute failed:`, error);
        throw new Error(error instanceof Error ? error.message : 'Failed to check variants');
      }
    },
  });
}
</file>

<file path="src/domain/agent/hypothesis-state-manager.ts">
// Hypothesis State Manager - manages hypothesis state across tool calls
import { Hypothesis } from '@features/hypotheses_generation/types';

class HypothesisStateManager {
  private currentHypothesis: Hypothesis | null = null;
  private hypothesisHistory: Hypothesis[] = [];

  /**
   * Set the current hypothesis (from generate_hypotheses tool)
   */
  setCurrentHypothesis(hypothesis: Hypothesis): void {
    console.log(`[STATE_MANAGER] Setting hypothesis: "${hypothesis.title}"`);
    this.currentHypothesis = hypothesis;
    this.hypothesisHistory.push(hypothesis);
    console.log(`[STATE_MANAGER] Hypothesis set: "${hypothesis.title}"`);
    console.log(`[STATE_MANAGER] Current hypothesis count: ${this.hypothesisHistory.length}`);
  }

  /**
   * Get the current hypothesis (for generate_variants and create_experiment tools)
   */
  getCurrentHypothesis(): Hypothesis | null {
    console.log(`[STATE_MANAGER] Getting current hypothesis: ${this.currentHypothesis ? 'FOUND' : 'NOT FOUND'}`);
    return this.currentHypothesis;
  }

  /**
   * Get the most recent hypothesis from history
   */
  getLatestHypothesis(): Hypothesis | null {
    return this.hypothesisHistory.length > 0 
      ? this.hypothesisHistory[this.hypothesisHistory.length - 1] 
      : null;
  }

  /**
   * Clear the current hypothesis
   */
  clearCurrentHypothesis(): void {
    console.log(`[STATE_MANAGER] Clearing current hypothesis`);
    this.currentHypothesis = null;
  }

  /**
   * Clear all hypothesis history
   */
  clearAll(): void {
    console.log(`[STATE_MANAGER] Clearing all hypothesis data`);
    this.currentHypothesis = null;
    this.hypothesisHistory = [];
  }

  /**
   * Get hypothesis history
   */
  getHistory(): Hypothesis[] {
    return [...this.hypothesisHistory];
  }

  /**
   * Check if there's a current hypothesis
   */
  hasCurrentHypothesis(): boolean {
    return this.currentHypothesis !== null;
  }
}

// Singleton instance
export const hypothesisStateManager = new HypothesisStateManager();

// Export the class for testing
export { HypothesisStateManager };
</file>

<file path="src/domain/agent/index.ts">
// Agent Domain
export * from './types';
export * from './agent';
export * from './tools';
export * from './prompts';
</file>

<file path="src/domain/analytics/analytics-service.ts">
import {
  AnalyticsEventData,
  AnalyticsQuery,
  ExposureStats,
  FunnelAnalysis,
  ConversionRates,
  PurchaseStats,
  SQSAnalyticsMessage
} from './types';

export interface AnalyticsService {
  // Event Management
  createEvent(eventData: Omit<AnalyticsEventData, 'id' | 'createdAt'>): Promise<AnalyticsEventData>;
  createEvents(events: Omit<AnalyticsEventData, 'id' | 'createdAt'>[]): Promise<AnalyticsEventData[]>;
  
  // Query Methods
  getEvents(query: AnalyticsQuery): Promise<AnalyticsEventData[]>;
  getEventsWithAttribution(query: AnalyticsQuery): Promise<AnalyticsEventData[]>;
  getEventCount(query: AnalyticsQuery): Promise<number>;
  
  // Analytics Methods
  getExposureStats(projectId: string, experimentId: string): Promise<ExposureStats[]>;
  getFunnelAnalysis(projectId: string, experimentId: string): Promise<FunnelAnalysis>;
  getConversionRates(projectId: string, experimentId: string): Promise<ConversionRates[]>;
  getPurchaseStats(projectId: string, experimentId: string): Promise<PurchaseStats[]>;
  getUserJourney(projectId: string, sessionId: string): Promise<AnalyticsEventData[]>;
  
  // Session Management
  getExperimentSessions(projectId: string, experimentId: string, limit?: number, offset?: number): Promise<{ sessions: { sessionId: string, eventCount: number }[], total: number }>;
  
  // SQS Integration
  processSQSEvent(message: SQSAnalyticsMessage): Promise<void>;
  processSQSBatch(messages: SQSAnalyticsMessage[]): Promise<void>;
}

export interface SQSConsumerService {
  start(): Promise<void>;
  stop(): Promise<void>;
  isRunning(): boolean;
}

export interface AnalyticsRepository {
  create(eventData: Omit<AnalyticsEventData, 'id' | 'createdAt'>): Promise<AnalyticsEventData>;
  createMany(events: Omit<AnalyticsEventData, 'id' | 'createdAt'>[]): Promise<AnalyticsEventData[]>;
  findMany(query: AnalyticsQuery): Promise<AnalyticsEventData[]>;
  count(query: AnalyticsQuery): Promise<number>;
  getExposureStats(projectId: string, experimentId: string): Promise<ExposureStats[]>;
  getFunnelAnalysis(projectId: string, experimentId: string): Promise<FunnelAnalysis>;
  getConversionRates(projectId: string, experimentId: string): Promise<ConversionRates[]>;
  getPurchaseStats(projectId: string, experimentId: string): Promise<PurchaseStats[]>;
  getUserJourney(projectId: string, sessionId: string): Promise<AnalyticsEventData[]>;
  getEventsWithAttribution(query: AnalyticsQuery): Promise<AnalyticsEventData[]>;
  getExperimentSessions(projectId: string, experimentId: string, limit?: number, offset?: number): Promise<{ sessions: { sessionId: string, eventCount: number }[], total: number }>;
}
</file>

<file path="src/domain/analytics/index.ts">
export * from './types';
export * from './analytics-service';
</file>

<file path="src/domain/analytics/types.ts">
// Analytics Event Types - matches Prisma EventType enum
export type AnalyticsEventType =
  | 'EXPOSURE'
  | 'PAGEVIEW'
  | 'CONVERSION'
  | 'PURCHASE'
  | 'CUSTOM';

export interface AnalyticsEventData {
  id: string;
  projectId: string;
  experimentId?: string;
  eventType: AnalyticsEventType;
  sessionId: string;
  viewId?: string;
  properties: Record<string, any>; // Flexible properties for any event type
  timestamp: number;
  createdAt: Date;
}

// Event Properties Interfaces
export interface ExposureEventProperties {
  expId: string;
  variantKey: string;
  userKey: string;
  device?: 'desktop' | 'mobile' | 'tablet';
}

export interface PageviewEventProperties {
  url: string;
  title?: string;
  referrer?: string;
  viewport?: {
    width: number;
    height: number;
  };
  device?: 'desktop' | 'mobile' | 'tablet';
}

export interface ConversionEventProperties {
  goal: string;
  value?: number;
  properties?: Record<string, any>;
  device?: 'desktop' | 'mobile' | 'tablet';
}

export interface PurchaseEventProperties {
  orderId: string;
  revenue: number;
  currency: string;
  items?: Array<{
    productId: string;
    name: string;
    price: number;
    quantity: number;
  }>;
  device?: 'desktop' | 'mobile' | 'tablet';
}

export interface CustomEventProperties {
  eventName: string;
  properties?: Record<string, any>;
  device?: 'desktop' | 'mobile' | 'tablet';
}

// Analytics Query Types
export interface AnalyticsQuery {
  projectId: string;
  experimentId?: string;
  startDate?: Date;
  endDate?: Date;
  sessionId?: string;
  limit?: number;
  offset?: number;
}

export interface ExposureStats {
  experimentId: string;
  variantId: string;
  exposures: number;
  uniqueSessions: number;
}

export interface FunnelStep {
  stepName: string;
  eventType: string;
  count: number;
  percentage: number;
  dropoffRate: number;
}

export interface FunnelAnalysis {
  experimentId: string;
  variants: {
    variantId: string;
    steps: FunnelStep[];
    totalSessions: number;
    conversionRate: number;
  }[];
  overallStats: {
    totalSessions: number;
    totalExposures: number;
    totalConversions: number;
    overallConversionRate: number;
  };
}

export interface ConversionRates {
  experimentId: string;
  variantId: string;
  sessions: number;
  conversions: number;
  conversionRate: number;
  averageValue?: number;
  totalValue?: number;
}

export interface PurchaseStats {
  experimentId: string;
  variantId: string;
  sessions: number;
  purchases: number;
  purchaseRate: number;
  totalRevenue: number;
  averageOrderValue: number;
  revenuePerSession: number;
}

// SQS Message Types
export interface SQSAnalyticsMessage {
  projectId: string;
  experimentId?: string;
  eventType: AnalyticsEventType;
  sessionId: string;
  viewId?: string;
  properties: Record<string, any>; // Flexible properties for any event type
  timestamp: number;
}

export interface SQSMessage {
  MessageId: string;
  ReceiptHandle: string;
  Body: string;
  Attributes: Record<string, string>;
  MessageAttributes: Record<string, any>;
}
</file>

<file path="src/features/brand_analysis/types.ts">
// Brand Analysis Types
import { z } from 'zod';

// Brand intelligence schema
export const brandIntelligenceSchema = z.object({
  brand_description: z.string(),
  brand_personality_words: z.array(z.string()).length(4),
  brand_trait_scores: z.object({
    premium: z.object({
      score: z.number().min(1).max(100),
      explanation: z.string()
    }),
    energetic: z.object({
      score: z.number().min(1).max(100),
      explanation: z.string()
    }),
    innovator: z.object({
      score: z.number().min(1).max(100),
      explanation: z.string()
    }),
    social_proof: z.object({
      score: z.number().min(1).max(100),
      explanation: z.string()
    }),
    curated: z.object({
      score: z.number().min(1).max(100),
      explanation: z.string()
    }),
    serious: z.object({
      score: z.number().min(1).max(100),
      explanation: z.string()
    })
  }),
  brand_colors: z.array(z.object({
    color: z.string(),
    description: z.string(),
    usage_type: z.enum(['primary', 'secondary', 'tertiary', 'accent']),
    hex_code: z.string()
  })).min(3).max(4)
});

export type BrandIntelligenceData = z.infer<typeof brandIntelligenceSchema>;

// Synthesis schema for combining multiple page analyses
export const synthesisSchema = z.object({
  brand_description: z.string(),
  brand_personality_words: z.array(z.string()).length(4),
  brand_trait_scores: z.object({
    premium: z.object({
      score: z.number().min(1).max(100),
      explanation: z.string()
    }),
    energetic: z.object({
      score: z.number().min(1).max(100),
      explanation: z.string()
    }),
    innovator: z.object({
      score: z.number().min(1).max(100),
      explanation: z.string()
    }),
    social_proof: z.object({
      score: z.number().min(1).max(100),
      explanation: z.string()
    }),
    curated: z.object({
      score: z.number().min(1).max(100),
      explanation: z.string()
    }),
    serious: z.object({
      score: z.number().min(1).max(100),
      explanation: z.string()
    })
  }),
  brand_colors: z.array(z.object({
    color: z.string(),
    description: z.string(),
    usage_type: z.enum(['primary', 'secondary', 'tertiary', 'accent']),
    hex_code: z.string()
  })).min(3).max(4),
  synthesis_notes: z.string().optional()
});
</file>

<file path="src/features/variant_generation/types.ts">
// Types for variant generation
import { z } from 'zod';

// Simplified variant schema - JavaScript handles everything
export const variantSchema = z.object({
    variant_label: z.string().describe('Unique name for this variant'),
    description: z.string().describe('What this variant does'),
    rationale: z.string().describe('Why this will improve conversions'),
    javascript_code: z.string().describe('JavaScript code that implements the variant'),
    target_selector: z.string().describe('Main CSS selector this variant targets'),
    execution_timing: z.enum(['immediate', 'dom_ready']).default('dom_ready').describe('When to run the JavaScript')
});

// Legacy basic variant schema (for backwards compatibility)
export const basicVariantSchema = z.object({
    variant_label: z.string(),
    description: z.string(),
    rationale: z.string(),
    javascript_code: z.string().optional(),
    target_selector: z.string().optional()
});

export const basicVariantsResponseSchema = z.object({
    variants: basicVariantSchema.array()
});

export const variantsResponseSchema = z.object({
    variants: variantSchema.array()
});

export type BasicVariant = z.infer<typeof basicVariantSchema>;
export type Variant = z.infer<typeof variantSchema>;
export type VariantsResponse = z.infer<typeof variantsResponseSchema>;
</file>

<file path="src/infra/dal/types.ts">
// DAL Types and Interfaces
import type { Project, Experiment, JobStatus } from '@prisma/client';

// Re-export Prisma types for DAL use
export type { Project, Experiment, JobStatus };

export interface CreateExperimentData {
  projectId: string;
  name: string;
  oec: string;
  minDays: number;
  minSessionsPerVariant: number;
  targetUrls?: any; // URL patterns for targeting
  targeting?: any; // Declarative DOM targeting rules
}

export interface UpdateExperimentStatusData {
  experimentId: string;
  status: JobStatus;
  publishedAt?: Date;
  finishedAt?: Date;
}

export interface ProjectWithRelations extends Project {
  experiments: Experiment[];
  chatMessages: any[];
}

export interface ExperimentWithProject extends Experiment {
  project: Project;
}
</file>

<file path="src/infra/external/auth0/auth0.ts">
import { ManagementClient } from 'auth0';

/**
 * Auth0 Management API service
 * Handles only Auth0 operations, not our database
 */
export class Auth0Service {
  private managementClient: ManagementClient;

  constructor() {
    this.managementClient = new ManagementClient({
      domain: process.env.AUTH0_DOMAIN!,
      clientId: process.env.AUTH0_M2M_CLIENT_ID!,
      clientSecret: process.env.AUTH0_M2M_CLIENT_SECRET!,
    });
  }

  /**
   * Create a new user in Auth0
   */
  async createUser(email: string, password?: string): Promise<{ id: string; email: string }> {
    const userData: {
      email: string;
      email_verified: boolean;
      connection: string;
      password?: string;
    } = {
      email,
      email_verified: false,
      connection: 'Username-Password-Authentication',
    };

    if (password) {
      userData.password = password;
    }

    if (email == "lucas@omen.so") {
      // Fetch user from Auth0 and dont create a new user
      const SIMON_AUTH0_ID = "auth0|68cc0ec46a10679b03412c0c";
      const auth0User = await this.managementClient.users.get({ id: SIMON_AUTH0_ID });
      return {
        id: auth0User.data.user_id!,
        email: auth0User.data.email!,
      };
    }

    const auth0User = await this.managementClient.users.create(userData);

    return {
      id: auth0User.data.user_id!,
      email: auth0User.data.email!,
    };
  }

  /**
   * Get user from Auth0 by ID
   */
  async getAuth0UserById(auth0Id: string): Promise<{ id: string; email: string } | null> {
    try {
      const auth0User = await this.managementClient.users.get({ id: auth0Id });

      return {
        id: auth0User.data.user_id!,
        email: auth0User.data.email!,
      };
    } catch {
      return null;
    }
  }

  /**
   * Get user from Auth0 by email
   */
  async getAuth0UserByEmail(email: string): Promise<{ id: string; email: string } | null> {
    try {
      const users = await this.managementClient.users.getAll({
        q: `email:"${email}"`,
        search_engine: 'v3'
      });

      if (users.data.length > 0) {
        const user = users.data[0];
        return {
          id: user.user_id!,
          email: user.email!,
        };
      }

      return null;
    } catch {
      return null;
    }
  }

  /**
   * Update user in Auth0
   */
  async updateAuth0User(auth0Id: string, updates: { email?: string; email_verified?: boolean }): Promise<void> {
    await this.managementClient.users.update({ id: auth0Id }, updates);
  }

  /**
   * Delete user from Auth0
   */
  async deleteAuth0User(auth0Id: string): Promise<void> {
    await this.managementClient.users.delete({ id: auth0Id });
  }
}

export const auth0 = new Auth0Service();
</file>

<file path="src/infra/external/shopify/oauth.ts">
import { shopify } from './service';
import { encrypt } from '../../encryption';
import { setInterval } from 'timers';

/**
 * Shopify OAuth service for handling OAuth flows
 * Includes state management for replay protection
 */
export class ShopifyOAuthService {
  private stateStore = new Map<string, { userId?: string; email?: string; timestamp: number }>();

  constructor() {
    // Clean up expired states every 10 minutes (states expire after 1 hour)
    setInterval(() => {
      const now = Date.now();
      for (const [state, data] of this.stateStore.entries()) {
        if (now - data.timestamp > 60 * 60 * 1000) { // 1 hour
          this.stateStore.delete(state);
        }
      }
    }, 10 * 60 * 1000); // 10 minutes
  }

  /**
   * Store state with user ID (for authenticated flows)
   */
  private setUserState(state: string, userId: string): void {
    this.stateStore.set(state, { userId, timestamp: Date.now() });
  }

  /**
   * Store state with email (for registration flows)
   */
  private setEmailState(state: string, email: string): void {
    this.stateStore.set(state, { email, timestamp: Date.now() });
  }

  /**
   * Get state data
   */
  private getState(state: string): { userId?: string; email?: string; timestamp: number } | undefined {
    return this.stateStore.get(state);
  }

  /**
   * Remove state (one-time use)
   */
  private removeState(state: string): void {
    this.stateStore.delete(state);
  }
  /**
   * Generate OAuth URL for shop connection
   */
  generateOAuthUrl(shop: string, state: string): string {
    return shopify.generateOAuthUrl(shop, state);
  }

  /**
   * Handle OAuth callback for authenticated users
   */
  async handleAuthenticatedCallback(
    code: string,
    shop: string,
    _hmac: string,
    state: string,
    userId: string
  ) {
    // Validate state parameter for replay protection
    const stateData = this.getState(state);
    if (!stateData || stateData.userId !== userId) {
      throw new Error('Invalid or expired state parameter');
    }

    // Remove state after validation (one-time use)
    this.removeState(state);

    // Validate OAuth parameters
    const validation = shopify.validateCallbackParams({ code, shop, hmac: _hmac, state });
    if (!validation.isValid) {
      throw new Error(validation.error);
    }

    // Exchange code for access token
    const tokenResponse = await shopify.exchangeCodeForToken(shop, code);
    
    // Fetch shop profile
    const shopProfile = await shopify.getShopProfile(shop, tokenResponse.access_token);
    
    // Encrypt the access token before storing
    const encryptedToken = encrypt(tokenResponse.access_token);

    return {
      shopProfile,
      encryptedToken,
    };
  }

  /**
   * Handle OAuth callback for registration flow
   */
  async handleRegistrationCallback(
    code: string,
    shop: string,
    _hmac: string,
    state: string
  ) {
    // Validate state parameter for replay protection
    const stateData = this.getState(state);
    if (!stateData?.email) {
      throw new Error('Invalid or expired state parameter');
    }

    // Remove state after validation (one-time use)
    this.removeState(state);

    // OAuth parameters are already validated in the route handler

    // Exchange code for access token
    const tokenResponse = await shopify.exchangeCodeForToken(shop, code);
    
    // Fetch shop profile
    const shopProfile = await shopify.getShopProfile(shop, tokenResponse.access_token);
    
    // Encrypt the access token before storing
    const encryptedToken = encrypt(tokenResponse.access_token);

    return {
      shopProfile,
      encryptedToken,
      email: stateData.email,
    };
  }

  /**
   * Generate state and OAuth URL for authenticated users
   */
  generateAuthenticatedOAuthUrl(shop: string, userId: string): { oauthUrl: string; state: string } {
    const state = this.generateState();
    this.setUserState(state, userId);
    const oauthUrl = this.generateOAuthUrl(shop, state);
    
    return { oauthUrl, state };
  }

  /**
   * Generate state and OAuth URL for registration flow
   */
  generateRegistrationOAuthUrl(shop: string, email: string): { oauthUrl: string; state: string } {
    const state = this.generateState();
    this.setEmailState(state, email);
    const oauthUrl = this.generateOAuthUrl(shop, state);
    
    return { oauthUrl, state };
  }

  private generateState(): string {
    const crypto = require('crypto');
    return crypto.randomBytes(16).toString('hex');
  }
}

export const shopifyOAuth = new ShopifyOAuthService();
</file>

<file path="src/infra/external/shopify/service.ts">
import { shopifyConfig } from './config';
import { decrypt, verifyHmac } from '../../encryption';
import fetch from 'node-fetch';
import { URLSearchParams } from 'url';

/**
 * Shopify service for API calls and shop profile management
 */

export interface ShopifyShop {
  id: number;
  name: string;
  email: string;
  domain: string;
  myshopify_domain: string;
  planName: string;
  currency: string;
  timezone: string;
  country: string;
  createdAt: string;
  updatedAt: string;
}

export interface ShopifyOAuthResponse {
  access_token: string;
  scope: string;
}

export class ShopifyService {
  /**
   * Exchange authorization code for access token
   */
  async exchangeCodeForToken(shop: string, code: string): Promise<ShopifyOAuthResponse> {
    const response = await fetch(`https://${shop}/admin/oauth/access_token`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        client_id: shopifyConfig.apiKey,
        client_secret: shopifyConfig.apiSecret,
        code,
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Failed to exchange code for token: ${response.status} ${errorText}`);
    }

    return response.json() as Promise<ShopifyOAuthResponse>;
  }

  /**
   * Fetch shop profile information
   */
  async getShopProfile(shop: string, accessToken: string): Promise<ShopifyShop> {
    const response = await fetch(`https://${shop}/admin/api/2024-01/shop.json`, {
      headers: {
        'X-Shopify-Access-Token': accessToken,
        'Content-Type': 'application/json',
      },
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Failed to fetch shop profile: ${response.status} ${errorText}`);
    }

    const data = await response.json() as { shop: ShopifyShop };
    return data.shop;
  }

  /**
   * Get shop profile using encrypted token from database
   */
  async getShopProfileWithEncryptedToken(shop: string, encryptedToken: string | null): Promise<ShopifyShop> {
    if (!encryptedToken) {
      throw new Error('Access token is required for Shopify API calls');
    }
    const accessToken = decrypt(encryptedToken);
    return this.getShopProfile(shop, accessToken);
  }

  /**
   * Generate Shopify OAuth URL
   */
  generateOAuthUrl(shop: string, state: string): string {
    const params = new URLSearchParams({
      client_id: shopifyConfig.apiKey,
      scope: "read_themes, write_themes",
      redirect_uri: shopifyConfig.redirectUri,
      state,
    });

    return `https://${shop}/admin/oauth/authorize?${params.toString()}`;
  }

  /**
   * Validate shop domain format
   */
  validateShopDomain(shop: string): boolean {
    // Shopify shop domains should be in format: shop-name.myshopify.com
    const shopifyDomainRegex = /^[a-zA-Z0-9][a-zA-Z0-9-]*\.myshopify\.com$/;
    return shopifyDomainRegex.test(shop);
  }

  /**
   * Normalize shop domain to ensure it has .myshopify.com suffix
   */
  normalizeShopDomain(shop: string): string {
    // If it's just the shop name, add .myshopify.com
    if (!shop.includes('.')) {
      return `${shop}.myshopify.com`;
    }

    // If it already has .myshopify.com, return as is
    if (shop.endsWith('.myshopify.com')) {
      return shop;
    }

    // If it's a custom domain, we can't normalize it
    throw new Error('Invalid shop domain format. Expected format: shop-name or shop-name.myshopify.com');
  }

  /**
   * Verify HMAC signature for OAuth callback
   */
  verifyHmacSignature(queryParams: Record<string, string>, hmac: string): boolean {
    const queryWithoutHmac = { ...queryParams };
    delete queryWithoutHmac.hmac;

    const queryStringWithoutHmac = Object.keys(queryWithoutHmac)
      .sort()
      .map(key => `${key}=${encodeURIComponent(queryWithoutHmac[key])}`)
      .join('&');

    return verifyHmac(queryStringWithoutHmac, shopifyConfig.apiSecret, hmac);
  }

  /**
   * Validate OAuth callback parameters
   */
  validateCallbackParams(query: Record<string, string>): {
    isValid: boolean;
    error?: string;
    params?: {
      code: string;
      shop: string;
      hmac: string;
      state: string;
    };
  } {
    const { code, shop, hmac, state } = query;

    if (!code || !shop || !hmac || !state) {
      return {
        isValid: false,
        error: 'Missing required parameters: code, shop, hmac, state',
      };
    }

    if (!this.validateShopDomain(shop)) {
      return {
        isValid: false,
        error: 'Invalid shop domain format',
      };
    }

    if (!this.verifyHmacSignature(query, hmac)) {
      return {
        isValid: false,
        error: 'Invalid HMAC signature',
      };
    }

    return {
      isValid: true,
      params: { code, shop, hmac, state },
    };
  }
}

export const shopify = new ShopifyService();
</file>

<file path="src/interfaces/http/analytics/handlers.ts">
import { FastifyRequest, FastifyReply } from 'fastify';
import { AnalyticsService } from '@services/analytics';

export function getExposureStatsHandler(analyticsService: AnalyticsService) {
  return async (request: FastifyRequest, reply: FastifyReply) => {
    const { experimentId } = request.params as { experimentId: string };
    const projectId = request.projectId; // From middleware

    if (!projectId) {
      return reply.status(400).send({ 
        error: 'Project ID is required',
        message: 'User must have a project associated with their account to access analytics'
      });
    }

    try {
      const stats = await analyticsService.getExposureStats(projectId, experimentId);
      return reply.send(stats);
    } catch (error) {
      request.log.error(error, 'Failed to get exposure stats');
      return reply.status(500).send({ error: 'Failed to get exposure stats' });
    }
  };
}

export function getEventsHandler(analyticsService: AnalyticsService) {
  return async (request: FastifyRequest, reply: FastifyReply) => {
    const query = request.query as {
      experimentId?: string;
      sessionId?: string;
      startDate?: string;
      endDate?: string;
      limit?: number;
      offset?: number;
    };
    const projectId = request.projectId; // From middleware

    if (!projectId) {
      return reply.status(400).send({ 
        error: 'Project ID is required',
        message: 'User must have a project associated with their account to access analytics'
      });
    }

    try {
      const analyticsQuery = {
        projectId,
        experimentId: query.experimentId,
        sessionId: query.sessionId,
        startDate: query.startDate ? new Date(query.startDate) : undefined,
        endDate: query.endDate ? new Date(query.endDate) : undefined,
        limit: query.limit || 100,
        offset: query.offset || 0,
      };

      const events = await analyticsService.getEventsWithAttribution(analyticsQuery);
      return reply.send(events);
    } catch (error) {
      request.log.error(error, 'Failed to get events');
      return reply.status(500).send({ error: 'Failed to get events' });
    }
  };
}

export function getEventCountHandler(analyticsService: AnalyticsService) {
  return async (request: FastifyRequest, reply: FastifyReply) => {
    const query = request.query as {
      experimentId?: string;
      sessionId?: string;
      startDate?: string;
      endDate?: string;
    };
    const projectId = request.projectId; // From middleware

    if (!projectId) {
      return reply.status(400).send({ 
        error: 'Project ID is required',
        message: 'User must have a project associated with their account to access analytics'
      });
    }

    try {
      const analyticsQuery = {
        projectId,
        experimentId: query.experimentId,
        sessionId: query.sessionId,
        startDate: query.startDate ? new Date(query.startDate) : undefined,
        endDate: query.endDate ? new Date(query.endDate) : undefined,
      };

      const events = await analyticsService.getEventsWithAttribution(analyticsQuery);
      const count = events.length;
      return reply.send({ count });
    } catch (error) {
      request.log.error(error, 'Failed to get event count');
      return reply.status(500).send({ error: 'Failed to get event count' });
    }
  };
}

export function getUserJourneyHandler(analyticsService: AnalyticsService) {
  return async (request: FastifyRequest, reply: FastifyReply) => {
    const { sessionId } = request.params as { sessionId: string };
    const projectId = request.projectId; // From middleware

    console.log('[ANALYTICS] getUserJourney called:', {
      sessionId,
      projectId,
      hasProjectId: !!projectId,
      hasSessionId: !!sessionId
    });

    if (!projectId) {
      console.log('[ANALYTICS] Missing projectId');
      return reply.status(400).send({ 
        error: 'Project ID is required',
        message: 'User must have a project associated with their account to access analytics'
      });
    }

    if (!sessionId) {
      console.log('[ANALYTICS] Missing sessionId');
      return reply.status(400).send({ error: 'Session ID is required' });
    }

    try {
      console.log('[ANALYTICS] Calling getUserJourney service...');
      const journey = await analyticsService.getEventsWithAttribution({
        projectId,
        sessionId,
        limit: 1000
      });
      console.log('[ANALYTICS] getUserJourney result:', { count: journey.length });
      console.log('[ANALYTICS] First event properties:', journey[0]?.properties);
      console.log('[ANALYTICS] All events properties check:');
      journey.forEach((event, index) => {
        console.log(`[ANALYTICS] Event ${index}:`, {
          eventType: event.eventType,
          hasProperties: !!event.properties,
          propertiesKeys: event.properties ? Object.keys(event.properties) : 'NO PROPERTIES',
          propertiesValue: event.properties
        });
      });

      // Create summary of the session
      const variantsSeen = new Set<string>();
      const pagesVisited = new Set<string>();
      const eventTypes = new Set<string>();

      journey.forEach(event => {
        eventTypes.add(event.eventType);
        
        if (event.eventType === 'EXPOSURE') {
          const variantKey = (event.properties as any)?.variantKey;
          if (variantKey) {
            variantsSeen.add(variantKey);
          }
        }
        
        if (event.eventType === 'PAGEVIEW') {
          const url = (event.properties as any)?.url;
          if (url) {
            pagesVisited.add(url);
          }
        }
      });

      const summary = {
        totalEvents: journey.length,
        variantsSeen: Array.from(variantsSeen),
        pagesVisited: Array.from(pagesVisited),
        eventTypes: Array.from(eventTypes)
      };

      const response = { 
        sessionId,
        summary,
        journey,
        debugInfo: {
          serverTimestamp: new Date().toISOString(),
          totalEvents: journey.length,
          firstEventProperties: journey[0]?.properties,
          serverVersion: 'v1.0.0-debug'
        }
      };
      
      console.log('[ANALYTICS] Sending response, first journey event properties:', response.journey[0]?.properties);
      console.log('[ANALYTICS] Full first journey event:', JSON.stringify(response.journey[0], null, 2));
      
      return reply.send(response);
    } catch (error) {
      console.log('[ANALYTICS] getUserJourney error:', error);
      request.log.error(error, 'Failed to get user journey');
      return reply.status(500).send({ error: 'Failed to get user journey' });
    }
  };
}

export function getFunnelAnalysisHandler(analyticsService: AnalyticsService) {
  return async (request: FastifyRequest, reply: FastifyReply) => {
    const { experimentId } = request.params as { experimentId: string };
    const projectId = request.projectId; // From middleware

    console.log('[ANALYTICS] getFunnelAnalysis called:', {
      experimentId,
      projectId,
      hasProjectId: !!projectId,
      hasExperimentId: !!experimentId
    });

    if (!projectId) {
      console.log('[ANALYTICS] Missing projectId');
      return reply.status(400).send({ 
        error: 'Project ID is required',
        message: 'User must have a project associated with their account to access analytics'
      });
    }

    if (!experimentId) {
      console.log('[ANALYTICS] Missing experimentId');
      return reply.status(400).send({ error: 'Experiment ID is required' });
    }

    try {
      console.log('[ANALYTICS] Calling getFunnelAnalysis service...');
      const funnelAnalysis = await analyticsService.getFunnelAnalysis(projectId, experimentId);
      console.log('[ANALYTICS] getFunnelAnalysis result:', { 
        totalSessions: funnelAnalysis.overallStats.totalSessions,
        variantsCount: funnelAnalysis.variants.length,
        overallConversionRate: funnelAnalysis.overallStats.overallConversionRate
      });
      console.log('[ANALYTICS] Full funnel analysis response:', JSON.stringify(funnelAnalysis, null, 2));
      console.log('[ANALYTICS] Variants details:', funnelAnalysis.variants.map(variant => ({
        variantId: variant.variantId,
        totalSessions: variant.totalSessions,
        conversionRate: variant.conversionRate,
        stepsCount: variant.steps.length
      })));
      return reply.send(funnelAnalysis);
    } catch (error) {
      console.log('[ANALYTICS] getFunnelAnalysis error:', error);
      request.log.error(error, 'Failed to get funnel analysis');
      return reply.status(500).send({ error: 'Failed to get funnel analysis' });
    }
  };
}

export function getConversionRatesHandler(analyticsService: AnalyticsService) {
  return async (request: FastifyRequest, reply: FastifyReply) => {
    const { experimentId } = request.params as { experimentId: string };
    const projectId = request.projectId; // From middleware

    if (!projectId) {
      return reply.status(400).send({
        error: 'Project ID is required',
        message: 'User must have a project associated with their account to access analytics'
      });
    }

    if (!experimentId) {
      return reply.status(400).send({ error: 'Experiment ID is required' });
    }

    try {
      const conversionRates = await analyticsService.getConversionRates(projectId, experimentId);
      return reply.send({ conversionRates });
    } catch (error) {
      request.log.error(error, 'Failed to get conversion rates');
      return reply.status(500).send({ error: 'Failed to get conversion rates' });
    }
  };
}

export function getPurchaseStatsHandler(analyticsService: AnalyticsService) {
  return async (request: FastifyRequest, reply: FastifyReply) => {
    const { experimentId } = request.params as { experimentId: string };
    const projectId = request.projectId; // From middleware

    if (!projectId) {
      return reply.status(400).send({
        error: 'Project ID is required',
        message: 'User must have a project associated with their account to access analytics'
      });
    }

    if (!experimentId) {
      return reply.status(400).send({ error: 'Experiment ID is required' });
    }

    try {
      const purchaseStats = await analyticsService.getPurchaseStats(projectId, experimentId);
      return reply.send({ purchaseStats });
    } catch (error) {
      request.log.error(error, 'Failed to get purchase stats');
      return reply.status(500).send({ error: 'Failed to get purchase stats' });
    }
  };
}

export function getExperimentSessionsHandler(analyticsService: AnalyticsService) {
  return async (request: FastifyRequest, reply: FastifyReply) => {
    const { experimentId } = request.params as { experimentId: string };
    const query = request.query as {
      limit?: number;
      offset?: number;
    };
    const projectId = request.projectId; // From middleware

    if (!projectId) {
      return reply.status(400).send({ 
        error: 'Project ID is required',
        message: 'User must have a project associated with their account to access analytics'
      });
    }

    if (!experimentId) {
      return reply.status(400).send({ error: 'Experiment ID is required' });
    }

    try {
      const limit = query.limit || 100;
      const offset = query.offset || 0;
      
      const result = await analyticsService.getExperimentSessions(projectId, experimentId, limit, offset);
      
      return reply.send({
        sessions: result.sessions,
        total: result.total,
        limit,
        offset
      });
    } catch (error) {
      request.log.error(error, 'Failed to get experiment sessions');
      return reply.status(500).send({ error: 'Failed to get experiment sessions' });
    }
  };
}
</file>

<file path="src/interfaces/http/analytics/schemas.ts">
import { FastifySchema } from 'fastify';

export const getExposureStatsSchema: FastifySchema = {
  params: {
    type: 'object',
    properties: {
      experimentId: { type: 'string' }
    },
    required: ['experimentId']
  },
  response: {
    200: {
      type: 'array',
      items: {
        type: 'object',
        properties: {
          experimentId: { type: 'string' },
          variantId: { type: 'string' },
          exposures: { type: 'number' },
          uniqueSessions: { type: 'number' }
        }
      }
    }
  }
};

export const getEventsSchema: FastifySchema = {
  querystring: {
    type: 'object',
    properties: {
      experimentId: { type: 'string' },
      sessionId: { type: 'string' },
      startDate: { type: 'string', format: 'date-time' },
      endDate: { type: 'string', format: 'date-time' },
      limit: { type: 'number', minimum: 1, maximum: 1000 },
      offset: { type: 'number', minimum: 0 }
    }
  },
  response: {
    200: {
      type: 'array',
      items: {
        type: 'object',
        properties: {
          id: { type: 'string' },
          projectId: { type: 'string' },
          experimentId: { type: 'string' },
          eventType: { type: 'string' },
          sessionId: { type: 'string' },
          viewId: { type: 'string' },
          properties: { type: 'object' },
          timestamp: { type: 'number' },
          createdAt: { type: 'string', format: 'date-time' }
        }
      }
    }
  }
};

export const getEventCountSchema: FastifySchema = {
  querystring: {
    type: 'object',
    properties: {
      experimentId: { type: 'string' },
      sessionId: { type: 'string' },
      startDate: { type: 'string', format: 'date-time' },
      endDate: { type: 'string', format: 'date-time' }
    }
  },
  response: {
    200: {
      type: 'object',
      properties: {
        count: { type: 'number' }
      }
    }
  }
};

export const getUserJourneySchema: FastifySchema = {
  params: {
    type: 'object',
    properties: {
      sessionId: { type: 'string' }
    },
    required: ['sessionId']
  },
  response: {
    200: {
      type: 'object',
      properties: {
        sessionId: { type: 'string' },
        summary: {
          type: 'object',
          properties: {
            totalEvents: { type: 'number' },
            variantsSeen: {
              type: 'array',
              items: { type: 'string' }
            },
            pagesVisited: {
              type: 'array',
              items: { type: 'string' }
            },
            eventTypes: {
              type: 'array',
              items: { type: 'string' }
            }
          }
        },
        journey: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              id: { type: 'string' },
              projectId: { type: 'string' },
              experimentId: { type: 'string' },
              eventType: { type: 'string' },
              sessionId: { type: 'string' },
              viewId: { type: 'string' },
              properties: { 
                type: 'object',
                additionalProperties: true
              },
              timestamp: { type: 'number' },
              createdAt: { type: 'string', format: 'date-time' }
            }
          }
        },
        debugInfo: {
          type: 'object',
          properties: {
            serverTimestamp: { type: 'string' },
            totalEvents: { type: 'number' },
            firstEventProperties: { type: 'object' },
            serverVersion: { type: 'string' }
          }
        }
      }
    }
  }
};

export const getFunnelAnalysisSchema: FastifySchema = {
  params: {
    type: 'object',
    properties: {
      experimentId: { type: 'string' }
    },
    required: ['experimentId']
  },
  response: {
    200: {
      type: 'object',
      properties: {
        experimentId: { type: 'string' },
        variants: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              variantId: { type: 'string' },
              steps: {
                type: 'array',
                items: {
                  type: 'object',
                  properties: {
                    stepName: { type: 'string' },
                    eventType: { type: 'string' },
                    count: { type: 'number' },
                    percentage: { type: 'number' },
                    dropoffRate: { type: 'number' }
                  }
                }
              },
              totalSessions: { type: 'number' },
              conversionRate: { type: 'number' }
            }
          }
        },
        overallStats: {
          type: 'object',
          properties: {
            totalSessions: { type: 'number' },
            totalExposures: { type: 'number' },
            totalConversions: { type: 'number' },
            overallConversionRate: { type: 'number' }
          }
        }
      }
    }
  }
};

export const getConversionRatesSchema: FastifySchema = {
  params: {
    type: 'object',
    properties: {
      experimentId: { type: 'string' }
    },
    required: ['experimentId']
  },
  response: {
    200: {
      type: 'object',
      properties: {
        conversionRates: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              experimentId: { type: 'string' },
              variantId: { type: 'string' },
              sessions: { type: 'number' },
              conversions: { type: 'number' },
              conversionRate: { type: 'number' },
              averageValue: { type: 'number' },
              totalValue: { type: 'number' }
            }
          }
        }
      }
    }
  }
};

export const getPurchaseStatsSchema: FastifySchema = {
  params: {
    type: 'object',
    properties: {
      experimentId: { type: 'string' }
    },
    required: ['experimentId']
  },
  response: {
    200: {
      type: 'object',
      properties: {
        purchaseStats: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              experimentId: { type: 'string' },
              variantId: { type: 'string' },
              sessions: { type: 'number' },
              purchases: { type: 'number' },
              purchaseRate: { type: 'number' },
              totalRevenue: { type: 'number' },
              averageOrderValue: { type: 'number' },
              revenuePerSession: { type: 'number' }
            }
          }
        }
      }
    }
  }
};

export const getExperimentSessionsSchema: FastifySchema = {
  params: {
    type: 'object',
    properties: {
      experimentId: { type: 'string' }
    },
    required: ['experimentId']
  },
  querystring: {
    type: 'object',
    properties: {
      limit: { type: 'number', minimum: 1, maximum: 1000, default: 100 },
      offset: { type: 'number', minimum: 0, default: 0 }
    }
  },
  response: {
    200: {
      type: 'object',
      properties: {
        sessions: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              sessionId: { type: 'string' },
              eventCount: { type: 'number' }
            }
          }
        },
        total: { type: 'number' },
        limit: { type: 'number' },
        offset: { type: 'number' }
      }
    }
  }
};
</file>

<file path="src/interfaces/http/middleware/better-auth.ts">
import type { FastifyRequest } from 'fastify/types/request.js';
import type { FastifyReply } from 'fastify/types/reply.js';
import '@shared/fastify.d';
import { auth } from '@infra/auth';
import { handleAuthError } from '@infra/errors';

/**
 * Better Auth middleware for Fastify
 * Verifies the session and attaches user context to the request
 */
export const betterAuthMiddleware = async (request: FastifyRequest, reply: FastifyReply) => {
  try {
    // Create headers object for Better Auth (includes cookies)
    const fetchHeaders = new Headers(request.headers as HeadersInit);

    // Verify session using Better Auth
    const sessionData = await auth.api.getSession({
      headers: fetchHeaders,
    });

    console.log('[BETTER_AUTH] Session data:', sessionData);

    if (!sessionData || !sessionData.session || !sessionData.user) {
      console.log('[BETTER_AUTH] No valid session found');
      return reply.status(401).send({
        error: 'UNAUTHORIZED',
        message: 'Invalid or expired session'
      });
    }

    // Attach user context to request
    request.user = {
      sub: sessionData.user.id,
      email: sessionData.user.email,
      email_verified: sessionData.user.emailVerified,
    };

    // Get or create user from our database
    const { userService } = await import('@infra/dal/user');
    const user = await userService.getOrCreateUser(
      sessionData.user.id,
      sessionData.user.email,
      sessionData.user.name
    );

    console.log('[BETTER_AUTH] User data:', {
      userId: user.id,
      email: user.email,
      hasProject: !!user.project,
      projectId: user.project?.id
    });

    request.userId = user.id;

    // Get user's project ID (single project per user)
    if (user.project) {
      request.projectId = user.project.id;
      console.log('[BETTER_AUTH] Project ID set:', request.projectId);
    } else {
      console.log('[BETTER_AUTH] No project found for user');
    }

  } catch (error) {
    return handleAuthError(error, reply);
  }
};
</file>

<file path="src/interfaces/http/utils/chat-utils.ts">
import { UIMessagePart } from 'ai';

/**
 * Extracts text content from UIMessage parts array
 */
export function extractTextFromParts(parts: UIMessagePart<any, any>[]): string {
    return parts
        .filter((part): part is UIMessagePart<any, any> & { type: 'text'; text: string } =>
            part.type === 'text' && 'text' in part)
        .map(part => part.text)
        .join('');
}
</file>

<file path="src/services/job-cleanup.ts">
// Job Cleanup Service - Refactored to use DAL pattern
import { VariantJobDAL } from '@infra/dal';
import { ScreenshotDAL } from '@infra/dal/screenshot';

export interface JobCleanupService {
  startCleanup(): void;
  stopCleanup(): void;
  cleanupNow(): Promise<number>;
  cleanupScreenshots(): Promise<number>;
  getScreenshotStats(projectId: string): Promise<{
    totalScreenshots: number;
    totalSize: number;
    accessCount: number;
  }>;
}

export class JobCleanupServiceImpl implements JobCleanupService {
  private cleanupInterval: NodeJS.Timeout | null = null;
  private readonly CLEANUP_INTERVAL = 24 * 60 * 60 * 1000; // 24 hours
  private readonly JOB_RETENTION_DAYS = 7; // Keep jobs for 7 days

  startCleanup(): void {
    if (this.cleanupInterval) {
      console.log('[JOB_CLEANUP] Cleanup already running');
      return;
    }

    console.log('[JOB_CLEANUP] Starting job cleanup service');

    // Run cleanup immediately
    this.runCleanup();

    // Schedule periodic cleanup
    this.cleanupInterval = setInterval(() => {
      this.runCleanup();
    }, this.CLEANUP_INTERVAL);
  }

  stopCleanup(): void {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
      console.log('[JOB_CLEANUP] Job cleanup service stopped');
    }
  }

  private async runCleanup(): Promise<void> {
    try {
      console.log('[JOB_CLEANUP] Running job cleanup...');
      const deletedCount = await VariantJobDAL.cleanupOldJobs(this.JOB_RETENTION_DAYS);
      console.log(`[JOB_CLEANUP] Cleaned up ${deletedCount} old variant jobs`);

      // Clean up expired screenshots
      console.log('[JOB_CLEANUP] Running screenshot cleanup...');
      const screenshotCount = await ScreenshotDAL.deleteExpired();
      console.log(`[JOB_CLEANUP] Cleaned up ${screenshotCount} expired screenshots`);
    } catch (error) {
      console.error('[JOB_CLEANUP] Error during cleanup:', error);
    }
  }

  async cleanupNow(): Promise<number> {
    console.log('[JOB_CLEANUP] Running immediate cleanup...');
    return await VariantJobDAL.cleanupOldJobs(this.JOB_RETENTION_DAYS);
  }

  async cleanupScreenshots(): Promise<number> {
    console.log('[JOB_CLEANUP] Running screenshot cleanup...');
    return await ScreenshotDAL.deleteExpired();
  }

  async getScreenshotStats(projectId: string): Promise<{
    totalScreenshots: number;
    totalSize: number;
    accessCount: number;
  }> {
    return await ScreenshotDAL.getProjectStats(projectId);
  }
}

// Simplified factory function - no longer needs prisma parameter
export function createJobCleanupService(): JobCleanupService {
  return new JobCleanupServiceImpl();
}
</file>

<file path="src/services/project-info.ts">
// Project Information Service
import { ProjectDAL } from '@infra/dal';
import { shopify } from '@infra/external/shopify';
import type { ProjectInfo } from '@domain/agent';

export interface ProjectInfoService {
  getProjectInfo(projectId: string): Promise<ProjectInfo>;
}

export class ProjectInfoServiceImpl implements ProjectInfoService {
  async getProjectInfo(projectId: string): Promise<ProjectInfo> {
    // Get project with relations
    const project = await ProjectDAL.getProjectWithRelations(projectId);
    if (!project) {
      throw new Error(`Project ${projectId} not found`);
    }

    // Get store information (only for Shopify stores)
    let shopInfo: {
      name?: string;
      email?: string;
      planName?: string;
      currency?: string;
      country?: string;
    } = {};

    // Only fetch Shopify data if this is a Shopify store
    if (project.isShopify && project.accessTokenEnc) {
      try {
        const shopProfile = await shopify.getShopProfileWithEncryptedToken(
          project.shopDomain,
          project.accessTokenEnc
        );
        shopInfo = {
          name: shopProfile.name,
          email: shopProfile.email,
          planName: shopProfile.planName,
          currency: shopProfile.currency,
          country: shopProfile.country,
        };
      } catch (error) {
        console.warn(`[PROJECT_INFO] Failed to fetch Shopify store info for ${project.shopDomain}:`, error);
        // Continue without shop info if API call fails
      }
    } else if (!project.isShopify) {
      // For non-Shopify stores, use generic info
      shopInfo = {
        name: project.shopDomain, // Use domain as name for non-Shopify stores
        // Other fields remain undefined for non-Shopify stores
      };
    }

    // Count experiments by status
    const experimentsCount = project.experiments.length;
    const activeExperimentsCount = project.experiments.filter(
      exp => exp.status === 'RUNNING'
    ).length;

    return {
      id: project.id,
      shopDomain: project.shopDomain,
      isShopify: project.isShopify,
      shopName: shopInfo.name,
      shopEmail: shopInfo.email,
      shopPlan: shopInfo.planName,
      shopCurrency: shopInfo.currency,
      shopCountry: shopInfo.country,
      experimentsCount,
      activeExperimentsCount,
    };
  }
}

export function createProjectInfoService(): ProjectInfoService {
  return new ProjectInfoServiceImpl();
}
</file>

<file path="src/shared/screenshot-config.ts">
// Screenshot Configuration - Single Source of Truth
import { ScreenshotOptions } from '@services/screenshot-storage';

// Standard screenshot configuration used across all services
export const STANDARD_SCREENSHOT_OPTIONS: ScreenshotOptions = {
  viewport: { width: 1920, height: 1080 },
  fullPage: true,
  quality: 80
};

// High quality screenshot configuration for brand analysis
export const HIGH_QUALITY_SCREENSHOT_OPTIONS: ScreenshotOptions = {
  viewport: { width: 1920, height: 1080 },
  fullPage: true,
  quality: 100
};

// Default page type mapping
export const getPageType = (url: string): 'home' | 'pdp' | 'about' | 'other' => {
  const urlLower = url.toLowerCase();
  
  if (urlLower.includes('/product/') || urlLower.includes('/products/')) {
    return 'pdp';
  }
  
  if (urlLower.includes('/about') || urlLower.includes('/about-us')) {
    return 'about';
  }
  
  if (urlLower === url.toLowerCase() || urlLower.endsWith('/') || urlLower.split('/').length <= 3) {
    return 'home';
  }
  
  return 'other';
};

// Smart URL pattern matching for experiment targeting
export interface URLPattern {
  type: 'exact' | 'startsWith' | 'endsWith' | 'contains' | 'regex';
  pattern: string;
  caseSensitive?: boolean;
}

export function matchesURLPattern(url: string, patterns: URLPattern[]): boolean {
  if (!patterns || patterns.length === 0) return true; // No patterns = match all
  
  return patterns.some(pattern => {
    const targetUrl = pattern.caseSensitive ? url : url.toLowerCase();
    const targetPattern = pattern.caseSensitive ? pattern.pattern : pattern.pattern.toLowerCase();
    
    switch (pattern.type) {
      case 'exact':
        return targetUrl === targetPattern;
      case 'startsWith':
        return targetUrl.startsWith(targetPattern);
      case 'endsWith':
        return targetUrl.endsWith(targetPattern);
      case 'contains':
        return targetUrl.includes(targetPattern);
      case 'regex':
        try {
          const regex = new RegExp(targetPattern, pattern.caseSensitive ? 'g' : 'gi');
          return regex.test(targetUrl);
        } catch (error) {
          console.warn(`Invalid regex pattern: ${targetPattern}`, error);
          return false;
        }
      default:
        return false;
    }
  });
}

// Helper function to create common URL patterns
export function createURLPatterns(patterns: string[]): URLPattern[] {
  return patterns.map(pattern => {
    // Detect pattern type based on syntax
    if (pattern.startsWith('^') && pattern.endsWith('$')) {
      // Exact match
      return { type: 'exact', pattern: pattern.slice(1, -1) };
    } else if (pattern.startsWith('^')) {
      // Starts with
      return { type: 'startsWith', pattern: pattern.slice(1) };
    } else if (pattern.endsWith('$')) {
      // Ends with
      return { type: 'endsWith', pattern: pattern.slice(0, -1) };
    } else if (pattern.includes('*')) {
      // Wildcard - convert to regex
      const regexPattern = pattern.replace(/\*/g, '.*');
      return { type: 'regex', pattern: `^${regexPattern}$` };
    } else if (pattern.startsWith('/') && pattern.endsWith('/')) {
      // Regex pattern
      return { type: 'regex', pattern: pattern.slice(1, -1) };
    } else {
      // Contains
      return { type: 'contains', pattern };
    }
  });
}
</file>

<file path="docker-compose.yml">
services:
  api:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "3001:3001"
    environment:
      - NODE_ENV=development
      - PORT=3001
      - DATABASE_URL=postgresql://postgres:password@postgres:5432/omen_db
      - CHROME_PATH=/usr/bin/chromium
    env_file:
      - .env 
    volumes:
      # Mount source code for hot reloading
      - ./src:/app/src
      - ./prisma:/app/prisma
      - ./tsconfig.json:/app/tsconfig.json
      - /app/node_modules
    depends_on:
      - postgres
    restart: unless-stopped
    command: sh -c "npx prisma migrate deploy && npm run dev"
          
  postgres:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=omen_db
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
    ports:
      - "5432:5432"
    volumes:
      - postgres_dev_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d omen_db"]
      interval: 2s
      timeout: 2s
      retries: 10
    restart: unless-stopped

volumes:
  postgres_dev_data:
</file>

<file path="Procfile">
release: npm run db:deploy
web: npm start
</file>

<file path="src/domain/agent/tools/get-brand-analysis.ts">
// @ts-nocheck 
// Brand Analysis Tool
import { tool } from 'ai';
import { ProjectDAL } from '@infra/dal/project';
import type { BrandIntelligenceData } from '@features/brand_analysis/types';
import { getBrandAnalysisSchema } from './schemas';

class GetBrandAnalysisExecutor {
  private projectId: string;

  constructor(projectId: string) {
    this.projectId = projectId;
  }

  async execute(input: { projectId?: string }) {
    try {
      console.log(`[BRAND_ANALYSIS] Using project ID: ${this.projectId}`);
      
      // Get brand analysis from database
      const brandAnalysisJson = await ProjectDAL.getProjectBrandAnalysis(this.projectId);

      console.log(`[BRAND_ANALYSIS] Brand analysis JSON: ${brandAnalysisJson}`);
      
      if (!brandAnalysisJson) {
        return {
          success: false,
          error: 'No brand analysis found for this project. Please run a brand analysis first.',
          data: null
        };
      }

      // Parse the JSON data and return it directly for the LLM to interpret
      const brandAnalysis: BrandIntelligenceData = JSON.parse(brandAnalysisJson);
      
      return {
        success: true,
        data: brandAnalysis,
        message: `Here's your brand analysis! Feel free to ask any questions about the insights, or let's start generating experiments to optimize your store.`
      };
    } catch (error) {
      console.error('Error getting brand analysis:', error);
      return {
        success: false,
        error: `Failed to retrieve brand analysis: ${error instanceof Error ? error.message : 'Unknown error'}`,
        data: null
      };
    }
  }
}

export function createGetBrandAnalysisTool(projectId: string) {
  const executor = new GetBrandAnalysisExecutor(projectId);

  return tool({
    description: 'Get the brand analysis data for a project. This includes visual style, brand elements, language analysis, and messaging insights.',
    inputSchema: getBrandAnalysisSchema,
    execute: async (input) => {
      try {
        return await executor.execute(input);
      } catch (error) {
        throw new Error(error instanceof Error ? error.message : 'Failed to fetch brand analysis');
      }
    },
  });
}
</file>

<file path="src/domain/agent/variant-state-manager.ts">
// Variant State Manager - manages variant state across tool calls
import { Variant } from '@features/variant_generation/types';
import { VariantJobDAL } from '@infra/dal';

class VariantStateManager {
  private currentVariants: Variant[] | null = null;
  private variantHistory: Variant[][] = [];
  private currentJobIds: string[] | null = null;

  /**
   * Set the current variants (from generate_variants tool)
   */
  setCurrentVariants(variants: Variant[]): void {
    console.log(`[STATE_MANAGER] ===== SETTING VARIANTS =====`);
    console.log(`[STATE_MANAGER] Input variants type:`, typeof variants);
    console.log(`[STATE_MANAGER] Input variants length:`, variants ? variants.length : 'null/undefined');
    console.log(`[STATE_MANAGER] Input variants:`, JSON.stringify(variants.map(v => ({ 
      label: v.variant_label, 
      description: v.description.substring(0, 50) + '...' 
    })), null, 2));
    this.currentVariants = variants;
    this.variantHistory.push(variants);
    console.log(`[STATE_MANAGER] Variants set: ${variants.length} variants`);
    console.log(`[STATE_MANAGER] Current variant set count: ${this.variantHistory.length}`);
    console.log(`[STATE_MANAGER] ================================`);
  }

  /**
   * Set the current job IDs (from generate_variants tool)
   */
  setCurrentJobIds(jobIds: string[]): void {
    console.log(`[STATE_MANAGER] ===== SETTING JOB IDS =====`);
    console.log(`[STATE_MANAGER] Job IDs:`, jobIds);
    this.currentJobIds = jobIds;
    console.log(`[STATE_MANAGER] ==========================`);
  }


  /**
   * Get the current job IDs
   */
  getCurrentJobIds(): string[] | null {
    console.log(`[STATE_MANAGER] ===== GETTING JOB IDS =====`);
    console.log(`[STATE_MANAGER] Current job IDs:`, this.currentJobIds);
    console.log(`[STATE_MANAGER] ===========================`);
    return this.currentJobIds;
  }


  /**
   * Get the current variants (for create_experiment tool)
   */
  getCurrentVariants(): Variant[] | null {
    console.log(`[STATE_MANAGER] ===== GETTING VARIANTS =====`);
    console.log(`[STATE_MANAGER] Current variants: ${this.currentVariants ? `${this.currentVariants.length} variants FOUND` : 'NOT FOUND'}`);
    if (this.currentVariants) {
      console.log(`[STATE_MANAGER] Variant labels:`, this.currentVariants.map(v => v.variant_label));
    }
    console.log(`[STATE_MANAGER] ==============================`);
    return this.currentVariants;
  }

  /**
   * Get the most recent variants from history
   */
  getLatestVariants(): Variant[] | null {
    return this.variantHistory.length > 0 
      ? this.variantHistory[this.variantHistory.length - 1] 
      : null;
  }

  /**
   * Clear the current variants
   */
  clearCurrentVariants(): void {
    console.log(`[STATE_MANAGER] Clearing current variants`);
    this.currentVariants = null;
  }

  /**
   * Clear the current job IDs
   */
  clearCurrentJobIds(): void {
    console.log(`[STATE_MANAGER] Clearing current job IDs`);
    this.currentJobIds = null;
  }


  /**
   * Clear all variant history
   */
  clearAll(): void {
    console.log(`[STATE_MANAGER] Clearing all variant data`);
    this.currentVariants = null;
    this.variantHistory = [];
    this.currentJobIds = null;
  }

  /**
   * Get variant history
   */
  getHistory(): Variant[][] {
    return [...this.variantHistory];
  }

  /**
   * Check if there are current variants
   */
  hasCurrentVariants(): boolean {
    return this.currentVariants !== null && this.currentVariants.length > 0;
  }

  /**
   * Get the number of current variants
   */
  getCurrentVariantCount(): number {
    return this.currentVariants ? this.currentVariants.length : 0;
  }

  /**
   * Retrieve completed variants from specific job IDs and populate state manager
   */
  async loadVariantsFromJobIds(jobIds: string[]): Promise<Variant[]> {
    console.log(`[STATE_MANAGER] ===== LOADING VARIANTS FROM SPECIFIC JOBS =====`);
    console.log(`[STATE_MANAGER] Job IDs:`, jobIds);
    
    try {
      const variants: Variant[] = [];
      const completedJobIds: string[] = [];
      
      for (const jobId of jobIds) {
        try {
          const job = await VariantJobDAL.getJobById(jobId);
          if (!job) {
            console.log(`[STATE_MANAGER] Job ${jobId} not found`);
            continue;
          }
          
          if (job.status === 'COMPLETED' && job.result) {
            if (job.result.variantsSchema && job.result.variantsSchema.variants) {
              const jobVariants = job.result.variantsSchema.variants;
              console.log(`[STATE_MANAGER] Job ${jobId} has ${jobVariants.length} variants`);
              variants.push(...jobVariants);
              completedJobIds.push(jobId);
            } else {
              console.log(`[STATE_MANAGER] Job ${jobId} completed but has no variants in result`);
            }
          } else {
            console.log(`[STATE_MANAGER] Job ${jobId} status: ${job.status}, has result: ${!!job.result}`);
          }
        } catch (error) {
          console.error(`[STATE_MANAGER] Error loading job ${jobId}:`, error);
        }
      }

      console.log(`[STATE_MANAGER] Extracted ${variants.length} variants from ${completedJobIds.length}/${jobIds.length} completed jobs`);
      
      if (variants.length > 0) {
        // Set the variants in the state manager
        this.setCurrentVariants(variants);
        console.log(`[STATE_MANAGER] Successfully loaded ${variants.length} variants into state manager`);
      }

      console.log(`[STATE_MANAGER] ================================================`);
      return variants;
    } catch (error) {
      console.error(`[STATE_MANAGER] Failed to load variants from job IDs:`, error);
      return [];
    }
  }

  /**
   * Retrieve completed variants from jobs for a project and populate state manager
   * @deprecated Use loadVariantsFromJobIds for more precise control
   */
  async loadVariantsFromJobs(projectId: string): Promise<Variant[]> {
    console.log(`[STATE_MANAGER] ===== LOADING VARIANTS FROM ALL PROJECT JOBS =====`);
    console.log(`[STATE_MANAGER] Project ID: ${projectId}`);
    
    try {
      // Get all completed jobs for this project
      const jobs = await VariantJobDAL.getJobsByProject(projectId);
      const completedJobs = jobs.filter(job => job.status === 'COMPLETED' && job.result);
      
      console.log(`[STATE_MANAGER] Found ${jobs.length} total jobs, ${completedJobs.length} completed`);
      
      if (completedJobs.length === 0) {
        console.log(`[STATE_MANAGER] No completed variant jobs found`);
        return [];
      }

      // Extract variants from completed jobs
      const variants: Variant[] = [];
      for (const job of completedJobs) {
        try {
          if (job.result && job.result.variantsSchema && job.result.variantsSchema.variants) {
            const jobVariants = job.result.variantsSchema.variants;
            console.log(`[STATE_MANAGER] Job ${job.id} has ${jobVariants.length} variants`);
            variants.push(...jobVariants);
          }
        } catch (error) {
          console.error(`[STATE_MANAGER] Error extracting variants from job ${job.id}:`, error);
        }
      }

      console.log(`[STATE_MANAGER] Extracted ${variants.length} total variants from jobs`);
      
      if (variants.length > 0) {
        // Set the variants in the state manager
        this.setCurrentVariants(variants);
        console.log(`[STATE_MANAGER] Successfully loaded ${variants.length} variants into state manager`);
      }

      console.log(`[STATE_MANAGER] ==========================================`);
      return variants;
    } catch (error) {
      console.error(`[STATE_MANAGER] Failed to load variants from jobs:`, error);
      return [];
    }
  }

  /**
   * Check if there are completed variant jobs for a project
   */
  async hasCompletedJobs(projectId: string): Promise<boolean> {
    try {
      const jobs = await VariantJobDAL.getJobsByProject(projectId);
      return jobs.some(job => job.status === 'COMPLETED' && job.result);
    } catch (error) {
      console.error(`[STATE_MANAGER] Error checking completed jobs:`, error);
      return false;
    }
  }
}

// Singleton instance
export const variantStateManager = new VariantStateManager();

// Export the class for testing
export { VariantStateManager };
</file>

<file path="src/features/brand_analysis/index.ts">
// Brand Analysis Feature Exports - Firecrawl Implementation
export { analyzeProject } from './brand-analysis';
export { FirecrawlService } from './firecrawl-service';
export { UrlSelector } from './url-selector';
export { getPageSpecificPrompt, getSynthesisPrompt } from './prompts';
export type {
  BrandIntelligenceData
} from './types';
export { brandIntelligenceSchema, synthesisSchema } from './types';
export type { PageType } from './prompts';
</file>

<file path="src/features/variant_generation/element-detector.ts">
// Multi-Strategy Element Detection System
// Based on Playwright's locator strategy and industry best practices

import * as cheerio from 'cheerio';
import { CSSPathGenerator } from './css-path-generator';

export interface ElementCandidate {
  selector: string;
  confidence: number;
  strategy: 'role' | 'text' | 'testid' | 'label' | 'placeholder' | 'title' | 'alt' | 'class' | 'id' | 'position';
  element: {
    tagName: string;
    text?: string;
    attributes: Record<string, string>;
    boundingBox?: { x: number; y: number; width: number; height: number };
  };
  reasoning: string;
}

export interface ElementDetectionResult {
  found: boolean;
  candidates: ElementCandidate[];
  bestMatch?: ElementCandidate;
  suggestions: string[];
}

// Playwright-inspired locator strategies
export class ElementDetector {
  private $: cheerio.CheerioAPI;
  private cssPathGenerator: CSSPathGenerator;

  constructor(html: string) {
    this.$ = cheerio.load(html);
    this.cssPathGenerator = new CSSPathGenerator(html);
  }

  // Main detection method - tries multiple strategies
  async detectElement(hypothesis: string): Promise<ElementDetectionResult> {
    console.log(`[ELEMENT_DETECTOR] Detecting element for hypothesis: "${hypothesis}"`);

    const candidates: ElementCandidate[] = [];

    // Strategy 1: Role-based detection (most reliable)
    const roleCandidates = this.detectByRole(hypothesis);
    candidates.push(...roleCandidates);

    // Strategy 2: Text-based detection
    const textCandidates = this.detectByText(hypothesis);
    candidates.push(...textCandidates);

    // Strategy 3: Data attributes
    const testIdCandidates = this.detectByTestId(hypothesis);
    candidates.push(...testIdCandidates);

    // Strategy 4: Label-based detection
    const labelCandidates = this.detectByLabel(hypothesis);
    candidates.push(...labelCandidates);

    // Strategy 5: Placeholder-based detection
    const placeholderCandidates = this.detectByPlaceholder(hypothesis);
    candidates.push(...placeholderCandidates);

    // Strategy 6: Title-based detection
    const titleCandidates = this.detectByTitle(hypothesis);
    candidates.push(...titleCandidates);

    // Strategy 7: Alt text detection
    const altCandidates = this.detectByAltText(hypothesis);
    candidates.push(...altCandidates);

    // Strategy 8: Semantic class detection
    const classCandidates = this.detectBySemanticClass(hypothesis);
    candidates.push(...classCandidates);

    // Strategy 9: Stable ID detection
    const idCandidates = this.detectByStableId(hypothesis);
    candidates.push(...idCandidates);

    // Strategy 10: Position-based detection (last resort)
    const positionCandidates = this.detectByPosition(hypothesis);
    candidates.push(...positionCandidates);

    // Remove duplicates and validate selectors
    const uniqueCandidates = this.deduplicateAndValidate(candidates);

    // Sort by confidence and strategy priority
    const sortedCandidates = this.sortCandidates(uniqueCandidates);

    const bestMatch = sortedCandidates.length > 0 ? sortedCandidates[0] : undefined;

    return {
      found: sortedCandidates.length > 0,
      candidates: sortedCandidates,
      bestMatch,
      suggestions: this.generateSuggestions(hypothesis, sortedCandidates)
    };
  }

  // Strategy 1: Role-based detection (Playwright's getByRole)
  private detectByRole(hypothesis: string): ElementCandidate[] {
    const candidates: ElementCandidate[] = [];
    const roleKeywords = this.extractRoleKeywords(hypothesis);

    // Common role mappings
    const roleMap: Record<string, string[]> = {
      'button': ['button', 'link', 'summary'],
      'heading': ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'],
      'textbox': ['input[type="text"]', 'input[type="email"]', 'input[type="password"]', 'textarea'],
      'link': ['a'],
      'image': ['img'],
      'list': ['ul', 'ol'],
      'listitem': ['li'],
      'navigation': ['nav'],
      'main': ['main'],
      'article': ['article'],
      'section': ['section'],
      'form': ['form']
    };

    for (const keyword of roleKeywords) {
      const roles = roleMap[keyword.toLowerCase()] || [];

      for (const role of roles) {
        const elements = this.$(role);

        elements.each((_, el) => {
          const $el = this.$(el);
          const text = $el.text().trim();
          const attributes = this.getElementAttributes($el);

          // Check if element has explicit role attribute
          const explicitRole = attributes.role;
          if (explicitRole && explicitRole.toLowerCase().includes(keyword.toLowerCase())) {
            const tagName = el.type === 'tag' ? el.name : 'unknown';
            // Generate specific CSS path instead of generic selector
            const specificSelector = this.cssPathGenerator.generateSelector($el);
            candidates.push({
              selector: specificSelector,
              confidence: 0.95,
              strategy: 'role',
              element: {
                tagName,
                text,
                attributes
              },
              reasoning: `Element with explicit role="${explicitRole}" matches "${keyword}"`
            });
          }

          // Check if element type matches role
          if (el.type === 'tag' && roles.includes(el.name)) {
            // Generate specific CSS path instead of generic tag name
            const specificSelector = this.cssPathGenerator.generateSelector($el);
            candidates.push({
              selector: specificSelector,
              confidence: 0.8,
              strategy: 'role',
              element: {
                tagName: el.name,
                text,
                attributes
              },
              reasoning: `Element type "${el.name}" matches role "${keyword}"`
            });
          }
        });
      }
    }

    return candidates;
  }

  // Strategy 2: Text-based detection (Playwright's getByText)
  private detectByText(hypothesis: string): ElementCandidate[] {
    const candidates: ElementCandidate[] = [];
    const textKeywords = this.extractTextKeywords(hypothesis);

    for (const keyword of textKeywords) {
      // Instead of using :contains() which can break with special chars,
      // iterate through all elements and check text content
      this.$('*').each((_, el) => {
        const $el = this.$(el);
        const text = $el.text().trim();

        // Only consider elements where the text matches exactly or is contained
        if (text.toLowerCase().includes(keyword.toLowerCase())) {
          const attributes = this.getElementAttributes($el);
          const tagName = el.type === 'tag' ? el.name : 'unknown';

          // Generate specific CSS path instead of generic selector
          const specificSelector = this.cssPathGenerator.generateSelector($el);

          candidates.push({
            selector: specificSelector,
            confidence: text.toLowerCase() === keyword.toLowerCase() ? 0.9 : 0.7,
            strategy: 'text',
            element: {
              tagName,
              text,
              attributes
            },
            reasoning: `Element contains text "${keyword}"`
          });
        }
      });
    }

    return candidates;
  }

  // Strategy 3: Data attributes (Playwright's getByTestId)
  private detectByTestId(_hypothesis: string): ElementCandidate[] {
    const candidates: ElementCandidate[] = [];

    // Look for data-testid attributes
    const testIdElements = this.$('[data-testid]');

    testIdElements.each((_, el) => {
      const $el = this.$(el);
      const testId = $el.attr('data-testid');
      const text = $el.text().trim();
      const attributes = this.getElementAttributes($el);
      const tagName = el.type === 'tag' ? el.name : 'unknown';

      if (testId) {
        candidates.push({
          selector: `[data-testid="${testId}"]`,
          confidence: 0.95,
          strategy: 'testid',
          element: {
            tagName,
            text,
            attributes
          },
          reasoning: `Element has data-testid="${testId}"`
        });
      }
    });

    return candidates;
  }

  // Strategy 4: Label-based detection (Playwright's getByLabel)
  private detectByLabel(hypothesis: string): ElementCandidate[] {
    const candidates: ElementCandidate[] = [];
    const labelKeywords = this.extractLabelKeywords(hypothesis);

    for (const keyword of labelKeywords) {
      // Iterate through all labels to avoid :contains() breaking with special chars
      const labels = this.$('label');

      labels.each((_, labelEl) => {
        const $label = this.$(labelEl);
        const labelText = $label.text().trim();

        // Skip if label doesn't contain keyword
        if (!labelText.toLowerCase().includes(keyword.toLowerCase())) {
          return;
        }

        const forAttr = $label.attr('for');

        if (forAttr) {
          // Find the associated input
          const input = this.$(`#${forAttr}`);
          if (input.length > 0) {
            const attributes = this.getElementAttributes(input);
            candidates.push({
              selector: `#${forAttr}`,
              confidence: 0.9,
              strategy: 'label',
              element: {
                tagName: input[0].type === 'tag' ? input[0].name : 'unknown',
                text: input.text().trim(),
                attributes
              },
              reasoning: `Input associated with label containing "${keyword}"`
            });
          }
        }
      });
    }

    return candidates;
  }

  // Strategy 5: Placeholder-based detection (Playwright's getByPlaceholder)
  private detectByPlaceholder(hypothesis: string): ElementCandidate[] {
    const candidates: ElementCandidate[] = [];
    const placeholderKeywords = this.extractPlaceholderKeywords(hypothesis);

    for (const keyword of placeholderKeywords) {
      // Escape special characters in the keyword for CSS selector
      const escapedKeyword = keyword.replace(/[\\"']/g, '\\$&');
      const inputs = this.$(`input[placeholder*="${escapedKeyword}"]`);

      inputs.each((_, el) => {
        const $el = this.$(el);
        const placeholder = $el.attr('placeholder');
        const attributes = this.getElementAttributes($el);

        candidates.push({
          selector: `input[placeholder="${placeholder}"]`,
          confidence: 0.85,
          strategy: 'placeholder',
          element: {
            tagName: el.name,
            text: $el.text().trim(),
            attributes
          },
          reasoning: `Input with placeholder containing "${keyword}"`
        });
      });
    }

    return candidates;
  }

  // Strategy 6: Title-based detection (Playwright's getByTitle)
  private detectByTitle(hypothesis: string): ElementCandidate[] {
    const candidates: ElementCandidate[] = [];
    const titleKeywords = this.extractTitleKeywords(hypothesis);

    for (const keyword of titleKeywords) {
      const elements = this.$(`[title*="${keyword}"]`);

      elements.each((_, el) => {
        const $el = this.$(el);
        const title = $el.attr('title');
        const attributes = this.getElementAttributes($el);

        candidates.push({
          selector: `[title="${title}"]`,
          confidence: 0.8,
          strategy: 'title',
          element: {
            tagName: el.name,
            text: $el.text().trim(),
            attributes
          },
          reasoning: `Element with title containing "${keyword}"`
        });
      });
    }

    return candidates;
  }

  // Strategy 7: Alt text detection (Playwright's getByAltText)
  private detectByAltText(hypothesis: string): ElementCandidate[] {
    const candidates: ElementCandidate[] = [];
    const altKeywords = this.extractAltKeywords(hypothesis);

    for (const keyword of altKeywords) {
      const images = this.$(`img[alt*="${keyword}"]`);

      images.each((_, el) => {
        const $el = this.$(el);
        const alt = $el.attr('alt');
        const attributes = this.getElementAttributes($el);

        candidates.push({
          selector: `img[alt="${alt}"]`,
          confidence: 0.85,
          strategy: 'alt',
          element: {
            tagName: el.name,
            text: alt || '',
            attributes
          },
          reasoning: `Image with alt text containing "${keyword}"`
        });
      });
    }

    return candidates;
  }

  // Strategy 8: Semantic class detection
  private detectBySemanticClass(hypothesis: string): ElementCandidate[] {
    const candidates: ElementCandidate[] = [];
    const classKeywords = this.extractClassKeywords(hypothesis);

    for (const keyword of classKeywords) {
      // Look for classes that contain the keyword
      const elements = this.$(`[class*="${keyword}"]`);

      elements.each((_, el) => {
        const $el = this.$(el);
        const classes = $el.attr('class')?.split(' ') || [];
        const matchingClasses = classes.filter(cls =>
          cls.toLowerCase().includes(keyword.toLowerCase())
        );

        if (matchingClasses.length > 0) {
          const attributes = this.getElementAttributes($el);

          // Generate specific CSS path instead of generic class selector
          const specificSelector = this.cssPathGenerator.generateSelector($el);

          candidates.push({
            selector: specificSelector,
            confidence: 0.7,
            strategy: 'class',
            element: {
              tagName: el.name,
              text: $el.text().trim(),
              attributes
            },
            reasoning: `Element with class containing "${keyword}"`
          });
        }
      });
    }

    return candidates;
  }

  // Strategy 9: Stable ID detection
  private detectByStableId(_hypothesis: string): ElementCandidate[] {
    const candidates: ElementCandidate[] = [];

    // Find elements with IDs that don't look generated
    const elementsWithIds = this.$('[id]');

    elementsWithIds.each((_, el) => {
      const $el = this.$(el);
      const id = $el.attr('id');

      if (id && this.isStableId(id)) {
        const attributes = this.getElementAttributes($el);

        candidates.push({
          selector: `#${id}`,
          confidence: 0.8,
          strategy: 'id',
          element: {
            tagName: el.name,
            text: $el.text().trim(),
            attributes
          },
          reasoning: `Element with stable ID "${id}"`
        });
      }
    });

    return candidates;
  }

  // Strategy 10: Position-based detection (last resort)
  private detectByPosition(_hypothesis: string): ElementCandidate[] {
    const candidates: ElementCandidate[] = [];

    // This would be implemented based on specific needs
    // For now, return empty array as position-based detection is fragile

    return candidates;
  }

  // Helper methods
  private extractRoleKeywords(hypothesis: string): string[] {
    const roleKeywords = ['button', 'heading', 'textbox', 'link', 'image', 'list', 'navigation', 'form'];
    return roleKeywords.filter(keyword =>
      hypothesis.toLowerCase().includes(keyword.toLowerCase())
    );
  }

  private extractTextKeywords(hypothesis: string): string[] {
    // Extract meaningful text from hypothesis
    const words = hypothesis.toLowerCase().split(/\s+/);
    return words.filter(word =>
      word.length > 2 &&
      !['the', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by'].includes(word)
    );
  }

  private extractLabelKeywords(hypothesis: string): string[] {
    return this.extractTextKeywords(hypothesis);
  }

  private extractPlaceholderKeywords(hypothesis: string): string[] {
    return this.extractTextKeywords(hypothesis);
  }

  private extractTitleKeywords(hypothesis: string): string[] {
    return this.extractTextKeywords(hypothesis);
  }

  private extractAltKeywords(hypothesis: string): string[] {
    return this.extractTextKeywords(hypothesis);
  }

  private extractClassKeywords(hypothesis: string): string[] {
    return this.extractTextKeywords(hypothesis);
  }

  private getElementAttributes($el: cheerio.Cheerio<any>): Record<string, string> {
    const attributes: Record<string, string> = {};
    const el = $el[0];

    if (el && el.type === 'tag') {
      Object.keys(el.attribs || {}).forEach(key => {
        attributes[key] = el.attribs[key];
      });
    }

    return attributes;
  }


  private isStableId(id: string): boolean {
    // Check if ID looks stable (not generated)
    const generatedPatterns = [
      /template--\d+/,
      /slide-\d+/,
      /section-\d+/,
      /block-\d+/,
      /shopify-section-\w+/,
      /^\d+$/,
      /^[a-f0-9]{8,}$/i,
      /^[a-z0-9]{20,}$/i,
      /-\d{10,}$/,
      /^[a-z]+-\d+-\d+/
    ];

    return !generatedPatterns.some(pattern => pattern.test(id));
  }

  private deduplicateAndValidate(candidates: ElementCandidate[]): ElementCandidate[] {
    const seen = new Set<string>();
    const valid: ElementCandidate[] = [];

    for (const candidate of candidates) {
      if (!seen.has(candidate.selector)) {
        // Validate selector
        try {
          this.$(candidate.selector);
          seen.add(candidate.selector);
          valid.push(candidate);
        } catch (_error) {
          // Skip invalid selectors
          console.warn(`[ELEMENT_DETECTOR] Invalid selector: ${candidate.selector}`);
        }
      }
    }

    return valid;
  }

  private sortCandidates(candidates: ElementCandidate[]): ElementCandidate[] {
    // Strategy priority (higher number = higher priority)
    const strategyPriority: Record<string, number> = {
      'testid': 9,
      'role': 8,
      'label': 7,
      'alt': 6,
      'title': 5,
      'placeholder': 4,
      'text': 3,
      'id': 2,
      'class': 1,
      'position': 0
    };

    return candidates.sort((a, b) => {
      // First by strategy priority
      const aPriority = strategyPriority[a.strategy] || 0;
      const bPriority = strategyPriority[b.strategy] || 0;

      if (aPriority !== bPriority) {
        return bPriority - aPriority;
      }

      // Then by confidence
      return b.confidence - a.confidence;
    });
  }

  private generateSuggestions(_hypothesis: string, candidates: ElementCandidate[]): string[] {
    const suggestions: string[] = [];

    if (candidates.length === 0) {
      suggestions.push('Try adding data-testid attributes to elements for more reliable targeting');
      suggestions.push('Consider using more specific text content in the hypothesis');
      suggestions.push('Check if the element exists on the current page');
    } else {
      suggestions.push(`Found ${candidates.length} potential elements using multiple strategies`);
      suggestions.push(`Best match: ${candidates[0].strategy} strategy with ${candidates[0].confidence * 100}% confidence`);
    }

    return suggestions;
  }
}

// Factory function
export function createElementDetector(html: string): ElementDetector {
  return new ElementDetector(html);
}
</file>

<file path="src/infra/dal/analytics.ts">
import type { PrismaClient } from '@prisma/client';
import {
  AnalyticsEventData,
  AnalyticsQuery,
  ExposureStats,
  FunnelAnalysis,
  ConversionRates,
  PurchaseStats,
  FunnelStep
} from '@domain/analytics/types';
import { AnalyticsRepository } from '@domain/analytics/analytics-service';

export class PrismaAnalyticsRepository implements AnalyticsRepository {
  constructor(private prisma: PrismaClient) { }

  async create(eventData: Omit<AnalyticsEventData, 'id' | 'createdAt'>): Promise<AnalyticsEventData> {
    const event = await this.prisma.analyticsEvent.create({
      data: {
        projectId: eventData.projectId,
        experimentId: eventData.experimentId,
        eventType: eventData.eventType,
        sessionId: eventData.sessionId,
        viewId: eventData.viewId,
        properties: eventData.properties as any,
        timestamp: BigInt(eventData.timestamp || Date.now()),
      },
    });

    return this.mapToAnalyticsEventData(event);
  }

  async createMany(events: Omit<AnalyticsEventData, 'id' | 'createdAt'>[]): Promise<AnalyticsEventData[]> {
    // Filter out events with invalid experiment IDs to prevent foreign key violations
    const validEvents = [];
    const invalidEvents = [];

    for (const event of events) {
      if (event.experimentId) {
        // Check if experiment exists
        const experimentExists = await this.prisma.experiment.findUnique({
          where: { id: event.experimentId },
          select: { id: true }
        });

        if (experimentExists) {
          validEvents.push(event);
        } else {
          console.warn(`[ANALYTICS] Skipping event for non-existent experiment: ${event.experimentId}`);
          invalidEvents.push(event);
        }
      } else {
        // Events without experimentId are valid (e.g., general pageview events)
        validEvents.push(event);
      }
    }

    if (validEvents.length === 0) {
      console.warn(`[ANALYTICS] No valid events to create after filtering`);
      return [];
    }

    if (invalidEvents.length > 0) {
      console.warn(`[ANALYTICS] Filtered out ${invalidEvents.length} events with invalid experiment IDs`);
    }

    const createdEvents = await this.prisma.analyticsEvent.createMany({
      data: validEvents.map(event => ({
        projectId: event.projectId,
        experimentId: event.experimentId,
        eventType: event.eventType,
        sessionId: event.sessionId,
        viewId: event.viewId,
        properties: event.properties as any,
        timestamp: BigInt(event.timestamp || Date.now()),
      })),
    });

    // Fetch the created events to return them
    const eventIds = await this.prisma.analyticsEvent.findMany({
      where: {
        projectId: events[0]?.projectId,
        sessionId: events[0]?.sessionId,
        timestamp: {
          gte: BigInt(Math.min(...events.map(e => e.timestamp || Date.now()))),
          lte: BigInt(Math.max(...events.map(e => e.timestamp || Date.now()))),
        },
      },
      orderBy: { createdAt: 'desc' },
      take: createdEvents.count,
    });

    return eventIds.map(event => this.mapToAnalyticsEventData(event));
  }

  async findMany(query: AnalyticsQuery): Promise<AnalyticsEventData[]> {
    const where: any = {
      projectId: query.projectId,
    };

    if (query.experimentId) {
      where.experimentId = query.experimentId;
    }

    if (query.sessionId) {
      where.sessionId = query.sessionId;
    }

    if (query.startDate || query.endDate) {
      where.timestamp = {};
      if (query.startDate) {
        where.timestamp.gte = BigInt(Math.floor(query.startDate.getTime() / 1000));
      }
      if (query.endDate) {
        where.timestamp.lte = BigInt(Math.floor(query.endDate.getTime() / 1000));
      }
    }

    const events = await this.prisma.analyticsEvent.findMany({
      where,
      orderBy: { timestamp: 'desc' },
      take: query.limit || 100,
      skip: query.offset || 0,
    });

    return events.map(event => this.mapToAnalyticsEventData(event));
  }

  async count(query: AnalyticsQuery): Promise<number> {
    const where: any = {
      projectId: query.projectId,
    };

    if (query.experimentId) {
      where.experimentId = query.experimentId;
    }

    if (query.sessionId) {
      where.sessionId = query.sessionId;
    }

    if (query.startDate || query.endDate) {
      where.timestamp = {};
      if (query.startDate) {
        where.timestamp.gte = BigInt(Math.floor(query.startDate.getTime() / 1000));
      }
      if (query.endDate) {
        where.timestamp.lte = BigInt(Math.floor(query.endDate.getTime() / 1000));
      }
    }

    return this.prisma.analyticsEvent.count({ where });
  }

  async getExposureStats(projectId: string, experimentId: string): Promise<ExposureStats[]> {
    // First, get all variants from the experiment
    const experiment = await this.prisma.experiment.findUnique({
      where: { id: experimentId },
      select: { variants: true }
    });

    if (!experiment) {
      return [];
    }

    // Initialize all variants with zero stats
    const variantStats = new Map<string, ExposureStats>();

    // Parse variants from experiment data
    const variants = experiment.variants as any[];
    for (const variant of variants) {
      const variantId = variant.variantId;
      if (variantId) {
        variantStats.set(variantId, {
          experimentId,
          variantId,
          exposures: 0,
          uniqueSessions: 0,
        });
      }
    }

    // Get all exposure events for this experiment
    const exposureEvents = await this.prisma.analyticsEvent.findMany({
      where: {
        projectId,
        experimentId,
        eventType: 'EXPOSURE',
      },
    });

    // Group by variant and count unique sessions
    const variantSessions = new Map<string, Set<string>>();
    const variantExposureCounts = new Map<string, number>();

    for (const event of exposureEvents) {
      const properties = event.properties as any;
      const variantKey = properties.variantKey; // SDK sends variantKey, not variantId

      if (!variantKey) continue;

      if (!variantStats.has(variantKey)) {
        // If we find a variant in events that's not in the experiment, add it
        variantStats.set(variantKey, {
          experimentId,
          variantId: variantKey, // Use variantKey as variantId for the response
          exposures: 0,
          uniqueSessions: 0,
        });
      }

      // Track unique sessions for this variant
      if (!variantSessions.has(variantKey)) {
        variantSessions.set(variantKey, new Set());
        variantExposureCounts.set(variantKey, 0);
      }

      variantSessions.get(variantKey)!.add(event.sessionId);
      variantExposureCounts.set(variantKey, (variantExposureCounts.get(variantKey) || 0) + 1);
    }

    // Fill in actual stats from events
    for (const [variantKey, stats] of variantStats.entries()) {
      const sessions = variantSessions.get(variantKey) || new Set();
      const exposureCount = variantExposureCounts.get(variantKey) || 0;
      
      stats.exposures = exposureCount;
      stats.uniqueSessions = sessions.size;
    }

    return Array.from(variantStats.values());
  }

  async getFunnelAnalysis(projectId: string, experimentId: string): Promise<FunnelAnalysis> {
    // First, find all sessions that have events for this experiment
    const experimentSessions = await this.prisma.analyticsEvent.findMany({
      where: {
        projectId,
        experimentId,
      },
      select: {
        sessionId: true,
      },
      distinct: ['sessionId'],
    });

    const sessionIds = experimentSessions.map(s => s.sessionId);

    if (sessionIds.length === 0) {
      return {
        experimentId,
        variants: [],
        overallStats: {
          totalSessions: 0,
          totalExposures: 0,
          totalConversions: 0,
          overallConversionRate: 0,
        },
      };
    }

    // Get ALL events for these sessions (not just experiment events)
    const events = await this.prisma.analyticsEvent.findMany({
      where: {
        projectId,
        sessionId: {
          in: sessionIds,
        },
      },
      orderBy: { timestamp: 'asc' },
    });

    // Map to AnalyticsEventData format
    const mappedEvents = events.map(event => this.mapToAnalyticsEventData(event));

    // First, find all exposure events to get variant information
    const exposureEvents = mappedEvents.filter(e => e.eventType === 'EXPOSURE');
    console.log('[FUNNEL_DEBUG] Exposure events found:', exposureEvents.length);
    console.log('[FUNNEL_DEBUG] Exposure events:', exposureEvents.map(e => ({
      sessionId: e.sessionId,
      variantKey: (e.properties as any)?.variantKey,
      experimentId: e.experimentId
    })));

    // Create a map of sessionId -> variantId from exposure events
    const sessionToVariant = new Map<string, string>();
    for (const exposure of exposureEvents) {
      const variantKey = (exposure.properties as any)?.variantKey;
      if (variantKey) {
        sessionToVariant.set(exposure.sessionId, variantKey);
      }
    }

    console.log('[FUNNEL_DEBUG] Session to variant mapping:', Array.from(sessionToVariant.entries()));

    // Group events by session and variant
    const sessionsByVariant = new Map<string, Map<string, any[]>>();

    for (const event of mappedEvents) {
      // Get variant for this session from exposure events
      const variantId = sessionToVariant.get(event.sessionId) || 'unknown';

      if (!sessionsByVariant.has(variantId)) {
        sessionsByVariant.set(variantId, new Map());
      }

      const variantSessions = sessionsByVariant.get(variantId)!;
      if (!variantSessions.has(event.sessionId)) {
        variantSessions.set(event.sessionId, []);
      }

      variantSessions.get(event.sessionId)!.push(event);
    }

    // Calculate overall stats first
    const allPageviewSessions = new Set(mappedEvents.filter(e => e.eventType === 'PAGEVIEW').map(e => e.sessionId));
    const allExposureSessions = new Set(mappedEvents.filter(e => e.eventType === 'EXPOSURE').map(e => e.sessionId));
    const allConversionSessions = new Set(mappedEvents.filter(e => e.eventType === 'CONVERSION').map(e => e.sessionId));

    const overallStats = {
      totalSessions: allPageviewSessions.size,
      totalExposures: allExposureSessions.size,
      totalConversions: allConversionSessions.size,
      overallConversionRate: allExposureSessions.size > 0 ? (allConversionSessions.size / allExposureSessions.size) * 100 : 0,
    };

    // Build funnel for each variant
    const variants = Array.from(sessionsByVariant.keys()).map(variantId => {
      const variantSessions = sessionsByVariant.get(variantId)!;
      const variantEvents = Array.from(variantSessions.values()).flat();

      // Count sessions by event type for this variant
      const pageviewSessions = new Set(variantEvents.filter(e => e.eventType === 'PAGEVIEW').map(e => e.sessionId));
      const exposureSessions = new Set(variantEvents.filter(e => e.eventType === 'EXPOSURE').map(e => e.sessionId));
      const conversionSessions = new Set(variantEvents.filter(e => e.eventType === 'CONVERSION').map(e => e.sessionId));

      const pageviewSessionCount = pageviewSessions.size;
      const exposureSessionCount = exposureSessions.size;
      const conversionSessionCount = conversionSessions.size;

      // Build funnel steps for this variant
      const steps: FunnelStep[] = [];

      // Step 1: Sessions (sessions that had at least one pageview)
      steps.push({
        stepName: 'Session',
        eventType: 'PAGEVIEW',
        count: pageviewSessionCount,
        percentage: 100, // Sessions are the baseline
        dropoffRate: 0,
      });

      // Step 2: Exposures (sessions that saw this variant)
      steps.push({
        stepName: 'Exposure',
        eventType: 'EXPOSURE',
        count: exposureSessionCount,
        percentage: exposureSessionCount > 0 ? (exposureSessionCount / pageviewSessionCount) * 100 : 0,
        dropoffRate: pageviewSessionCount > 0 ? ((pageviewSessionCount - exposureSessionCount) / pageviewSessionCount) * 100 : 0,
      });

      // Step 3: Conversions (sessions that converted)
      steps.push({
        stepName: 'Conversion',
        eventType: 'CONVERSION',
        count: conversionSessionCount,
        percentage: conversionSessionCount > 0 ? (conversionSessionCount / pageviewSessionCount) * 100 : 0,
        dropoffRate: exposureSessionCount > 0 ? ((exposureSessionCount - conversionSessionCount) / exposureSessionCount) * 100 : 0,
      });

      const conversionRate = exposureSessionCount > 0 ? (conversionSessionCount / exposureSessionCount) * 100 : 0;

      return {
        variantId,
        steps,
        totalSessions: pageviewSessionCount,
        conversionRate,
      };
    });

    console.log('[FUNNEL_DEBUG] Final variants array:', JSON.stringify(variants, null, 2));
    console.log('[FUNNEL_DEBUG] Overall stats:', JSON.stringify(overallStats, null, 2));

    return {
      experimentId,
      variants,
      overallStats,
    };
  }

  async getConversionRates(projectId: string, experimentId: string): Promise<ConversionRates[]> {
    // First, get all variants from the experiment
    const experiment = await this.prisma.experiment.findUnique({
      where: { id: experimentId },
      select: { variants: true }
    });

    if (!experiment) {
      return [];
    }

    // Initialize all variants with zero stats
    const variantStats = new Map<string, {
      sessions: number;
      conversions: number;
      totalValue: number;
      conversionCount: number;
    }>();

    // Parse variants from experiment data
    const variants = experiment.variants as any[];
    for (const variant of variants) {
      const variantId = variant.variantId;
      if (variantId) {
        variantStats.set(variantId, {
          sessions: 0,
          conversions: 0,
          totalValue: 0,
          conversionCount: 0,
        });
      }
    }

    // First, find all sessions that have events for this experiment
    const experimentSessions = await this.prisma.analyticsEvent.findMany({
      where: {
        projectId,
        experimentId,
      },
      select: {
        sessionId: true,
      },
      distinct: ['sessionId'],
    });

    const sessionIds = experimentSessions.map(s => s.sessionId);

    if (sessionIds.length === 0) {
      return Array.from(variantStats.entries()).map(([variantId]) => ({
        experimentId,
        variantId,
        sessions: 0,
        conversions: 0,
        conversionRate: 0,
        averageValue: 0,
        totalValue: 0,
      }));
    }

    // Get only EXPOSURE and CONVERSION events for these sessions
    const events = await this.prisma.analyticsEvent.findMany({
      where: {
        projectId,
        sessionId: {
          in: sessionIds,
        },
        eventType: {
          in: ['EXPOSURE', 'CONVERSION']
        }
      },
      orderBy: { timestamp: 'asc' },
    });

    // Map to AnalyticsEventData format
    const mappedEvents = events.map(event => this.mapToAnalyticsEventData(event));

    // Group events by variant and session to count unique sessions
    const variantSessions = new Map<string, Set<string>>();
    const variantConversions = new Map<string, Set<string>>();
    const variantValues = new Map<string, number[]>();

    // Initialize maps for all variants
    for (const [variantId] of variantStats.entries()) {
      variantSessions.set(variantId, new Set());
      variantConversions.set(variantId, new Set());
      variantValues.set(variantId, []);
    }

    // Process events
    for (const event of mappedEvents) {
      if (event.eventType === 'EXPOSURE' && event.experimentId === experimentId) {
        // Get variant from exposure event
        const variantKey = (event.properties as any)?.variantKey;
        if (variantKey) {
          if (!variantStats.has(variantKey)) {
            // If we find a variant in events that's not in the experiment, add it
            variantStats.set(variantKey, {
              sessions: 0,
              conversions: 0,
              totalValue: 0,
              conversionCount: 0,
            });
            variantSessions.set(variantKey, new Set());
            variantConversions.set(variantKey, new Set());
            variantValues.set(variantKey, []);
          }
          
          // Track unique sessions that were exposed to this variant
          const sessions = variantSessions.get(variantKey);
          if (sessions) {
            sessions.add(event.sessionId);
          }
        }
      } else if (event.eventType === 'CONVERSION') {
        // For conversions, we need to find which variant this session was exposed to
        // Look for the most recent exposure event for this session in this experiment
        const exposureEvent = mappedEvents
          .filter(e => e.eventType === 'EXPOSURE' && e.experimentId === experimentId && e.sessionId === event.sessionId)
          .sort((a, b) => b.timestamp - a.timestamp)[0];
        
        if (exposureEvent) {
          const variantKey = (exposureEvent.properties as any)?.variantKey;
          if (variantKey) {
            if (!variantStats.has(variantKey)) {
              // If we find a variant in events that's not in the experiment, add it
              variantStats.set(variantKey, {
                sessions: 0,
                conversions: 0,
                totalValue: 0,
                conversionCount: 0,
              });
              variantSessions.set(variantKey, new Set());
              variantConversions.set(variantKey, new Set());
              variantValues.set(variantKey, []);
            }
            
            // Track unique sessions that converted for this variant
            const conversions = variantConversions.get(variantKey);
            const values = variantValues.get(variantKey);
            if (conversions && values) {
              conversions.add(event.sessionId);
              const value = (event.properties as any)?.value || 0;
              values.push(value);
            }
          }
        }
      }
    }

    // Calculate final stats for each variant
    for (const [variantId, stats] of variantStats.entries()) {
      const sessions = variantSessions.get(variantId) || new Set();
      const conversions = variantConversions.get(variantId) || new Set();
      const values = variantValues.get(variantId) || [];

      stats.sessions = sessions.size;
      stats.conversions = conversions.size;
      stats.totalValue = values.reduce((sum, val) => sum + val, 0);
      stats.conversionCount = values.length;
    }

    return Array.from(variantStats.entries()).map(([variantId, stats]) => ({
      experimentId,
      variantId,
      sessions: stats.sessions,
      conversions: stats.conversions,
      conversionRate: stats.sessions > 0 ? (stats.conversions / stats.sessions) * 100 : 0,
      averageValue: stats.conversionCount > 0 ? stats.totalValue / stats.conversionCount : 0,
      totalValue: stats.totalValue,
    }));
  }

  async getPurchaseStats(projectId: string, experimentId: string): Promise<PurchaseStats[]> {
    // First, get all variants from the experiment
    const experiment = await this.prisma.experiment.findUnique({
      where: { id: experimentId },
      select: { variants: true }
    });

    if (!experiment) {
      return [];
    }

    // Initialize all variants with zero stats
    const variantStats = new Map<string, {
      sessions: number;
      purchases: number;
      totalRevenue: number;
      purchaseCount: number;
    }>();

    // Parse variants from experiment data
    const variants = experiment.variants as any[];
    for (const variant of variants) {
      const variantId = variant.variantId;
      if (variantId) {
        variantStats.set(variantId, {
          sessions: 0,
          purchases: 0,
          totalRevenue: 0,
          purchaseCount: 0,
        });
      }
    }

    // First, find all sessions that have events for this experiment
    const experimentSessions = await this.prisma.analyticsEvent.findMany({
      where: {
        projectId,
        experimentId,
      },
      select: {
        sessionId: true,
      },
      distinct: ['sessionId'],
    });

    const sessionIds = experimentSessions.map(s => s.sessionId);

    if (sessionIds.length === 0) {
      return Array.from(variantStats.entries()).map(([variantId]) => ({
        experimentId,
        variantId,
        sessions: 0,
        purchases: 0,
        purchaseRate: 0,
        totalRevenue: 0,
        averageOrderValue: 0,
        revenuePerSession: 0,
      }));
    }

    // Get only EXPOSURE and PURCHASE events for these sessions
    const events = await this.prisma.analyticsEvent.findMany({
      where: {
        projectId,
        sessionId: {
          in: sessionIds,
        },
        eventType: {
          in: ['EXPOSURE', 'PURCHASE']
        }
      },
      orderBy: { timestamp: 'asc' },
    });

    // Map to AnalyticsEventData format
    const mappedEvents = events.map(event => this.mapToAnalyticsEventData(event));

    // Group events by variant and session
    const variantSessions = new Map<string, Set<string>>();
    const variantPurchases = new Map<string, Set<string>>();
    const variantRevenues = new Map<string, number[]>();

    // Initialize maps for all variants
    for (const [variantId] of variantStats.entries()) {
      variantSessions.set(variantId, new Set());
      variantPurchases.set(variantId, new Set());
      variantRevenues.set(variantId, []);
    }

    // Process events
    for (const event of mappedEvents) {
      if (event.eventType === 'EXPOSURE' && event.experimentId === experimentId) {
        // Get variant from exposure event
        const variantKey = (event.properties as any)?.variantKey;
        if (variantKey) {
          if (!variantStats.has(variantKey)) {
            // If we find a variant in events that's not in the experiment, add it
            variantStats.set(variantKey, {
              sessions: 0,
              purchases: 0,
              totalRevenue: 0,
              purchaseCount: 0,
            });
            variantSessions.set(variantKey, new Set());
            variantPurchases.set(variantKey, new Set());
            variantRevenues.set(variantKey, []);
          }

          // Track unique sessions that were exposed to this variant
          const sessions = variantSessions.get(variantKey);
          if (sessions) {
            sessions.add(event.sessionId);
          }
        }
      } else if (event.eventType === 'PURCHASE') {
        // For purchases, we need to find which variant this session was exposed to
        // Look for the most recent exposure event for this session in this experiment
        const exposureEvent = mappedEvents
          .filter(e => e.eventType === 'EXPOSURE' && e.experimentId === experimentId && e.sessionId === event.sessionId)
          .sort((a, b) => b.timestamp - a.timestamp)[0];

        if (exposureEvent) {
          const variantKey = (exposureEvent.properties as any)?.variantKey;
          if (variantKey) {
            if (!variantStats.has(variantKey)) {
              // If we find a variant in events that's not in the experiment, add it
              variantStats.set(variantKey, {
                sessions: 0,
                purchases: 0,
                totalRevenue: 0,
                purchaseCount: 0,
              });
              variantSessions.set(variantKey, new Set());
              variantPurchases.set(variantKey, new Set());
              variantRevenues.set(variantKey, []);
            }

            // Track unique sessions that purchased for this variant
            const purchases = variantPurchases.get(variantKey);
            const revenues = variantRevenues.get(variantKey);
            if (purchases && revenues) {
              purchases.add(event.sessionId);
              const revenue = (event.properties as any)?.revenue || 0;
              revenues.push(revenue);
            }
          }
        }
      }
    }

    // Calculate final stats for each variant
    for (const [variantId, stats] of variantStats.entries()) {
      const sessions = variantSessions.get(variantId) || new Set();
      const purchases = variantPurchases.get(variantId) || new Set();
      const revenues = variantRevenues.get(variantId) || [];

      stats.sessions = sessions.size;
      stats.purchases = purchases.size;
      stats.totalRevenue = revenues.reduce((sum, val) => sum + val, 0);
      stats.purchaseCount = revenues.length;
    }

    return Array.from(variantStats.entries()).map(([variantId, stats]) => ({
      experimentId,
      variantId,
      sessions: stats.sessions,
      purchases: stats.purchases,
      purchaseRate: stats.sessions > 0 ? (stats.purchases / stats.sessions) * 100 : 0,
      totalRevenue: stats.totalRevenue,
      averageOrderValue: stats.purchaseCount > 0 ? stats.totalRevenue / stats.purchaseCount : 0,
      revenuePerSession: stats.sessions > 0 ? stats.totalRevenue / stats.sessions : 0,
    }));
  }

  async getUserJourney(projectId: string, sessionId: string): Promise<AnalyticsEventData[]> {
    const events = await this.prisma.analyticsEvent.findMany({
      where: {
        projectId,
        sessionId,
      },
      orderBy: { timestamp: 'asc' },
    });

    return events.map(event => this.mapToAnalyticsEventData(event));
  }

  /**
   * Get events with variant attribution using database joins
   * This is the core method for database-based attribution
   */
  async getEventsWithAttribution(query: AnalyticsQuery): Promise<AnalyticsEventData[]> {
    const events = await this.prisma.analyticsEvent.findMany({
      where: {
        projectId: query.projectId,
        sessionId: query.sessionId,
        // Filter by experimentId if provided
        ...(query.experimentId && { experimentId: query.experimentId }),
        timestamp: query.startDate || query.endDate ? {
          gte: query.startDate ? BigInt(query.startDate.getTime()) : undefined,
          lte: query.endDate ? BigInt(query.endDate.getTime()) : undefined,
        } : undefined,
      },
      orderBy: { timestamp: 'asc' },
      take: query.limit || 1000,
    });

    // If no experimentId is provided, return all events as-is (for journey view)
    if (!query.experimentId) {
      return events.map(event => this.mapToAnalyticsEventData(event));
    }

    // For specific experiment queries, add variant attribution to non-exposure events
    const eventsWithAttribution = await Promise.all(
      events.map(async (event) => {
        if (event.eventType === 'EXPOSURE' || event.experimentId) {
          // Already has attribution or is an exposure event
          return this.mapToAnalyticsEventData(event);
        }

        // Get the most recent exposure for this session before this event
        const exposure = await this.prisma.analyticsEvent.findFirst({
          where: {
            sessionId: event.sessionId,
            eventType: 'EXPOSURE',
            experimentId: query.experimentId,
            timestamp: { lte: event.timestamp },
          },
          orderBy: { timestamp: 'desc' },
        });

        if (exposure) {
          // Add attribution to the event
          const eventProperties = event.properties as Record<string, any> || {};
          return this.mapToAnalyticsEventData({
            ...event,
            experimentId: exposure.experimentId,
            properties: {
              ...eventProperties,
              variantKey: (exposure.properties as any)?.variantKey,
              attributedFrom: 'database_join',
            },
          });
        }

        // Return null for events that can't be attributed to this experiment
        return null;
      })
    );

    // Filter out null values (events that couldn't be attributed to this experiment)
    return eventsWithAttribution.filter(event => event !== null);
  }

  async getExperimentSessions(projectId: string, experimentId: string, limit: number = 100, offset: number = 0): Promise<{ sessions: { sessionId: string, eventCount: number }[], total: number }> {
    // Use raw SQL to get sessions that have experiment events, with counts of ALL their events
    const result = await this.prisma.$queryRaw<Array<{ sessionId: string, eventCount: bigint }>>`
      SELECT 
        e1."sessionId",
        COUNT(e2.id)::bigint as "eventCount"
      FROM analytics_events e1
      INNER JOIN analytics_events e2 ON e1."sessionId" = e2."sessionId"
      WHERE e1."projectId" = ${projectId}
        AND e1."experimentId" = ${experimentId}
        AND e2."projectId" = ${projectId}
      GROUP BY e1."sessionId"
      ORDER BY e1."sessionId" ASC
      LIMIT ${limit} OFFSET ${offset}
    `;

    // Get total count for pagination
    const totalResult = await this.prisma.$queryRaw<Array<{ count: bigint }>>`
      SELECT COUNT(DISTINCT "sessionId")::bigint as count
      FROM analytics_events
      WHERE "projectId" = ${projectId}
        AND "experimentId" = ${experimentId}
    `;

    return {
      sessions: result.map(s => ({
        sessionId: s.sessionId,
        eventCount: Number(s.eventCount),
      })),
      total: Number(totalResult[0]?.count || 0),
    };
  }

  private mapToAnalyticsEventData(event: any): AnalyticsEventData {
    return {
      id: event.id,
      projectId: event.projectId,
      experimentId: event.experimentId,
      eventType: event.eventType,
      sessionId: event.sessionId,
      viewId: event.viewId,
      properties: event.properties ? JSON.parse(JSON.stringify(event.properties)) : {},
      timestamp: Number(event.timestamp),
      createdAt: event.createdAt,
    };
  }
}
</file>

<file path="src/infra/external/shopify/graphql.ts">
import '@shopify/shopify-api/adapters/node';
import { shopifyApi, ApiVersion, Session } from '@shopify/shopify-api';
import { ProjectDAL } from '../../dal';
import { decrypt } from '../../encryption';

const shopify = shopifyApi({
    apiKey: process.env.SHOPIFY_API_KEY,
    apiSecretKey: process.env.SHOPIFY_API_SECRET!,
    scopes: ['read_products, read_themes'],
    hostName: 'ngrok-tunnel-address',
    apiVersion: ApiVersion.July25,
    isEmbeddedApp: false,

});

const getDefaultProjectInfo = async () => {
    const projectInfo = await ProjectDAL.getProjectById("cmfnzk7mh0001qjm3ujts5g08");

    if (!projectInfo) {
        throw new Error("Project not found");
    }

    if (!projectInfo.isShopify || !projectInfo.accessTokenEnc) {
        throw new Error("Project is not a Shopify store or missing access token");
    }

    // Log all variables to check if they are correct
    console.log("Project info:", projectInfo);
    console.log("Shop domain:", projectInfo.shopDomain);
    console.log("Access token:", projectInfo.accessTokenEnc);
    console.log("Key:", process.env.SHOPIFY_API_KEY);
    console.log("Secret:", process.env.SHOPIFY_API_SECRET);

    const session = new Session({
        id: `offline_${projectInfo.shopDomain}`, // offline token format; if online, use a unique session ID
        shop: projectInfo.shopDomain,
        state: "state",
        isOnline: false, // true if using an online token
        accessToken: decrypt(projectInfo.accessTokenEnc),
    });

    if (!session) {
        throw new Error("Session not found");
    }

    const client = new shopify.clients.Graphql({ session });

    const data = await client.query({
        data: `query GetThemes {
  themes(roles: MAIN, first: 1) {
    edges {
      node {
        id
        name
        role
        themeStoreId
        updatedAt
      }
    }
  }
}
  `,
    }) as any;

    const mainTheme = data.body.data.themes.edges[0].node;
    const themeData = await client.query({
      data: `query GetTheme {
  theme(id: "${mainTheme.id}") {
    id
    name
    role
    files {
      nodes {
        body {
          ... on OnlineStoreThemeFileBodyText {
            content
          }
        }
      }
    }
  }
}
`,
  }) as any;
    console.log(themeData.body.data.theme.files[0]);
    return mainTheme

}


export default getDefaultProjectInfo;
</file>

<file path="src/interfaces/http/analytics/index.ts">
import { FastifyInstance } from 'fastify';
import { serviceContainer } from '@app/container';
import { betterAuthMiddleware } from '../middleware/better-auth';
import { requireProject } from '../middleware/authorization';
import {
  getExposureStatsHandler,
  getEventsHandler,
  getEventCountHandler,
  getUserJourneyHandler,
  getFunnelAnalysisHandler,
  getConversionRatesHandler,
  getPurchaseStatsHandler,
  getExperimentSessionsHandler
} from './handlers';
import {
  getExposureStatsSchema,
  getEventsSchema,
  getEventCountSchema,
  getUserJourneySchema,
  getFunnelAnalysisSchema,
  getConversionRatesSchema,
  getPurchaseStatsSchema,
  getExperimentSessionsSchema
} from './schemas';

export async function analyticsRoutes(fastify: FastifyInstance) {
  console.log('[ANALYTICS_ROUTES] Registering analytics routes...');
  const analyticsService = serviceContainer.getAnalyticsService();

  // Experiment exposure statistics
  fastify.get('/experiments/:experimentId/exposures', {
    schema: getExposureStatsSchema,
    preHandler: [betterAuthMiddleware, requireProject],
    handler: getExposureStatsHandler(analyticsService)
  });

  // Raw events query
  fastify.get('/events', {
    schema: getEventsSchema,
    preHandler: [betterAuthMiddleware, requireProject],
    handler: getEventsHandler(analyticsService)
  });

  // Event count
  fastify.get('/events/count', {
    schema: getEventCountSchema,
    preHandler: [betterAuthMiddleware, requireProject],
    handler: getEventCountHandler(analyticsService)
  });

  // User journey - get all events for a specific session
  fastify.get('/journey/:sessionId', {
    schema: getUserJourneySchema,
    preHandler: [betterAuthMiddleware, requireProject],
    handler: getUserJourneyHandler(analyticsService)
  });
  
  console.log('[ANALYTICS_ROUTES] Analytics routes registered successfully');

  // Funnel analysis for an experiment
  fastify.get('/funnel/:experimentId', {
    schema: getFunnelAnalysisSchema,
    preHandler: [betterAuthMiddleware, requireProject],
    handler: getFunnelAnalysisHandler(analyticsService)
  });

  // Conversion rates for an experiment
  fastify.get('/conversions/:experimentId', {
    schema: getConversionRatesSchema,
    preHandler: [betterAuthMiddleware, requireProject],
    handler: getConversionRatesHandler(analyticsService)
  });

  // Purchase stats for an experiment
  fastify.get('/purchases/:experimentId', {
    schema: getPurchaseStatsSchema,
    preHandler: [betterAuthMiddleware, requireProject],
    handler: getPurchaseStatsHandler(analyticsService)
  });

  // Sessions for an experiment
  fastify.get('/experiments/:experimentId/sessions', {
    schema: getExperimentSessionsSchema,
    preHandler: [betterAuthMiddleware, requireProject],
    handler: getExperimentSessionsHandler(analyticsService)
  });
}
</file>

<file path="src/interfaces/http/middleware/authorization.ts">
import type { FastifyRequest } from 'fastify/types/request.js';
import type { FastifyReply } from 'fastify/types/reply.js';
import '@shared/fastify.d';
import type { ProjectParams, ProjectBody } from '@shared/types';

/**
 * Basic authentication guard middleware
 * Ensures user is authenticated but doesn't require a project
 */
export const requireAuth = async (request: FastifyRequest, reply: FastifyReply) => {
  if (!request.userId) {
    return reply.status(401).send({
      error: 'UNAUTHORIZED',
      message: 'Authentication required'
    });
  }
};

/**
 * Authorization guard middleware that requires a project
 * Ensures all protected routes require projectId ownership
 */
export const requireProject = async (request: FastifyRequest, reply: FastifyReply) => {
  if (!request.userId) {
    return reply.status(401).send({
      error: 'UNAUTHORIZED',
      message: 'Authentication required'
    });
  }

  // If no projectId in request context, user needs to bind a project first
  if (!request.projectId) {
    return reply.status(403).send({
      error: 'FORBIDDEN',
      message: 'No project bound to user. Please connect a project first.'
    });
  }
};

/**
 * Authorization guard for project-specific operations
 * Ensures user owns the specified project
 */
export const requireProjectOwnership = async (request: FastifyRequest, reply: FastifyReply) => {
  if (!request.userId) {
    return reply.status(401).send({
      error: 'UNAUTHORIZED',
      message: 'Authentication required'
    });
  }

  // Extract projectId from route params or body
  const projectId = (request.params as ProjectParams)?.projectId || (request.body as ProjectBody)?.projectId;

  if (!projectId) {
    return reply.status(400).send({
      error: 'BAD_REQUEST',
      message: 'Project ID is required'
    });
  }

  // Check if user owns this project
  const { userService } = await import('@infra/dal/user');
  const ownsProject = await userService.userOwnsProject(request.userId, projectId);

  if (!ownsProject) {
    return reply.status(403).send({
      error: 'FORBIDDEN',
      message: 'Access denied. You do not own this project.'
    });
  }

  // Attach projectId to request context for downstream handlers
  request.projectId = projectId;
};

/**
 * Optional project ownership check
 * Used for routes that can work with or without a specific project
 */
export const optionalProjectOwnership = async (request: FastifyRequest, reply: FastifyReply) => {
  if (!request.userId) {
    return reply.status(401).send({
      error: 'UNAUTHORIZED',
      message: 'Authentication required'
    });
  }

  const projectId = (request.params as ProjectParams)?.projectId || (request.body as ProjectBody)?.projectId;

  if (projectId) {
    const { userService } = await import('@infra/dal/user');
    const ownsProject = await userService.userOwnsProject(request.userId, projectId);

    if (!ownsProject) {
      return reply.status(403).send({
        error: 'FORBIDDEN',
        message: 'Access denied. You do not own this project.'
      });
    }

    request.projectId = projectId;
  }
};
</file>

<file path="src/interfaces/http/project/brandSummary.ts">
import { FastifyInstance } from 'fastify';
import { ProjectDAL } from '@infra/dal';
import { betterAuthMiddleware } from '../middleware/better-auth';
import { requireProject } from '../middleware/authorization';
import { prisma } from '@infra/prisma';
import { JobStatus } from '@prisma/client';
import { analyzeProject } from '@features/brand_analysis';

export async function brandSummaryRoutes(fastify: FastifyInstance) {
    // Start brand summary generation
    fastify.post('/project/:projectId/brand-summary', { preHandler: [betterAuthMiddleware, requireProject] }, async (request, reply) => {
        try {
            const { projectId } = request.params as { projectId: string };

            // Verify project exists and user owns it
            const project = await ProjectDAL.getProjectById(projectId);
            if (!project) {
                return reply.status(404).send({ error: 'Project not found' });
            }

            // Create job
            const job = await ProjectDAL.createBrandSummaryJob(projectId);

            // Start async processing
            processBrandSummary(job.id, projectId, fastify).catch(error => {
                fastify.log.error({ err: error, jobId: job.id }, 'Brand summary failed');
                updateJobStatus(job.id, 'FAILED', undefined, undefined, error.message);
            });

            return reply.status(200).send({
                jobId: job.id,
                status: 'pending',
                message: 'Brand summary generation started'
            });
        } catch (error) {
            fastify.log.error({ err: error }, 'Start brand summary error:');
            return reply.status(500).send({ error: 'Failed to start brand summary' });
        }
    });

    // Get brand summary status
    fastify.get('/project/:projectId/brand-summary/:jobId', { preHandler: [betterAuthMiddleware, requireProject] }, async (request, reply) => {
        try {
            const { projectId, jobId } = request.params as { projectId: string; jobId: string };

            // Verify project exists and user owns it
            const project = await ProjectDAL.getProjectById(projectId);
            if (!project) {
                return reply.status(404).send({ error: 'Project not found' });
            }

            const job = await ProjectDAL.getBrandSummaryJob(jobId);
            if (!job) {
                return reply.status(404).send({ error: 'Job not found' });
            }

            return reply.status(200).send({
                jobId: job.id,
                status: job.status.toLowerCase(),
                progress: job.progress || undefined,
                result: job.result || undefined,
                error: job.error || undefined,
                createdAt: job.createdAt.toISOString(),
                completedAt: job.completedAt?.toISOString(),
            });
        } catch (error) {
            fastify.log.error({ err: error }, 'Get brand summary status error:');
            return reply.status(500).send({ error: 'Failed to get brand summary status' });
        }
    });
}

// Simple async processing function
async function processBrandSummary(jobId: string, projectId: string, fastify: FastifyInstance): Promise<void> {
    try {
        fastify.log.info({ jobId, projectId }, 'Starting brand summary processing');
        
        // Update to running
        await updateJobStatus(jobId, 'RUNNING', 10);

        // Get project
        const project = await ProjectDAL.getProjectById(projectId);
        if (!project) throw new Error('Project not found');

        fastify.log.info({ jobId, shopDomain: project.shopDomain }, 'Running brand analysis');

        // Run brand analysis
        const brandIntelligence = await analyzeProject(projectId, project.shopDomain);

        fastify.log.info({ jobId }, 'Brand analysis completed successfully');

        // Complete job
        await updateJobStatus(jobId, 'COMPLETED', 100, brandIntelligence);

    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        fastify.log.error({ err: error, jobId, projectId }, 'Brand summary processing failed');
        await updateJobStatus(jobId, 'FAILED', undefined, undefined, errorMessage);
    }
}

// Simple job status update
async function updateJobStatus(
    jobId: string,
    status: JobStatus,
    progress?: number,
    result?: any, // Prisma's JsonValue type
    error?: string
): Promise<void> {
    const updateData = {
        status,
        ...(progress !== undefined && { progress }),
        ...(result !== undefined && { result }),
        ...(error !== undefined && { error }),
        ...(status === 'RUNNING' && { startedAt: new Date() }),
        ...((status === 'COMPLETED' || status === 'FAILED') && { completedAt: new Date() })
    };

    await prisma.brandSummaryJob.update({
        where: { id: jobId },
        data: updateData,
    });
}
</file>

<file path="src/services/analytics.ts">
import {
  AnalyticsService,
  SQSConsumerService,
  AnalyticsRepository
} from '@domain/analytics/analytics-service';
import {
  AnalyticsEventData,
  AnalyticsQuery,
  ExposureStats,
  FunnelAnalysis,
  ConversionRates,
  PurchaseStats,
  SQSAnalyticsMessage
} from '@domain/analytics/types';
import { SQSClient, ReceiveMessageCommand, DeleteMessageCommand } from '@aws-sdk/client-sqs';
import { NodeHttpHandler } from '@smithy/node-http-handler';
import https from 'https';
import { ServiceConfig } from '@infra/config/services';

export class AnalyticsServiceImpl implements AnalyticsService {
  constructor(private repository: AnalyticsRepository) {}

  async createEvent(eventData: Omit<AnalyticsEventData, 'id' | 'createdAt'>): Promise<AnalyticsEventData> {
    return this.repository.create(eventData);
  }

  async createEvents(events: Omit<AnalyticsEventData, 'id' | 'createdAt'>[]): Promise<AnalyticsEventData[]> {
    return this.repository.createMany(events);
  }

  async getEvents(query: AnalyticsQuery): Promise<AnalyticsEventData[]> {
    return this.repository.findMany(query);
  }

  async getEventsWithAttribution(query: AnalyticsQuery): Promise<AnalyticsEventData[]> {
    return this.repository.getEventsWithAttribution(query);
  }

  async getEventCount(query: AnalyticsQuery): Promise<number> {
    return this.repository.count(query);
  }

  async getExposureStats(projectId: string, experimentId: string): Promise<ExposureStats[]> {
    return this.repository.getExposureStats(projectId, experimentId);
  }

  async getFunnelAnalysis(projectId: string, experimentId: string): Promise<FunnelAnalysis> {
    return this.repository.getFunnelAnalysis(projectId, experimentId);
  }

  async getConversionRates(projectId: string, experimentId: string): Promise<ConversionRates[]> {
    return this.repository.getConversionRates(projectId, experimentId);
  }

  async getPurchaseStats(projectId: string, experimentId: string): Promise<PurchaseStats[]> {
    return this.repository.getPurchaseStats(projectId, experimentId);
  }

  async getUserJourney(projectId: string, sessionId: string): Promise<AnalyticsEventData[]> {
    return this.repository.getUserJourney(projectId, sessionId);
  }

  async getExperimentSessions(projectId: string, experimentId: string, limit?: number, offset?: number): Promise<{ sessions: { sessionId: string, eventCount: number }[], total: number }> {
    return this.repository.getExperimentSessions(projectId, experimentId, limit, offset);
  }

  async processSQSEvent(message: SQSAnalyticsMessage): Promise<void> {
    try {
      await this.createEvent({
        projectId: message.projectId,
        experimentId: message.experimentId,
        eventType: message.eventType,
        sessionId: message.sessionId,
        viewId: message.viewId,
        properties: message.properties,
        timestamp: message.timestamp,
      });
    } catch (error) {
      console.error('Failed to process SQS event:', error);
      throw error;
    }
  }

  async processSQSBatch(messages: SQSAnalyticsMessage[]): Promise<void> {
    try {
      console.log(`[ANALYTICS] Processing ${messages.length} SQS messages`);
      
      const events = messages.map(message => ({
        projectId: message.projectId,
        experimentId: message.experimentId,
        eventType: message.eventType,
        sessionId: message.sessionId,
        viewId: message.viewId,
        properties: message.properties,
        timestamp: message.timestamp,
      }));
      
      const createdEvents = await this.createEvents(events);
      console.log(`[ANALYTICS] Successfully created ${createdEvents.length} analytics events`);
      
    } catch (error) {
      console.error('Failed to process SQS batch:', error);
      
      // Don't throw error to prevent SQS message from being reprocessed indefinitely
      // The analytics repository now handles invalid experiment IDs gracefully
      if (error instanceof Error && error.message.includes('Foreign key constraint')) {
        console.warn('[ANALYTICS] Foreign key constraint error - some events may have been filtered out');
        return; // Continue processing other batches
      }
      
      // For other errors, still throw to trigger retry mechanism
      throw error;
    }
  }
}

export class SQSConsumerServiceImpl implements SQSConsumerService {
  private isRunningFlag = false;
  private pollInterval: any = null;
  private sqsClient: SQSClient;
  private analyticsService: AnalyticsService;
  private isProcessing = false; // Backpressure flag

  constructor(
    private config: ServiceConfig['sqs'],
    analyticsService: AnalyticsService
  ) {
    // Create custom HTTPS agent with increased socket pool
    const agent = new https.Agent({
      maxSockets: 250, // Increase from default 50
      keepAlive: true,
      // Limit queued requests waiting for a socket
      maxFreeSockets: 10, // Keep 10 idle sockets for reuse
      timeout: 60000, // Socket timeout: 60 seconds
    });

    this.sqsClient = new SQSClient({
      region: config.region,
      credentials: {
        accessKeyId: config.accessKeyId,
        secretAccessKey: config.secretAccessKey,
      },
      requestHandler: new NodeHttpHandler({
        httpsAgent: agent,
        connectionTimeout: 3000,
        requestTimeout: 10000,
        socketAcquisitionWarningTimeout: 3000, // Warn if waiting >3s for socket
      }),
      maxAttempts: 2, // Reduce retries to prevent queue buildup
    });
    this.analyticsService = analyticsService;
  }

  async start(): Promise<void> {
    if (this.isRunningFlag) {
      console.log('SQS Consumer is already running');
      return;
    }

    this.isRunningFlag = true;
    console.log('Starting SQS Consumer...');

    this.pollInterval = (global as any).setInterval(async () => {
      await this.pollMessages();
    }, this.config.pollInterval);

    console.log('SQS Consumer started');
  }

  async stop(): Promise<void> {
    if (!this.isRunningFlag) {
      console.log('SQS Consumer is not running');
      return;
    }

    this.isRunningFlag = false;
    
    if (this.pollInterval) {
      (global as any).clearInterval(this.pollInterval);
      this.pollInterval = null;
    }

    console.log('SQS Consumer stopped');
  }

  isRunning(): boolean {
    return this.isRunningFlag;
  }

  private async pollMessages(): Promise<void> {
    // Skip polling if already processing (backpressure)
    // This is normal with long polling (WaitTimeSeconds: 5)
    if (this.isProcessing) {
      return;
    }

    const startTime = Date.now();

    // Set a timeout to force-reset if something hangs
    const timeoutId = setTimeout(() => {
      console.error('[SQS] TIMEOUT! Poll took longer than 60 seconds - force resetting');
      this.isProcessing = false;
    }, 60000); // 60 second timeout

    try {
      this.isProcessing = true;

      const command = new ReceiveMessageCommand({
        QueueUrl: this.config.queueUrl,
        MaxNumberOfMessages: this.config.batchSize,
        VisibilityTimeout: this.config.visibilityTimeout,
        WaitTimeSeconds: 5, // Long polling
      });

      const response = await this.sqsClient.send(command);

      if (!response.Messages || response.Messages.length === 0) {
        // Queue is empty - no need to log every time
        return;
      }

      console.log(`[SQS] Received ${response.Messages.length} messages from queue`);

      // Process messages in batch
      const messages: SQSAnalyticsMessage[] = [];
      const receiptHandles: string[] = [];
      const malformedMessages: any[] = [];

      for (const message of response.Messages) {
        try {
          const rawMessage = JSON.parse(message.Body || '{}');

          // Validate that this looks like an analytics message
          if (this.isValidAnalyticsMessage(rawMessage)) {
            const analyticsMessage: SQSAnalyticsMessage = rawMessage;
            messages.push(analyticsMessage);
            receiptHandles.push(message.ReceiptHandle || '');
          } else {
            // Log malformed message for debugging
            console.log('[SQS] Skipping malformed message:', {
              messageId: message.MessageId,
              body: rawMessage,
              reason: 'Invalid analytics message format'
            });
            malformedMessages.push({
              messageId: message.MessageId,
              body: rawMessage,
              timestamp: new Date().toISOString()
            });
            // Delete malformed messages
            if (message.ReceiptHandle) {
              await this.deleteMessage(message.ReceiptHandle);
            }
          }
        } catch (error) {
          console.error('[SQS] Failed to parse message:', error);
          console.log('[SQS] Raw message body:', message.Body);
          // Delete malformed messages
          if (message.ReceiptHandle) {
            await this.deleteMessage(message.ReceiptHandle);
          }
        }
      }

      if (malformedMessages.length > 0) {
        console.log(`[SQS] Filtered out ${malformedMessages.length} malformed messages`);
      }

      if (messages.length > 0) {
        const processingStart = Date.now();
        await this.analyticsService.processSQSBatch(messages);
        console.log(`[SQS] Batch processing took ${Date.now() - processingStart}ms`);

        // Delete successfully processed messages
        const deleteStart = Date.now();
        for (const receiptHandle of receiptHandles) {
          await this.deleteMessage(receiptHandle);
        }
        console.log(`[SQS] Deletion took ${Date.now() - deleteStart}ms`);
      } else {
        console.log('[SQS] No valid messages to process');
      }

      const totalTime = Date.now() - startTime;
      console.log(`[SQS] Poll completed in ${totalTime}ms`);
    } catch (error) {
      console.error('[SQS] Error polling SQS messages:', error);
      const totalTime = Date.now() - startTime;
      console.error(`[SQS] Poll failed after ${totalTime}ms`);
    } finally {
      // Clear the timeout and reset processing flag
      clearTimeout(timeoutId);
      this.isProcessing = false;
    }
  }

  private isValidAnalyticsMessage(message: any): boolean {
    // Check if the message has the required fields for analytics
    return (
      message &&
      typeof message.projectId === 'string' &&
      typeof message.eventType === 'string' &&
      typeof message.sessionId === 'string' &&
      typeof message.timestamp === 'number' &&
      message.properties &&
      typeof message.properties === 'object' &&
      // Validate eventType is one of our supported types
      ['EXPOSURE', 'PAGEVIEW', 'CONVERSION', 'PURCHASE', 'CUSTOM'].includes(message.eventType)
    );
  }

  private async deleteMessage(receiptHandle: string): Promise<void> {
    try {
      const command = new DeleteMessageCommand({
        QueueUrl: this.config.queueUrl,
        ReceiptHandle: receiptHandle,
      });
      await this.sqsClient.send(command);
    } catch (error) {
      console.error('Failed to delete SQS message:', error);
    }
  }

}

export function createAnalyticsService(repository: AnalyticsRepository): AnalyticsService {
  return new AnalyticsServiceImpl(repository);
}

// Export the interfaces for use in handlers and other services
export type { AnalyticsService, SQSConsumerService } from '@domain/analytics/analytics-service';

export function createSQSConsumerService(
  config: ServiceConfig['sqs'],
  analyticsService: AnalyticsService
): SQSConsumerService {
  return new SQSConsumerServiceImpl(config, analyticsService);
}
</file>

<file path="src/shared/ai-config.ts">
// Shared AI Configuration
import { getServiceConfig } from '@infra/config/services';

export interface AIConfig {
  model: string;
  temperature: number;
  maxTokens: number;
  apiKey: string;
}

export function getAIConfig(): AIConfig {
  const config = getServiceConfig();
  return {
    model: config.google?.model || 'gemini-2.5-pro',
    temperature: config.google?.temperature || 0.7,
    maxTokens: config.google?.maxTokens || 1000,
    apiKey: config.google?.apiKey || '',
  };
}

// Common AI SDK configurations
export const AI_CONFIGS = {
  STREAMING: {
    temperature: 0.7,
    maxTokens: 1000,
  },
  STRUCTURED_OUTPUT: {
    temperature: 0.3,
    maxTokens: 2000,
  },
  ANALYSIS: {
    temperature: 0.5,
    maxTokens: 1500,
  },
  VARIANT_GENERATION: {
    temperature: 0.7,
    maxTokens: 3000,
  },
} as const;

// Get AI config for variant generation (uses Gemini 2.5 Pro)
export function getVariantGenerationAIConfig(): AIConfig {
  const config = getServiceConfig();
  return {
    model: 'gemini-2.5-pro', // Use Gemini 2.5 Pro for variant generation
    temperature: config.google?.temperature || 0.3,
    maxTokens: config.google?.maxTokens || 3000,
    apiKey: config.google?.apiKey || '',
  };
}
</file>

<file path="src/shared/fastify.d.ts">
/**
 * Fastify Type Augmentation
 * 
 * This file extends Fastify's built-in types to include our custom properties.
 * This is the proper way to extend FastifyRequest in TypeScript.
 */

import 'fastify';
import type { DiagnosticsService } from '../domain/analytics/diagnostics';

declare module 'fastify' {
  interface FastifyRequest {
    user?: {
      sub: string; // Auth0 user ID
      email: string;
      email_verified: boolean;
      project?: {
        id: string;
        shopDomain: string;
        brandAnalysis: any;
      } | null;
    };
    userId?: string; // Our internal user ID
    projectId?: string; // User's project ID
  }

  interface FastifyInstance {
    diagnosticsService: DiagnosticsService;
  }
}
</file>

<file path="src/shared/types.ts">
/**
 * Shared Type Definitions
 * 
 * This file contains all shared types used across the application.
 * Following Clean Architecture, these are framework-agnostic types.
 */

// Request parameter types
export interface ProjectParams {
  projectId: string;
}

// Request body types
export interface ProjectBody {
  projectId?: string;
}

// User context types
export interface UserContext {
  userId: string;
  projectId?: string;
}

// Auth0 user types
export interface Auth0User {
  id: string;
  email: string;
  project?: {
    id: string;
    shopDomain: string;
  };
}

// API response types
export interface ApiResponse<T = unknown> {
  data?: T;
  error?: string;
  message?: string;
}

export interface ApiError {
  error: string;
  message: string;
  details?: unknown;
}

// DSL Types for Experiments
export type ExperimentStatusType = 'draft' | 'running' | 'paused' | 'finished';

export type VariantId = 'A' | 'B' | 'C';

export type RenderPosition = 'inner' | 'outer' | 'before' | 'after' | 'append' | 'prepend';

export type ApplyMode = 'first' | 'all';

export interface ExperimentMatch {
  host?: string;
  path: string;
}

export interface ExperimentTraffic {
  A: number;
  B: number;
  C: number;
}

export interface ExperimentAssignment {
  cookieName: string;
  ttlDays: number;
}

export interface ExperimentRuntime {
  minDays: number;
  minSessionsPerVariant: number;
  endAt?: string; // ISO date string
}

export interface ExperimentAnalytics {
  posthog: {
    enabled: boolean;
    host: string;
  };
  eventProps: string[];
}

export interface ExperimentGuardrails {
  watch: ('lcp' | 'js_errors' | 'cls')[];
}

export interface VariantRender {
  position: RenderPosition;
  html: string;
  css?: string;
  js?: string;
  oncePerResponse?: boolean;
}

export interface Variant {
  mode: 'render';
  render: VariantRender;
}

export interface ExperimentTarget {
  selector: string;
  apply: ApplyMode;
  variants: Record<VariantId, Variant>;
}

export interface ExperimentKPI {
  primary: string;
  secondary?: string[];
}

export interface ExperimentDSL {
  experimentId: string;
  projectId: string;
  name: string;
  status: ExperimentStatusType;
  match: ExperimentMatch;
  traffic: ExperimentTraffic;
  assignment: ExperimentAssignment;
  targets: ExperimentTarget[];
  kpi: ExperimentKPI;
  runtime: ExperimentRuntime;
  analytics: ExperimentAnalytics;
  guardrails?: ExperimentGuardrails;
}

// Validation Error Types
export type ValidationErrorCode =
  | 'INVALID_DSL_STRUCTURE'
  | 'INVALID_TRAFFIC'
  | 'INVALID_SELECTOR'
  | 'UNSAFE_HTML'
  | 'UNSCOPED_CSS'
  | 'LIMIT_EXCEEDED'
  | 'UNSAFE_OUTER_TARGET'
  | 'INVALID_VARIANT_COUNT'
  | 'INVALID_TARGET_COUNT'
  | 'INVALID_HTML_SIZE'
  | 'INVALID_CSS_SIZE'
  | 'INVALID_DSL_SIZE'
  | 'INVALID_ANALYTICS_HOST';

export interface ValidationError {
  code: ValidationErrorCode;
  message: string;
  field?: string;
  details?: unknown;
}

export interface ValidationResult {
  isValid: boolean;
  errors: ValidationError[];
}

// PostHog Analytics Types
export interface VariantMetrics {
  variantId: string;
  sessions: number;
  primaryKPI: {
    name: string;
    count: number;
    rate: number;
  };
  guardrails?: {
    lcp?: 'normal' | 'elevated';
    jsErrors?: 'normal' | 'elevated';
    cls?: 'normal' | 'elevated';
  };
}

export interface ExperimentStatus {
  state: 'draft' | 'running' | 'paused' | 'finished';
  traffic: Record<string, number>;
  variants: VariantMetrics[];
  leader?: string;
  liftVsA?: number;
  meta: {
    timeframe: {
      start: string;
      end: string;
    };
    denominator: 'pageviews';
    totalSessions: number;
  };
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "moduleResolution": "bundler",
    "lib": ["ES2022"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "resolveJsonModule": true,
    "incremental": true,
    "tsBuildInfoFile": "./dist/.tsbuildinfo",
    "types": ["node"],
    "typeRoots": ["./node_modules/@types", "./src/shared"],
    "baseUrl": "./src",
    "paths": {
      "@app/*": ["app/*"],
      "@config/*": ["config/*"],
      "@domain/*": ["domain/*"],
      "@features/*": ["features/*"],
      "@infra/*": ["infra/*"],
      "@interfaces/*": ["interfaces/*"],
      "@jobs/*": ["jobs/*"],
      "@services/*": ["services/*"],
      "@shared/*": ["shared/*"],
      "@tests/*": ["tests/*"]
    }
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
</file>

<file path="src/domain/agent/tools/get-project-info.ts">
// @ts-nocheck 
// Get Project Info Tool
import { tool } from 'ai';
import { createProjectInfoService, type ProjectInfoService } from '@services/project-info';
import type { ProjectInfo } from '../types';
import { getProjectInfoSchema } from './schemas';

class GetProjectInfoExecutor {
  private projectInfoService: ProjectInfoService;
  private projectId: string;

  constructor(projectId: string) {
    this.projectInfoService = createProjectInfoService();
    this.projectId = projectId;
  }

  private async getProjectInfo(projectId: string): Promise<ProjectInfo> {
    return await this.projectInfoService.getProjectInfo(projectId);
  }

  async execute(input: { projectId?: string }): Promise<ProjectInfo> {
    console.log(`[PROJECT_INFO] Using project ID: ${this.projectId}`);
    return await this.getProjectInfo(this.projectId);
  }
}

export function createGetProjectInfoTool(projectId: string) {
  const executor = new GetProjectInfoExecutor(projectId);

  return tool({
    description: 'Get detailed information about the current project including store details and experiment statistics',
    inputSchema: getProjectInfoSchema,
    execute: async (input) => {
      try {
        return await executor.execute(input);
      } catch (error) {
        throw new Error(error instanceof Error ? error.message : 'Failed to fetch project information');
      }
    },
  });
}
</file>

<file path="src/infra/dal/user.ts">
import { prisma } from '@infra/prisma';
import type { User as PrismaUser, Project } from '@prisma/client';

// Use Prisma-generated types as the source of truth
export type User = PrismaUser & {
  project?: Pick<Project, 'id' | 'shopDomain' | 'brandAnalysis'>;
};

/**
 * User service for database operations
 * Handles all user-related database logic
 */
export class UserService {
  /**
   * Get user by Better Auth ID
   */
  async getUserByBetterAuthId(betterAuthId: string): Promise<User | null> {
    const user = await prisma.user.findUnique({
      where: { id: betterAuthId },
      include: { project: true },
    });

    return user as User | null;
  }

  /**
   * Get or create user from Better Auth payload
   * Creates user on first login
   */
  async getOrCreateUser(betterAuthId: string, email: string, name: string): Promise<User> {
    // Try to find existing user
    let user = await prisma.user.findUnique({
      where: { id: betterAuthId },
      include: { project: true },
    });

    if (!user) {
      // Create new user on first login
      user = await prisma.user.create({
        data: {
          id: betterAuthId,
          email,
          name,
        },
        include: { project: true },
      });
    } else {
      // Update user data if it has changed
      const updates: any = {};
      if (user.email !== email) updates.email = email;
      if (user.name !== name) updates.name = name;

      if (Object.keys(updates).length > 0) {
        user = await prisma.user.update({
          where: { id: user.id },
          data: updates,
          include: { project: true },
        });
      }
    }

    return user as User;
  }

  /**
   * Get user by Auth0 ID (DEPRECATED - for migration purposes)
   */
  async getUserByAuth0Id(auth0Id: string): Promise<User | null> {
    const user = await prisma.user.findUnique({
      where: { auth0Id },
      include: { project: true },
    });

    return user as User | null;
  }

  /**
   * Get user by ID with project details
   */
  async getUserById(userId: string): Promise<User | null> {
    const user = await prisma.user.findUnique({
      where: { id: userId },
      include: { project: true },
    });

    return user as User | null;
  }

  /**
   * Get user by email
   */
  async getUserByEmail(email: string): Promise<User | null> {
    const user = await prisma.user.findUnique({
      where: { email },
      include: { project: true },
    });

    return user as User | null;
  }

  /**
   * Update user email
   */
  async updateUserEmail(userId: string, email: string): Promise<User> {
    const user = await prisma.user.update({
      where: { id: userId },
      data: { email },
      include: { project: true },
    });

    return user as User;
  }

  /**
   * Delete user
   */
  async deleteUser(userId: string): Promise<void> {
    await prisma.user.delete({
      where: { id: userId },
    });
  }

  /**
   * Create a project for a user (for non-Shopify stores during registration)
   */
  async createProjectForUser(userId: string, websiteUrl: string, isShopify: boolean = false): Promise<User> {
    // Check if user exists
    const existingUser = await prisma.user.findUnique({
      where: { id: userId },
      include: { project: true },
    });

    if (!existingUser) {
      throw new Error('User not found');
    }

    // If user already has a project, throw an error (shouldn't happen during registration)
    if (existingUser.project) {
      throw new Error('User already has a project');
    }

    // Create a new project for the user
    const user = await prisma.user.update({
      where: { id: userId },
      data: {
        project: {
          create: {
            shopDomain: websiteUrl,
            isShopify,
            accessTokenEnc: null, // No token needed for non-Shopify stores
          },
        },
      },
      include: { project: true },
    });

    return user as User;
  }

  /**
   * Bind a project to a user (single project rule)
   * This will create a new project or update the existing one
   */
  async bindProjectToUser(userId: string, shopDomain: string, accessTokenEnc: string): Promise<User> {
    // Check if user exists
    const existingUser = await prisma.user.findUnique({
      where: { id: userId },
      include: { project: true },
    });

    if (!existingUser) {
      throw new Error('User not found');
    }

    // If user already has a project, update it; otherwise create a new one
    const user = await prisma.user.update({
      where: { id: userId },
      data: {
        project: existingUser.project
          ? {
              update: {
                shopDomain,
                accessTokenEnc,
                isShopify: true, // Mark as Shopify store when binding via OAuth
              },
            }
          : {
              create: {
                shopDomain,
                accessTokenEnc,
                isShopify: true, // Mark as Shopify store when binding via OAuth
              },
            },
      },
      include: { project: true },
    });

    return user as User;
  }

  /**
   * Get user's project ID
   */
  async getUserProjectId(userId: string): Promise<string | null> {
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: { project: { select: { id: true } } },
    });

    return user?.project?.id || null;
  }

  /**
   * Check if user owns a specific project
   */
  async userOwnsProject(userId: string, projectId: string): Promise<boolean> {
    const user = await prisma.user.findUnique({
      where: { 
        id: userId,
        project: { id: projectId },
      },
      select: { id: true },
    });

    return !!user;
  }
}

export const userService = new UserService();
</file>

<file path="src/infra/external/cloudflare/types.ts">
// Cloudflare Publisher Types
import type { InjectPosition } from '@prisma/client';

export interface CloudflareConfig {
  accountId: string;
  apiToken: string;
  namespaceId: string;
}

export interface PublishedExperiment {
  id: string;
  projectId: string;
  name: string;
  status: string;
  oec: string;
  traffic: Record<string, number>;
  variants: Record<string, PublishedVariant>;
  targetUrls?: string[]; // URL patterns for targeting
  targeting?: {
    match?: 'all' | 'any';
    timeoutMs?: number;
    rules: Array<
      | { type: 'selectorExists'; selector: string }
      | { type: 'selectorNotExists'; selector: string }
      | { type: 'textContains'; selector: string; text: string }
      | { type: 'attrEquals'; selector: string; attr: string; value: string }
      | { type: 'meta'; name: string; value: string; by?: 'name' | 'property' }
      | { type: 'cookie'; name: string; value: string }
      | { type: 'localStorage'; key: string; value: string }
      | { type: 'urlParam'; name: string; value: string }
    >;
  };
}

export interface PublishedVariant {
  selector: string;
  html: string;
  css: string;
  js: string; // Always included, even if empty
  position: InjectPosition;
}

export interface CloudflarePublishResult {
  success: boolean;
  experimentId: string;
  key?: string;
  error?: string;
}
</file>

<file path="src/interfaces/http/user/index.ts">
import type { FastifyInstance } from 'fastify/types/instance.js';
import '@shared/fastify.d';
import { betterAuthMiddleware } from '@interfaces/http/middleware/better-auth';
import { requireAuth } from '@interfaces/http/middleware/authorization';
import { userService } from '@infra/dal/user';

export async function userRoutes(fastify: FastifyInstance) {

    /**
     * Get user by ID
     */
    fastify.get('/:userId', { preHandler: [betterAuthMiddleware, requireAuth] }, async (request, reply) => {
        try {
            const { userId } = request.params as { userId: string };

            const user = await userService.getUserById(userId);

            if (!user) {
                return reply.status(404).send({
                    error: 'NOT_FOUND',
                    message: 'User not found',
                });
            }

            return {
                user: {
                    id: user.id,
                    email: user.email,
                    projectId: user.project?.id,
                },
                project: user.project ? {
                    id: user.project.id,
                    shopDomain: user.project.shopDomain,
                } : null,
            };

        } catch (error: unknown) {
            fastify.log.error({ err: error }, 'Get user error:');
            return reply.status(500).send({
                error: 'INTERNAL_ERROR',
                message: 'Failed to fetch user information',
            });
        }
    });

    /**
     * Update user email
     */
    fastify.patch('/:userId', { preHandler: [betterAuthMiddleware, requireAuth] }, async (request, reply) => {
        try {
            const { userId } = request.params as { userId: string };
            const { email } = request.body as { email: string };

            if (!email) {
                return reply.status(400).send({
                    error: 'BAD_REQUEST',
                    message: 'Email is required',
                });
            }

            // Validate email format
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!emailRegex.test(email)) {
                return reply.status(400).send({
                    error: 'BAD_REQUEST',
                    message: 'Invalid email format',
                });
            }

            const user = await userService.updateUserEmail(userId, email);

            return {
                message: 'User updated successfully',
                user: {
                    id: user.id,
                    email: user.email,
                    projectId: user.project?.id,
                },
            };

        } catch (error: unknown) {
            fastify.log.error({ err: error }, 'Update user error:');
            return reply.status(500).send({
                error: 'INTERNAL_ERROR',
                message: 'Failed to update user',
            });
        }
    });

    /**
     * Delete user
     */
    fastify.delete('/:userId', { preHandler: [betterAuthMiddleware, requireAuth] }, async (request, reply) => {
        try {
            const { userId } = request.params as { userId: string };

            await userService.deleteUser(userId);

            return {
                message: 'User deleted successfully',
            };

        } catch (error: unknown) {
            fastify.log.error({ err: error }, 'Delete user error:');
            return reply.status(500).send({
                error: 'INTERNAL_ERROR',
                message: 'Failed to delete user',
            });
        }
    });
}
</file>

<file path="src/interfaces/http/screenshots.ts">
// Screenshot serving routes
import type { FastifyInstance } from 'fastify/types/instance.js';
import { serviceContainer } from '@app/container';
import { prisma } from '@infra/prisma';

export async function screenshotRoutes(fastify: FastifyInstance) {
  // Serve database screenshots by ID
  fastify.get('/screenshots/db/:screenshotId', async (request, reply) => {
    try {
      const { screenshotId } = request.params as { screenshotId: string };
      
      // Validate screenshotId format (should be a cuid)
      if (!screenshotId || screenshotId.length < 20) {
        return reply.code(400).send({ error: 'Invalid screenshot ID' });
      }

      const screenshotStorage = serviceContainer.getScreenshotStorageService();
      const screenshot = await screenshotStorage.getScreenshotById(screenshotId);
      
      if (!screenshot) {
        return reply.code(404).send({ error: 'Screenshot not found' });
      }
      
      // Set appropriate headers
      reply.type(screenshot.contentType);
      reply.header('Cache-Control', 'public, max-age=3600'); // Cache for 1 hour
      
      // Send the screenshot data
      return reply.send(screenshot.data);
    } catch (error) {
      console.error(`[SCREENSHOT_ROUTES] Error serving database screenshot:`, error);
      return reply.code(404).send({ error: 'Screenshot not found' });
    }
  });

  // List screenshots for a project
  fastify.get('/screenshots/project/:projectId', async (request, reply) => {
    try {
      const { projectId } = request.params as { projectId: string };

      const screenshots = await prisma.screenshot.findMany({
        where: { 
          projectId,
          expiresAt: { gt: new Date() } // Only non-expired screenshots
        },
        select: {
          id: true,
          pageType: true,
          url: true,
          createdAt: true,
          fileSize: true,
          viewportWidth: true,
          viewportHeight: true,
          fullPage: true,
          quality: true
        },
        orderBy: { createdAt: 'desc' }
      });

      return reply.send({
        projectId,
        screenshots: screenshots.map(s => ({
          ...s,
          viewUrl: `/screenshots/db/${s.id}`
        }))
      });
    } catch (error) {
      console.error(`[SCREENSHOT_ROUTES] Error listing project screenshots:`, error);
      return reply.code(500).send({ error: 'Failed to list screenshots' });
    }
  });

  // Serve the latest screenshot for a project and page type
  fastify.get('/screenshots/project/:projectId/:pageType', async (request, reply) => {
    try {
      const { projectId, pageType } = request.params as {
        projectId: string;
        pageType: 'home' | 'pdp' | 'about' | 'other'
      };

      const screenshot = await prisma.screenshot.findFirst({
        where: { 
          projectId,
          pageType,
          expiresAt: { gt: new Date() }
        },
        orderBy: { createdAt: 'desc' }
      });

      if (!screenshot) {
        return reply.code(404).send({ error: 'Screenshot not found' });
      }
      
      // Redirect to the screenshot ID endpoint
      return reply.redirect(`/screenshots/db/${screenshot.id}`);
    } catch (error) {
      console.error(`[SCREENSHOT_ROUTES] Error serving latest screenshot:`, error);
      return reply.code(500).send({ error: 'Failed to serve screenshot' });
    }
  });

  // Debug endpoint to inspect screenshot data
  fastify.get('/screenshots/debug/:screenshotId', async (request, reply) => {
    try {
      const { screenshotId } = request.params as { screenshotId: string };

      const screenshot = await prisma.screenshot.findUnique({
        where: { id: screenshotId },
        select: {
          id: true,
          pageType: true,
          url: true,
          createdAt: true,
          fileSize: true,
          data: true,
          htmlContent: true
        }
      });

      if (!screenshot) {
        return reply.code(404).send({ error: 'Screenshot not found' });
      }
      
      // Decode the first part of the screenshot to see what it contains
      const dataBuffer = Buffer.from(screenshot.data);
      const firstBytes = dataBuffer.slice(0, 50);
      const isBase64 = screenshot.data.length > 0 && /^[A-Za-z0-9+/]*={0,2}$/.test(screenshot.data.toString());
      
      return reply.send({
        id: screenshot.id,
        pageType: screenshot.pageType,
        url: screenshot.url,
        createdAt: screenshot.createdAt,
        fileSize: screenshot.fileSize,
        dataSize: screenshot.data.length,
        isBase64: isBase64,
        firstBytes: Array.from(firstBytes).map(b => b.toString(16).padStart(2, '0')).join(' '),
        firstBytesAsText: firstBytes.toString('utf8', 0, Math.min(50, firstBytes.length)),
        htmlLength: screenshot.htmlContent?.length || 0,
        htmlPreview: screenshot.htmlContent?.substring(0, 200) || 'No HTML content'
      });
    } catch (error) {
      console.error(`[SCREENSHOT_ROUTES] Error debugging screenshot:`, error);
      return reply.code(500).send({ error: 'Failed to debug screenshot' });
    }
  });

  // Health check for screenshots
  fastify.get('/screenshots/health', async (_request, reply) => {
    return reply.send({ 
      status: 'ok', 
      message: 'Screenshot service is running',
      timestamp: new Date().toISOString()
    });
  });
}
</file>

<file path="src/interfaces/http/shopify.ts">
import type { FastifyInstance } from 'fastify/types/instance.js';
import '@shared/fastify.d';
import { betterAuthMiddleware } from '@interfaces/http/middleware/better-auth';
import { shopifyOAuth, shopify } from '@infra/external/shopify';
import { userService } from '@infra/dal/user';

export async function shopifyRoutes(fastify: FastifyInstance) {
  /**
   * Generate Shopify OAuth URL for store connection (for authenticated users)
   */
  fastify.post('/auth/shopify/connect', { preHandler: [betterAuthMiddleware] }, async (request, reply) => {
    try {
      const { shop } = request.body as { shop: string };

      if (!shop) {
        return reply.status(400).send({
          error: 'BAD_REQUEST',
          message: 'Shop domain is required',
        });
      }

      // Normalize shop domain
      const normalizedShop = shopify.normalizeShopDomain(shop);
      
      // Generate OAuth URL
      const { oauthUrl, state } = shopifyOAuth.generateAuthenticatedOAuthUrl(normalizedShop, request.userId!);

      return {
        oauthUrl,
        state,
        shop: normalizedShop,
      };

    } catch (error: unknown) {
      fastify.log.error({ err: error }, 'Shopify connect URL generation error:');

      if (error instanceof Error && error.message.includes('Invalid shop domain')) {
        return reply.status(400).send({
          error: 'BAD_REQUEST',
          message: error.message,
        });
      }

      return reply.status(500).send({
        error: 'INTERNAL_ERROR',
        message: 'Failed to generate Shopify OAuth URL',
      });
    }
  });

  /**
   * Shopify OAuth callback endpoint (for authenticated users)
   */
  fastify.get('/auth/shopify/callback', { preHandler: [betterAuthMiddleware] }, async (request, reply) => {
    try {
      // Validate OAuth callback parameters
      const validation = shopify.validateCallbackParams(request.query as Record<string, string>);
      
      if (!validation.isValid) {
        return reply.status(400).send({
          error: 'BAD_REQUEST',
          message: validation.error,
        });
      }

      const { code, shop, hmac, state } = validation.params!;

      // Handle OAuth callback
      const { shopProfile, encryptedToken } = await shopifyOAuth.handleAuthenticatedCallback(
        code, shop, hmac, state, request.userId!
      );
      
      // Bind project to user
      const user = await userService.bindProjectToUser(
        request.userId!,
        shopProfile.myshopify_domain,
        encryptedToken
      );

      // Return success response
      return {
        message: 'Shopify store connected successfully',
        shop: {
          id: shopProfile.id,
          name: shopProfile.name,
          domain: shopProfile.myshopify_domain,
          email: shopProfile.email,
          planName: shopProfile.planName,
          currency: shopProfile.currency,
          timezone: shopProfile.timezone,
          country: shopProfile.country,
        },
        project: user.project,
      };

    } catch (error: unknown) {
      fastify.log.error({ err: error }, 'Shopify OAuth callback error:');

      // Handle specific error cases
      if (error instanceof Error) {
        if (error.message.includes('already has a project')) {
          return reply.status(409).send({
            error: 'CONFLICT',
            message: error.message,
          });
        }

        if (error.message.includes('Invalid or expired state parameter')) {
          return reply.status(400).send({
            error: 'BAD_REQUEST',
            message: error.message,
          });
        }

        if (error.message.includes('Failed to exchange code')) {
          return reply.status(400).send({
            error: 'BAD_REQUEST',
            message: 'Invalid authorization code or shop domain',
          });
        }

        if (error.message.includes('Failed to fetch shop profile')) {
          return reply.status(400).send({
            error: 'BAD_REQUEST',
            message: 'Failed to fetch shop information. Please check your permissions.',
          });
        }
      }

      return reply.status(500).send({
        error: 'INTERNAL_ERROR',
        message: 'Failed to connect Shopify store',
      });
    }
  });
}
</file>

<file path="src/services/index.ts">
export * from './experiment-publisher';
export * from './project-info';
export * from './screenshot-storage';
export * from './screenshot-analytics';
export * from './variant-job-processor';
export * from './job-cleanup';
export * from './analytics';
export * from './background-services';
</file>

<file path="src/services/screenshot-storage.ts">
// Screenshot Storage Service - Refactored to use ScreenshotDAL
import { ScreenshotDAL, type ScreenshotOptions } from '@infra/dal/screenshot';

export type { ScreenshotOptions } from '@infra/dal/screenshot';

export interface ScreenshotStorageService {
  getScreenshot(
    projectId: string,
    pageType: 'home' | 'pdp' | 'about' | 'other',
    options: ScreenshotOptions
  ): Promise<string | null>;

  getScreenshotWithHtml(
    projectId: string,
    pageType: 'home' | 'pdp' | 'about' | 'other',
    options: ScreenshotOptions
  ): Promise<{ screenshot: string | null; html: string | null }>;

  saveScreenshot(
    projectId: string,
    pageType: 'home' | 'pdp' | 'about' | 'other',
    url: string,
    options: ScreenshotOptions,
    screenshotData: string,
    htmlContent?: string,
    markdownContent?: string,
    variantId?: string
  ): Promise<string>;

  cleanupExpiredScreenshots(): Promise<number>;

  getScreenshotStats(projectId: string): Promise<{
    totalScreenshots: number;
    totalSize: number;
    accessCount: number;
  }>;

  getScreenshotById(screenshotId: string): Promise<{
    data: Buffer;
    contentType: string;
  } | null>;
}

export class ScreenshotStorageServiceImpl implements ScreenshotStorageService {
  async getScreenshot(
    projectId: string,
    pageType: 'home' | 'pdp' | 'about' | 'other',
    options: ScreenshotOptions
  ): Promise<string | null> {
    try {
      const screenshotRecord = await ScreenshotDAL.getScreenshot(projectId, pageType, options);

      if (!screenshotRecord || !screenshotRecord.data) {
        console.log(`[SCREENSHOT_STORAGE] No screenshot found for ${pageType} page`);
        return null;
      }

      // Update access tracking
      await ScreenshotDAL.updateAccessTracking(screenshotRecord.id);

      console.log(`[SCREENSHOT_STORAGE] Retrieved ${pageType} screenshot (${screenshotRecord.fileSize} bytes)`);
      return Buffer.from(screenshotRecord.data).toString('base64');
    } catch (error) {
      console.error('[SCREENSHOT_STORAGE] Error getting screenshot:', error);
      return null;
    }
  }

  async getScreenshotWithHtml(
    projectId: string,
    pageType: 'home' | 'pdp' | 'about' | 'other',
    options: ScreenshotOptions
  ): Promise<{ screenshot: string | null; html: string | null }> {
    try {
      const screenshotRecord = await ScreenshotDAL.getScreenshot(projectId, pageType, options);

      if (!screenshotRecord || !screenshotRecord.data) {
        console.log(`[SCREENSHOT_STORAGE] No screenshot found for ${pageType} page`);
        return { screenshot: null, html: null };
      }

      // Update access tracking
      await ScreenshotDAL.updateAccessTracking(screenshotRecord.id);

      const htmlSize = screenshotRecord.htmlContent ? screenshotRecord.htmlContent.length : 0;
      console.log(`[SCREENSHOT_STORAGE] Retrieved ${pageType} screenshot with HTML (${screenshotRecord.fileSize} bytes, HTML: ${htmlSize} chars)`);
      return {
        screenshot: Buffer.from(screenshotRecord.data).toString('base64'),
        html: screenshotRecord.htmlContent
      };
    } catch (error) {
      console.error('[SCREENSHOT_STORAGE] Error getting screenshot with HTML:', error);
      return { screenshot: null, html: null };
    }
  }

  async saveScreenshot(
    projectId: string,
    pageType: 'home' | 'pdp' | 'about' | 'other',
    url: string,
    options: ScreenshotOptions,
    screenshotData: string,
    htmlContent?: string,
    markdownContent?: string,
    variantId?: string
  ): Promise<string> {
    try {
      const result = await ScreenshotDAL.upsertScreenshot(
        projectId,
        pageType,
        url,
        options,
        screenshotData,
        htmlContent,
        markdownContent,
        variantId
      );

      const buffer = Buffer.from(screenshotData, 'base64');
      const htmlSize = htmlContent ? htmlContent.length : 0;
      const markdownSize = markdownContent ? markdownContent.length : 0;
      console.log(`[SCREENSHOT_STORAGE] Saved ${pageType} screenshot (${buffer.length} bytes, HTML: ${htmlSize} chars, Markdown: ${markdownSize} chars) with ID: ${result.id}`);
      return result.id;
    } catch (error) {
      console.error('[SCREENSHOT_STORAGE] Error saving screenshot:', error);
      throw error;
    }
  }

  async cleanupExpiredScreenshots(): Promise<number> {
    try {
      const count = await ScreenshotDAL.deleteExpired();
      console.log(`[SCREENSHOT_CACHE] Cleaned up ${count} expired screenshots`);
      return count;
    } catch (error) {
      console.error('[SCREENSHOT_CACHE] Error cleaning up screenshots:', error);
      return 0;
    }
  }

  async getScreenshotStats(projectId: string): Promise<{
    totalScreenshots: number;
    totalSize: number;
    accessCount: number;
  }> {
    try {
      return await ScreenshotDAL.getProjectStats(projectId);
    } catch (error) {
      console.error('[SCREENSHOT_STORAGE] Error getting screenshot stats:', error);
      return {
        totalScreenshots: 0,
        totalSize: 0,
        accessCount: 0
      };
    }
  }

  async getScreenshotById(screenshotId: string): Promise<{
    data: Buffer;
    contentType: string;
  } | null> {
    try {
      const screenshotRecord = await ScreenshotDAL.getById(screenshotId);

      if (!screenshotRecord || !screenshotRecord.data) {
        console.log(`[SCREENSHOT_STORAGE] Screenshot not found: ${screenshotId}`);
        return null;
      }

      // Update access tracking
      await ScreenshotDAL.updateAccessTracking(screenshotId);

      console.log(`[SCREENSHOT_STORAGE] Retrieved screenshot ${screenshotId} (${screenshotRecord.fileSize} bytes)`);
      return {
        data: Buffer.from(screenshotRecord.data),
        contentType: 'image/png'
      };
    } catch (error) {
      console.error('[SCREENSHOT_STORAGE] Error getting screenshot by ID:', error);
      return null;
    }
  }
}

// Simplified factory function - no longer needs prisma parameter
export function createScreenshotStorageService(): ScreenshotStorageService {
  return new ScreenshotStorageServiceImpl();
}
</file>

<file path="Dockerfile">
# Development Dockerfile with hot reloading
FROM node:20-bullseye-slim

# Set working directory
WORKDIR /app

# Copy package files
COPY package*.json ./

# Install all dependencies (including dev dependencies)
RUN npm install --package-lock-only --legacy-peer-deps
RUN npm ci --legacy-peer-deps

RUN apt-get update && apt-get install -y --no-install-recommends \
    chromium \
    libnss3 \
    libfreetype6 \
    libharfbuzz0b \
    ca-certificates \
    libcairo2 \
    libpango-1.0-0 \
    libpangocairo-1.0-0 \
    fonts-freefont-ttf \
    udev

RUN npx playwright install chromium

# Copy source code and config files
COPY src/ ./src/
COPY tsconfig.json ./
COPY prisma/ ./prisma/

# Generate Prisma client (but don't build TypeScript)
RUN npm run db:generate

# Expose port
EXPOSE 3001

# Start the application in development mode with hot reloading
CMD ["npm", "run", "dev"]
</file>

<file path="src/features/brand_analysis/url-selector.ts">
import { generateObject } from 'ai';
import { google } from '@ai-sdk/google';
import { z } from 'zod';
import { getAIConfig } from '@shared/ai-config';

export interface UrlSelectionResult {
    home: string;
    pdp: string;
    about: string;
}

export interface UrlWithType {
    url: string;
    pageType: 'home' | 'pdp' | 'about';
}

const urlSelectionSchema = z.object({
    home: z.string(),
    pdp: z.string(),
    about: z.string()
});

export class UrlSelector {
    constructor() { }

    async selectUrls(urls: string[]): Promise<UrlSelectionResult> {
        const systemText = `
        You are a professional brand analyst.
        For getting the clear picture of the brand, image and feeling of an e-commerce store we need you to analyze a collection of url's which we can then further analyze.
        You return the most useful navigation URLs for getting brand information that are stripped from an e-commerce homepage.
        From this collection you return the home page, one specific product to analyze the PDP and the about page.
        If any of the pages can't be found, return '' instead of making something up.

Rules:
- Use only internal links on the same domain as baseUrl.
- Normalize relative links to absolute using baseUrl.
- Choose the single best URL per category when possible.


The urls to select from are:
${urls.join('\n')}

Return ONLY valid JSON.`;

        try {
            const aiConfig = getAIConfig();
            const result = await generateObject({
                model: google(aiConfig.model),
                schema: urlSelectionSchema,
                messages: [
                    {
                        role: 'user',
                        content: systemText
                    }
                ]
            });

            const data = result.object;
            return data;
        } catch (error) {
            throw new Error(`Failed to get urls: ${error}`);

        }
    }

    /**
     * Convert URL selection result to an array of URLs with their page types
     */
    getUrlsWithTypes(selection: UrlSelectionResult): UrlWithType[] {
        const urlsWithTypes: UrlWithType[] = [];
        
        if (selection.home && selection.home.length > 0) {
            urlsWithTypes.push({ url: selection.home, pageType: 'home' });
        }
        
        if (selection.pdp && selection.pdp.length > 0) {
            urlsWithTypes.push({ url: selection.pdp, pageType: 'pdp' });
        }
        
        if (selection.about && selection.about.length > 0) {
            urlsWithTypes.push({ url: selection.about, pageType: 'about' });
        }
        
        return urlsWithTypes;
    }
}
</file>

<file path="src/features/crawler/types.ts">
// Web Crawler Service Types
export interface CrawlerService {
  crawlPage(url: string, options?: CrawlOptions): Promise<CrawlResult>;
  crawlMultiplePages(urls: string[], options?: CrawlOptions): Promise<CrawlResult[]>;
  takePartialScreenshot(url: string, viewport: { width: number, height: number }, fullPage: boolean, authentication?: { type: 'shopify_password'; password: string, shopDomain: string }): Promise<string>;
}

export interface CrawlResult {
  url: string;
  html: string;
  screenshot: string; // base64 encoded screenshot
  title?: string;
  description?: string;
  error?: string;
}

export interface CrawlOptions {
  viewport?: {
    width: number;
    height: number;
  };
  waitFor?: number; // milliseconds to wait after page load
  timeout?: number; // page load timeout
  userAgent?: string;
  screenshot?: {
    fullPage?: boolean;
    quality?: number;
  };
  authentication?: {
    type: 'shopify_password';
    password: string;
    shopDomain: string;
  };
}

export interface CrawlerConfig {
  headless?: boolean;
  defaultViewport?: {
    width: number;
    height: number;
  };
  defaultTimeout?: number;
  defaultWaitFor?: number;
}
</file>

<file path="src/infra/dal/index.ts">
// Data Access Layer (DAL) - Centralized database operations
export * from './project';
export * from './experiment';
export * from './chat-message';
export * from './user';
export * from './variant-job';
export * from './analytics';
export * from './screenshot';
export * from './types';
</file>

<file path="src/infra/dal/project.ts">
// Project Data Access Layer
import { prisma } from '@infra/prisma';
import type { Project, ProjectWithRelations } from './types';

export class ProjectDAL {
  /**
   * Get project for a specific user
   */
  static async getProjectForUser(userId: string): Promise<Project | null> {
    return await prisma.project.findUnique({
      where: { userId },
    });
  }

  /**
   * Get project with all relations (experiments, chat messages)
   */
  static async getProjectWithRelations(projectId: string): Promise<ProjectWithRelations | null> {
    return await prisma.project.findUnique({
      where: { id: projectId },
      include: {
        experiments: {
          orderBy: { createdAt: 'desc' },
        },
        chatMessages: {
          orderBy: { createdAt: 'desc' },
        },
      },
    });
  }

  /**
   * Get project by ID
   */
  static async getProjectById(projectId: string): Promise<Project | null> {
    return await prisma.project.findUnique({
      where: { id: projectId },
    });
  }

  /**
   * Get project by shop domain
   */
  static async getProjectByShopDomain(shopDomain: string): Promise<Project | null> {
    return await prisma.project.findUnique({
      where: { shopDomain },
    });
  }

  /**
   * Create a new project
   */
  static async createProject(data: {
    userId: string;
    shopDomain: string;
    accessTokenEnc: string;
  }): Promise<Project> {
    return await prisma.project.create({
      data,
    });
  }

  /**
   * Update project access token
   */
  static async updateProjectAccessToken(
    projectId: string,
    accessTokenEnc: string
  ): Promise<Project> {
    return await prisma.project.update({
      where: { id: projectId },
      data: { accessTokenEnc },
    });
  }

  /**
   * Update project brand analysis
   */
  static async updateProjectBrandAnalysis(
    projectId: string,
    brandAnalysis: any
  ): Promise<Project> {
    return await prisma.project.update({
      where: { id: projectId },
      data: { brandAnalysis: brandAnalysis },
    });
  }

  /**
   * Get project brand analysis
   */
  static async getProjectBrandAnalysis(
    projectId: string
  ): Promise<string | null> {
    const project = await prisma.project.findUnique({
      where: { id: projectId },
      select: { brandAnalysis: true },
    });
    const brandAnalysis = JSON.stringify(project?.brandAnalysis) ?? null;
    console.log(`[PROJECT_BRAND_ANALYSIS] Retrieved brand analysis: ${brandAnalysis ? `${brandAnalysis.length} chars` : 'null'}`);
    return brandAnalysis;
  }

  /**
   * Delete project (cascade will handle related records)
   */
  static async deleteProject(projectId: string): Promise<void> {
    await prisma.project.delete({
      where: { id: projectId },
    });
  }

  /**
   * Check if user has a project
   */
  static async userHasProject(userId: string): Promise<boolean> {
    const project = await prisma.project.findUnique({
      where: { userId },
      select: { id: true },
    });
    return project !== null;
  }

  /**
   * Create a brand summary job
   */
  static async createBrandSummaryJob(projectId: string): Promise<{ id: string }> {
    const job = await prisma.brandSummaryJob.create({
      data: {
        projectId,
        status: 'PENDING',
        progress: 0,
      },
    });
    return { id: job.id };
  }

  /**
   * Get brand summary job status
   */
  static async getBrandSummaryJob(jobId: string) {
    return await prisma.brandSummaryJob.findUnique({
      where: { id: jobId },
    });
  }
}
</file>

<file path="src/domain/agent/types.ts">
// Agent Domain Types

export interface AgentMessage {
  id: string;
  sessionId: string;
  role: 'USER' | 'AGENT' | 'TOOL' | 'SYSTEM';
  content: {
    text?: string;
    metadata?: Record<string, unknown>;
    toolCalls?: ToolCall[];
    toolCallId?: string;
  };
  createdAt: Date;
}

export interface ToolCall {
  id: string;
  type: 'function';
  function: {
    name: string;
    arguments: string;
  };
}

export interface ContentBlock {
  type: 'text' | 'tool-call' | 'tool-result' | 'image';
  text?: string;
  toolCallId?: string;
  toolName?: string;
  args?: Record<string, unknown>;
  result?: unknown;
  image?: { url: string };
}

export interface ChatMessage {
  role: 'system' | 'user' | 'assistant' | 'tool';
  content: string | ContentBlock[];
  name?: string;
  tool_calls?: ToolCall[];
  tool_call_id?: string;
}

export interface ChatCompletionResponse {
  content: string;
  toolCalls?: ToolCall[];
  usage?: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
}


export interface AgentConfig {
  systemPrompt?: string;
  maxContextMessages?: number;
  enableToolCalls?: boolean;
  enableWelcomeFlow?: boolean;
}


export interface ProjectInfo {
  id: string;
  shopDomain: string; // Website URL for all stores (Shopify and non-Shopify)
  isShopify: boolean; // Whether this is a Shopify store or not
  shopName?: string;
  shopEmail?: string;
  shopPlan?: string; // Only for Shopify stores
  shopCurrency?: string; // Only for Shopify stores
  shopCountry?: string; // Only for Shopify stores
  experimentsCount: number;
  activeExperimentsCount: number;
}

export interface AgentService {
  sendMessageStream(message: string, projectId: string, conversationHistory?: any[]): Promise<{ stream: unknown; messageId: string }>;
}
</file>

<file path="src/features/variant_generation/prompts.ts">
// Prompts for variant generation service
import { Hypothesis } from '@features/hypotheses_generation/types';

export function buildButtonVariantGenerationPrompt(hypothesis: Hypothesis, variantIndex?: number): string {
    return `
You are a CRO-focused UX/UI design assistant specializing in button optimization. Your task is to take a structured hypothesis and generate 1 practical, testable button variant for A/B testing.

HYPOTHESIS TO TEST:
- Hypothesis: ${hypothesis.description}
- Primary Outcome: ${hypothesis.primary_outcome}
- Current Problem: ${hypothesis.current_problem}
- Why It Works: ${hypothesis.why_it_works.map(w => w.reason).join(', ')}
- Predicted Lift: ${hypothesis.predicted_lift_range.min}-${hypothesis.predicted_lift_range.max}%

TARGET ELEMENT: Button/Link (specifically targeting "Shop all" button)

YOUR TASK:
Generate 1 button variant that focuses on improving conversion through better button design, states, and UX.

VARIANT FOCUS (based on variant index):
${variantIndex === 0 ? 'Variant 1: Focus on COLOR and CONTRAST - Use bold, high-contrast colors to make the button stand out' : 
  variantIndex === 1 ? 'Variant 2: Focus on SIZE and TYPOGRAPHY - Use larger sizes and bold typography to increase prominence' : 
  'Variant 3: Focus on ANIMATION and INTERACTION - Use subtle animations, micro-interactions, and engaging effects to make the button more compelling'}

BUTTON DESIGN PRINCIPLES TO CONSIDER:
- Visual hierarchy and prominence
- Color psychology and contrast
- Size and touch targets (minimum 44px)
- Typography and readability
- Hover, focus, and active states
- Loading states and feedback
- Accessibility (WCAG 2.1 AA compliance)
- Mobile responsiveness

VARIANT REQUIREMENTS:
Each variant must include:

1. VISUAL DESIGN:
   - Color scheme (background, text, border)
   - Size and dimensions
   - Typography (font weight, size, letter spacing)
   - Border radius and shadows
   - Icon or visual elements

2. INTERACTIVE STATES:
   - Default state
   - Hover state (color, scale, shadow changes)
   - Active/pressed state
   - Focus state (for keyboard navigation)
   - Disabled state (if applicable)

3. ACCESSIBILITY:
   - Color contrast ratios (minimum 4.5:1 for normal text)
   - Touch target size (minimum 44x44px)
   - ARIA labels and roles
   - Keyboard navigation support

4. MOBILE OPTIMIZATION:
   - Touch-friendly sizing
   - Readable text at mobile sizes
   - Proper spacing and padding

VARIANT IDEAS TO CONSIDER:
- Color variations (primary, secondary, accent colors)
- Size variations (small, medium, large)
- Style variations (solid, outline, ghost, gradient)
- Typography variations (bold, regular, all-caps)
- Visual enhancements (icons, badges, animations)
- Layout variations (full-width, centered, right-aligned)

CONSTRAINTS:
- Keep changes measurable in an experiment
- Ensure variants are visually distinct but cohesive
- Focus on conversion optimization principles
- Consider the brand analysis context
- Make variants implementable with CSS/HTML
- MEDIA/LINK GUARDRAILS (critical): Do NOT introduce new images/videos or external assets, and do NOT change link destinations (href). Limit suggestions to text, classes, styles, layout, and states using existing DOM and assets. If a concept requires new media or URL changes, explicitly state to skip that aspect.

VARIANT NAMING RULES:
- Use a UNIQUE, descriptive name that clearly differentiates this variant
- Include specific visual characteristics (color, style, size, shape)
- Each variant must have a COMPLETELY DIFFERENT name - no similar words
- Examples: "Solid Turquoise Button", "Outlined White Button", "Large Bold CTA", "Rounded Green Button"
- AVOID: "Primary Action Button", "High-Contrast Button", "CTA Button" - these are too generic
- REQUIRE: Specific colors, sizes, styles, or shapes in every name

SPECIFIC NAMING FOR THIS VARIANT:
${variantIndex === 0 ? 'Variant 1 (COLOR focus): Include specific color names and contrast terms (e.g., "Solid Turquoise Button", "Dark Navy CTA", "Bright Orange Button")' : 
  variantIndex === 1 ? 'Variant 2 (SIZE focus): Include specific size and typography terms (e.g., "Large Bold CTA", "Compact Uppercase Button", "Jumbo Text Button")' : 
  'Variant 3 (ANIMATION focus): Include specific animation and interaction terms (e.g., "Pulse Animation Button", "Hover Glow CTA", "Bounce Effect Button")'}

IMPORTANT: Return your response as a JSON object with a "variants" array containing exactly 1 variant object. The variant must have the fields: variant_label, description, rationale, accessibility_consideration, and implementation_notes.

Note: The system will automatically generate the actual CSS and HTML code for this variant, so focus on clear, specific descriptions that can be easily translated into code.`;
}

export function buildVariantGenerationPrompt(hypothesis: Hypothesis, designSystem?: any): string {
    const designContext = designSystem ? `

DESIGN SYSTEM & VISUAL GUIDELINES:
Typography:
- Primary Font: ${designSystem.typography?.primary_font || 'Not specified'}
- Button Font Size: ${designSystem.typography?.heading_sizes?.button || '16px'}
- Font Weight (Bold): ${designSystem.typography?.font_weights?.bold || '700'}
- Text Transform: ${designSystem.typography?.text_transform_buttons || 'none'}

Colors:
- Primary Button BG: ${designSystem.colors?.primary_button_bg || '#000'}
- Button Text Color: ${designSystem.colors?.primary_button_text || '#fff'}
- Hover Background: ${designSystem.colors?.primary_button_hover_bg || '#333'}
- Accent Color: ${designSystem.colors?.accent_color || '#0066cc'}

Spacing & Layout:
- Button Padding: ${designSystem.spacing?.button_padding || '12px 24px'}
- Button Margin: ${designSystem.spacing?.button_margin || '16px 0'}

Visual Effects:
- Border Radius: ${designSystem.borders?.button_radius || '4px'}
- Button Shadow: ${designSystem.shadows?.button_shadow || 'none'}
- Hover Shadow: ${designSystem.shadows?.button_hover_shadow || '0 4px 8px rgba(0,0,0,0.15)'}

Animations:
- Transition: ${designSystem.animations?.transition_duration || '0.2s'} ${designSystem.animations?.transition_timing || 'ease-in-out'}
- Hover Transform: ${designSystem.animations?.button_hover_transform || 'scale(1.05)'}

UI Patterns:
- Button Style Type: ${designSystem.ui_patterns?.button_style || 'solid'}
- Uses Gradients: ${designSystem.ui_patterns?.uses_gradients || false}
- Uses Animations: ${designSystem.ui_patterns?.uses_animations || true}
` : '';

    return `
You are a SENIOR UI/UX DESIGNER with expertise in conversion optimization and modern web design. Your task is to create VISUALLY STUNNING, HIGH-CONVERTING variants that look professional and polished.
${designContext}
HYPOTHESIS TO TEST:
- Hypothesis: ${hypothesis.description}
- Primary Outcome: ${hypothesis.primary_outcome}
- Current Problem: ${hypothesis.current_problem}
- Why It Works: ${hypothesis.why_it_works.map(w => w.reason).join(', ')}
- Predicted Lift: ${hypothesis.predicted_lift_range.min}-${hypothesis.predicted_lift_range.max}%

YOUR TASK:
Create 1 VISUALLY EXCEPTIONAL variant that is:
1. BEAUTIFUL - Modern, polished, professional design
2. ON-BRAND - Consistent with the extracted design system
3. HIGH-CONVERTING - Using proven UX patterns
4. ACCESSIBLE - WCAG 2.1 AA compliant
5. SMOOTH - With elegant animations and micro-interactions

Based on the hypothesis above, identify the most likely DOM element(s) or site objects that this hypothesis refers to and generate 1 practical, testable variant.

Step 1 - Translate Hypothesis to DOM Target:
- Infer the relevant DOM element(s) (class names, IDs, attributes, role, or common HTML tags)
- If multiple candidates exist (e.g., several CTAs), identify the primary one based on hierarchy or context
- Output both a human-readable description (e.g., "Main Add to Cart button below price") and a technical guess (e.g., .product-form button[type=submit])
- If no reliable target can be inferred, output a fallback: "Unable to map hypothesis to a specific DOM object"

Step 2 - Generate a Variant:
For the identified element(s), create 1 variant idea that takes a clear approach (e.g., COLOR/CONTRAST, SIZE/TYPOGRAPHY, or ANIMATION/INTERACTION) and provide:

- Variant Label - Include specific visual characteristics (e.g., "Solid Turquoise Button", "Large Bold CTA", "Hover Glow CTA")
- Description - what visually or structurally changes
- Rationale - why this might improve performance (CRO/UX principle)
- Accessibility Consideration - check for WCAG compliance (contrast, tap size, ARIA roles, etc.)
- Implementation Notes - specific technical details for implementation

VARIANT NAMING RULES:
- Each variant must have a COMPLETELY UNIQUE, descriptive name
- Include specific visual characteristics (color, style, size, shape) in EVERY name
- Avoid generic terms like "Primary Action Button", "High-Contrast Button", "CTA Button"
- Each name must be visually distinct and memorable
- Examples: "Solid Turquoise Button", "Outlined White Button", "Large Bold CTA", "Rounded Green Button"
- REQUIRE: Different colors, sizes, styles, or shapes for each variant
- NO REPEATING: If one variant is "Solid Turquoise", the next can't be "Solid Blue" - use completely different approaches

CONSTRAINTS:
- Keep all suggestions UI-focused (no backend, pricing, or copywriting strategy beyond short CTA tweaks)
- Ensure changes are measurable in an experiment
- Stay general enough to apply to ~80% of Shopify stores
- Build upon the existing hypothesis rationale and success metrics
- Consider the accessibility issues already identified in the hypothesis
 - MEDIA/LINK GUARDRAILS (critical): Do NOT introduce new images/videos or external assets, and do NOT change link destinations (href). Limit suggestions to text, classes, styles, layout, microcopy variations of existing CTAs, and states using existing DOM and assets. If a concept would require new media or URL changes, explicitly state to skip that part.

CRITICAL NAMING REQUIREMENT:
- The variant should clearly signal its primary focus (e.g., COLOR, SIZE/TYPOGRAPHY, or ANIMATION/INTERACTION)
- The name must be visually distinct and memorable

IMPORTANT: Return your response as a JSON object with a "variants" array containing exactly 1 variant object. The variant must have the fields: variant_label, description, rationale, accessibility_consideration, and implementation_notes. 

Note: After generating these variants, the system will automatically generate the actual CSS and HTML code for each variant, so focus on clear, specific descriptions that can be easily translated into code. Do NOT return a schema definition - return actual data.`;
}
</file>

<file path="src/app/server.ts">
import 'dotenv/config';
import fastify from 'fastify';
import type { FastifyInstance } from 'fastify';
import { prisma } from '@infra/prisma';
import { registerRoutes } from '@interfaces/http/index';
import { serviceContainer } from '@app/container';
import { createJobCleanupService } from '@services/job-cleanup';
import { backgroundServicesManager } from '@services/background-services';

export async function createServer(): Promise<{ server: FastifyInstance; httpServer: any }> {
    // Create Fastify instance
    const server: FastifyInstance = fastify({
        logger: process.env.NODE_ENV === 'development' ? {
            level: 'info',
            transport: {
                target: 'pino-pretty',
                options: {
                    colorize: true,
                    translateTime: 'HH:MM:ss',
                    ignore: 'pid,hostname'
                }
            }
        } : true
    });

    // Register CORS for Auth0 integration
    await server.register(import('@fastify/cors'), {
        origin: true, //TODO: Configure this properly for production
        credentials: true,
    });

    // Register services with Fastify
    await server.register(registerRoutes, { prefix: '/api' });

    // Get the underlying HTTP server from Fastify
    const httpServer = server.server;

    return { server, httpServer };
}

export async function startServer(): Promise<void> {
    try {
        const { server } = await createServer();
        const port = parseInt(process.env.PORT || '3000', 10);
        const host = process.env.HOST || '0.0.0.0';

        // Start the Fastify server
        await server.listen({ port, host });

        // Start job cleanup service
        const jobCleanupService = createJobCleanupService();
        jobCleanupService.startCleanup();

        // Start background services (SQS Consumer, etc.)
        await backgroundServicesManager.start();

        // Graceful shutdown
        const gracefulShutdown = async (): Promise<void> => {
            jobCleanupService.stopCleanup();
            await backgroundServicesManager.stop();
            await serviceContainer.cleanup();
            await prisma.$disconnect();
            await server.close();
        };

        process.on('SIGINT', gracefulShutdown);
        process.on('SIGTERM', gracefulShutdown);
    } catch (err) {
        console.error(err);
        process.exit(1);
    }
}
</file>

<file path="src/features/variant_generation/code-generator.ts">
// Code Generator for Variant Implementation
import { generateObject } from 'ai';
import { google } from '@ai-sdk/google';
import { z } from 'zod';
import { Hypothesis } from '@features/hypotheses_generation/types';
import { InjectionPoint } from './dom-analyzer';
import { getVariantGenerationAIConfig } from '@shared/ai-config';
import { DEMO_CONDITION, getDemoSelector, DEMO_TARGET_ELEMENT } from '@shared/demo-config';

export interface CodeGenerationResult {
    javascript_code: string;
    target_selector: string;
    execution_timing: 'immediate' | 'dom_ready';
    implementation_instructions: string;
}

const codeGenerationSchema = z.object({
    javascript_code: z.string().describe('JavaScript code to implement this variant'),
    target_selector: z.string().describe('CSS selector for the main target element'),
    execution_timing: z.enum(['immediate', 'dom_ready']).describe('When to execute the JavaScript'),
    implementation_instructions: z.string().describe('Brief explanation of what the code does')
});

export class VariantCodeGenerator {
    private designSystem: any = null;

    setDesignSystem(designSystem: any) {
        this.designSystem = designSystem;
    }

    async generateCode(
        variant: any,
        _hypothesis: Hypothesis,
        brandAnalysis: string,
        screenshot: string,
        injectionPoints: InjectionPoint[],
        htmlContent?: string
    ): Promise<CodeGenerationResult> {
        // Extract only essential brand info to reduce tokens
        const brandSummary = this.extractBrandSummary(brandAnalysis);

        // Use demo selector if enabled, otherwise use injection points
        if (DEMO_CONDITION) {
            console.log(`[CODE_GENERATOR] Using demo selector for: ${variant.variant_label}`);
            const demoTarget = {
                selector: getDemoSelector('variants'),
                description: DEMO_TARGET_ELEMENT.description,
                confidence: 1.0,
                elementType: 'button',
                attributes: { href: '/collections/all', class: 'size-style link' }
            };
            return this.generateCodeWithSelector(variant, brandSummary, screenshot, [demoTarget], htmlContent);
        }

        // Use injection points for dynamic approach
        const topPoints = injectionPoints.slice(0, 3);
        const bestPoint = topPoints[0];
        if (!bestPoint) {
            throw new Error(`No injection points found for variant: ${variant.variant_label}`);
        }

        return this.generateCodeWithSelector(variant, brandSummary, screenshot, topPoints, htmlContent);
    }

    private async generateCodeWithSelector(
        variant: any,
        _brandSummary: string,
        screenshot: string,
        points: any[],
        htmlContent?: string
    ): Promise<CodeGenerationResult> {

        const designSystemContext = this.designSystem ? `

DESIGN SYSTEM VALUES TO USE:
Colors:
- Primary Button BG: ${this.designSystem.colors?.primary_button_bg}
- Button Text: ${this.designSystem.colors?.primary_button_text}
- Hover BG: ${this.designSystem.colors?.primary_button_hover_bg}

Typography:
- Font Family: ${this.designSystem.typography?.primary_font}
- Button Font Size: ${this.designSystem.typography?.heading_sizes?.button}
- Font Weight: ${this.designSystem.typography?.font_weights?.bold}
- Text Transform: ${this.designSystem.typography?.text_transform_buttons}

Spacing:
- Padding: ${this.designSystem.spacing?.button_padding}
- Margin: ${this.designSystem.spacing?.button_margin}

Visual Effects:
- Border Radius: ${this.designSystem.borders?.button_radius}
- Box Shadow: ${this.designSystem.shadows?.button_shadow}
- Hover Shadow: ${this.designSystem.shadows?.button_hover_shadow}

Animations:
- Transition: ${this.designSystem.animations?.transition_duration} ${this.designSystem.animations?.transition_timing}
- Hover Transform: ${this.designSystem.animations?.button_hover_transform}
` : '';

        const codePrompt = `Generate PROFESSIONAL, VISUALLY POLISHED JavaScript code for A/B test variant:

VARIANT: ${variant.variant_label}
DESCRIPTION: ${variant.description}
RATIONALE: ${variant.rationale}
${designSystemContext}

SELECTOR OPTIONS WITH CONTEXT:
${this.buildSelectorOptionsContext(points, htmlContent || '')}

REQUIREMENTS:
1. Generate VISUALLY POLISHED JavaScript with PROFESSIONAL CSS
2. Include smooth transitions (0.2s-0.3s ease-in-out) for ALL state changes
3. Add proper :hover, :focus, :active states with visual feedback
4. Use the EXACT design system values provided above
5. Include box-shadows for depth and visual hierarchy
6. Add subtle scale or translateY transforms on hover for micro-interactions
7. Ensure minimum 4.5:1 color contrast for accessibility
8. Use try-catch for error handling
9. Work beautifully on both mobile and desktop
10. Include the IIFE wrapper pattern
11. Choose the BEST selector from the options above
12. STRICT SCOPE: Do NOT query the entire document for other elements
13. If no provided selector matches, log a clear warning and exit
14. RESPECT ELEMENT CONTEXT (CRITICAL):
    - Check "Important styles" - if parent has 'overflow: hidden', ensure positioned elements won't be clipped
    - Check "Spatial context" - respect grid/flex layouts, don't break parent container layouts
    - Check "Interactions" - don't duplicate existing handlers or animations
    - If "Parent has hover effects" is mentioned, coordinate your hover states
    - Respect z-index values to avoid elements being hidden behind others
15. FOLLOW INSERTION STRATEGY (VERY IMPORTANT):
    - Each selector has an "INSERTION STRATEGY" section
    - USE THE PROVIDED METHOD (before, after, prepend, append, replace)
    - USE THE PROVIDED TARGET SELECTOR for precise placement
    - Follow the EXAMPLE code pattern
    - If the primary strategy fails, use the FALLBACK strategy
    - This ensures elements are placed in the CORRECT location, not randomly
14. MEDIA GUARDRAILS (critical):
   - Do NOT create new media elements (img, video, source, picture, iframe) and do NOT modify any element's src, srcset, poster, or style.backgroundImage to point to a new URL.
   - Never introduce external or synthetic URLs (http:, https:, //, data:, blob:) for images/videos. Use ONLY existing assets already present in the DOM, or leave media unchanged.
   - Do NOT change anchor hrefs to external domains; limit to text/content/class/style updates.
   - If the variant would require new media URLs, instead skip that part, log a clear console.warn, and proceed with only text/layout/style changes.
9. LINKS GUARDRAILS (critical):
   - Do NOT create new anchor elements and do NOT change existing href targets. Keep link destinations unchanged.
   - Do NOT invent new URLs or paths. Do NOT switch to different routes. Only adjust link text, classes, or inline styles.
   - If the hypothesis implies changing where a link points, skip that step, log a console.warn, and implement only non-navigational changes.

CODE STRUCTURE:
(function() {
  'use strict';

  function initVariant() {
    try {
      // Resolve target element using the best selector from options
      const trySelectors = (selectors) => {
        for (const s of selectors) {
          const el = document.querySelector(s);
          if (el) return el;
        }
        return null;
      };

      // Use the selector you determine is best for this variant
      const selectors = [
        // Add the selectors in order of preference based on the variant needs
      ];

      const baseElement = trySelectors(selectors);
      if (!baseElement) {
        console.warn('[Variant ${variant.variant_label}] Target element not found for selectors:', selectors);
        return;
      }

      // Your variant implementation here
      // Based on: ${variant.description}
      // IMPORTANT: Scope all queries within baseElement, e.g. baseElement.querySelector(...)

    } catch (error) {
      console.error('[Variant ${variant.variant_label}]', error);
    }
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initVariant);
  } else {
    initVariant();
  }
})();

Return JSON with: javascript_code, target_selector, execution_timing, implementation_instructions`;

        const aiConfig = getVariantGenerationAIConfig();
        console.log(`[CODE_GENERATOR] Generating code for variant: ${variant.variant_label}`);
        console.log(`[CODE_GENERATOR] Using ${points.length} selector options with context`);

        try {
            const codeObject = await generateObject({
                model: google(aiConfig.model),
                schema: codeGenerationSchema,
                messages: [
                    {
                        role: 'user',
                        content: [
                            { type: "text", text: codePrompt },
                            { type: "image", image: screenshot }
                        ]
                    }
                ]
            });

            console.log(`[CODE_GENERATOR] Generated JavaScript code for variant: ${variant.variant_label} (${codeObject.object.javascript_code.length} chars)`);

            // Use the selector the LLM chose
            const result = codeObject.object;
            // Don't force a specific selector - let the LLM choose the best one

            return result;
        } catch (error) {
            console.error(`[CODE_GENERATOR] Error generating code for variant ${variant.variant_label}:`, error);
            // Return a fallback code result
            return {
                javascript_code: `// Failed to generate code for ${variant.variant_label}`,
                target_selector: points[0]?.selector || '',
                execution_timing: 'dom_ready' as const,
                implementation_instructions: `Code generation failed. Please implement manually: ${variant.description}`
            };
        }
    }


    private buildSelectorOptionsContext(points: any[], htmlContent: string): string {
        return points.map((point, index) => {
            const isPrimary = index === 0;
            const priority = isPrimary ? 'PRIMARY' : `OPTION ${index}`;

            // Enhanced context with validation information
            const validation = point.selectorReliability || {};
            const alternatives = point.alternativeSelectors || [];

            // Build enhanced context string with spatial and interaction info
            const elementContext = point.elementContext || {};
            const spatialInfo = this.formatSpatialContext(elementContext.spatial);
            const interactionInfo = this.formatInteractionContext(elementContext.interactions);
            const styleInfo = this.formatStyleContext(elementContext.computedStyles);

            // Format insertion strategy
            const insertionInfo = this.formatInsertionStrategy(point.insertionStrategy);

            return `
${priority} SELECTOR:
- Selector: ${point.selector}
- Type: ${point.elementType || point.type || 'unknown'}
- Confidence: ${point.confidence || 0}
- Description: ${point.description || 'No description'}
- Context: ${point.context || 'No context'}
${point.originalText ? `- Current text: "${point.originalText}"` : ''}
${point.reasoning ? `- Reasoning: ${point.reasoning}` : ''}
${validation.works !== undefined ? `- Validation: ${validation.works ? 'VALID' : 'INVALID'} - ${validation.reason || 'No reason'}` : ''}
${alternatives.length > 0 ? `- Alternative selectors: ${alternatives.slice(0, 3).join(', ')}` : ''}
${styleInfo ? `- Important styles: ${styleInfo}` : ''}
${spatialInfo ? `- Spatial context: ${spatialInfo}` : ''}
${interactionInfo ? `- Interactions: ${interactionInfo}` : ''}
${insertionInfo ? `\n- INSERTION STRATEGY:\n${insertionInfo}` : ''}
${htmlContent ? `- HTML Context: ${this.extractEnhancedHtmlContext(point.selector, htmlContent)}` : ''}
`;
        }).join('\n');
    }

    private extractEnhancedHtmlContext(selector: string, htmlContent: string): string {
        try {
            const cheerio = require('cheerio');
            const $ = cheerio.load(htmlContent);
            const elements = $(selector);

            if (elements.length === 0) {
                return 'No elements found with this selector';
            }

            const element = elements.first();

            // Get parent context
            const parent = element.parent();
            const parentInfo = parent.length > 0 ?
                `Parent: <${parent[0].name} class="${parent.attr('class') || ''}"...>` : '';

            // Get sibling context
            const prevSibling = element.prev();
            const nextSibling = element.next();
            const siblingInfo = [];
            if (prevSibling.length > 0) {
                siblingInfo.push(`Previous: <${prevSibling[0].name}>`);
            }
            if (nextSibling.length > 0) {
                siblingInfo.push(`Next: <${nextSibling[0].name}>`);
            }

            // Get element HTML (truncated)
            const elementHtml = $.html(element[0]).substring(0, 300);

            return `
  Element HTML: ${elementHtml}${elementHtml.length >= 300 ? '...' : ''}
  ${parentInfo}
  ${siblingInfo.length > 0 ? `Siblings: ${siblingInfo.join(', ')}` : ''}
  Position: ${element.index() + 1} of ${element.siblings().length + 1} siblings`;

        } catch (error) {
            return `Error extracting context: ${error}`;
        }
    }

    private formatSpatialContext(spatial: any): string {
        if (!spatial) return '';

        const parts: string[] = [];

        if (spatial.parentContainer) {
            parts.push(`Parent: ${spatial.parentContainer.layout} layout`);
            if (spatial.parentContainer.styles?.overflow) {
                parts.push(`overflow: ${spatial.parentContainer.styles.overflow}`);
            }
        }

        if (spatial.siblings && spatial.siblings.length > 0) {
            parts.push(`${spatial.siblings.length} siblings nearby`);
        }

        if (spatial.children && spatial.children.length > 0) {
            const interactive = spatial.children.filter((c: any) => c.hasInteractions).length;
            if (interactive > 0) {
                parts.push(`${interactive} interactive children`);
            }
        }

        return parts.join(', ');
    }

    private formatInteractionContext(interactions: any): string {
        if (!interactions) return '';

        const parts: string[] = [];

        if (interactions.existingHandlers && interactions.existingHandlers.length > 0) {
            parts.push(`Has: ${interactions.existingHandlers.join(', ')}`);
        }

        if (interactions.animations && interactions.animations.length > 0) {
            parts.push('Has animations');
        }

        if (interactions.hoveredAncestors && interactions.hoveredAncestors.length > 0) {
            parts.push('Parent has hover effects');
        }

        if (interactions.zIndex && interactions.zIndex > 0) {
            parts.push(`z-index: ${interactions.zIndex}`);
        }

        return parts.join(', ');
    }

    private formatStyleContext(styles: any): string {
        if (!styles || Object.keys(styles).length === 0) return '';

        const important = ['position', 'overflow', 'display'];
        const relevantStyles = Object.entries(styles)
            .filter(([key]) => important.includes(key))
            .map(([key, value]) => `${key}: ${value}`)
            .join(', ');

        return relevantStyles;
    }

    private formatInsertionStrategy(strategy: any): string {
        if (!strategy) return '';

        let output = `  Method: ${strategy.method.toUpperCase()}`;

        if (strategy.targetSelector) {
            output += `\n  Target: baseElement.querySelector('${strategy.targetSelector}')`;
        } else {
            output += `\n  Target: baseElement itself`;
        }

        output += `\n  Reason: ${strategy.reasoning}`;
        output += `\n  Example: ${strategy.example}`;

        if (strategy.fallbacks && strategy.fallbacks.length > 0) {
            output += `\n  Fallback: ${strategy.fallbacks[0].method} - ${strategy.fallbacks[0].reasoning}`;
        }

        return output;
    }

    // Extract essential brand info to reduce token usage
    private extractBrandSummary(brandAnalysis: string): string {
        try {
            const brand = JSON.parse(brandAnalysis);
            const personality = brand.brand_personality_words?.slice(0, 3).join(', ') || 'Modern';
            const primaryColor = brand.brand_colors?.[0]?.color || 'Blue';
            return `${personality} brand, primary: ${primaryColor}`;
        } catch {
            return 'Modern, professional brand';
        }
    }
}

// Factory function
export function createVariantCodeGenerator(): VariantCodeGenerator {
    return new VariantCodeGenerator();
}
</file>

<file path="src/infra/config/services.ts">
// Service Configuration
export interface ServiceConfig {
  // openai: {
  //   apiKey: string;
  //   model?: string;
  //   temperature?: number;
  //   maxTokens?: number;
  // };
  google: {
    apiKey: string;
    model?: string;
    temperature?: number;
    maxTokens?: number;
  };
  crawler: {
    headless?: boolean;
    defaultViewport?: {
      width: number;
      height: number;
    };
    defaultTimeout?: number;
    defaultWaitFor?: number;
  };
  posthog: {
    apiKey: string;
    host: string;
    projectId: string;
    timeout?: number;
    retryAttempts?: number;
  };
  cloudflare: {
    accountId: string;
    apiToken: string;
    namespaceId: string;
  };
  sqs: {
    accessKeyId: string;
    secretAccessKey: string;
    region: string;
    queueUrl: string;
    batchSize?: number;
    pollInterval?: number;
    visibilityTimeout?: number;
  };
}

export function getServiceConfig(): ServiceConfig {
  return {
    // openai: {
    //   apiKey: process.env.OPENAI_API_KEY || '',
    //   model: process.env.OPENAI_MODEL || 'gpt-4o',
    //   temperature: parseFloat(process.env.OPENAI_TEMPERATURE || '0.3'),
    //   maxTokens: parseInt(process.env.OPENAI_MAX_TOKENS || '2000'),
    // },
    google: {
      apiKey: process.env.GOOGLE_GENERATIVE_AI_API_KEY || '',
      model: process.env.GOOGLE_MODEL || 'gemini-2.5-pro',
      temperature: parseFloat(process.env.GOOGLE_TEMPERATURE || '0.7'),
      maxTokens: parseInt(process.env.GOOGLE_MAX_TOKENS || '1000'),
    },
    crawler: {
      headless: process.env.CRAWLER_HEADLESS !== 'false',
      defaultViewport: {
        width: parseInt(process.env.CRAWLER_VIEWPORT_WIDTH || '1280'),
        height: parseInt(process.env.CRAWLER_VIEWPORT_HEIGHT || '720'),
      },
      defaultTimeout: parseInt(process.env.CRAWLER_TIMEOUT || '30000'),
      defaultWaitFor: parseInt(process.env.CRAWLER_WAIT_FOR || '2000'),
    },
    posthog: {
      apiKey: process.env.POSTHOG_API_KEY || '',
      host: process.env.POSTHOG_HOST || 'https://eu.posthog.com',
      projectId: process.env.POSTHOG_PROJECT_ID || '',
      timeout: parseInt(process.env.POSTHOG_TIMEOUT || '10000'),
      retryAttempts: parseInt(process.env.POSTHOG_RETRY_ATTEMPTS || '3'),
    },
    cloudflare: {
      accountId: process.env.CLOUDFLARE_ACCOUNT_ID || '',
      apiToken: process.env.CLOUDFLARE_API_TOKEN || '',
      namespaceId: process.env.CLOUDFLARE_NAMESPACE_ID || '',
    },
    sqs: {
      accessKeyId: process.env.AWS_ACCESS_KEY_ID || '',
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY || '',
      region: process.env.AWS_REGION || 'eu-central-1',
      queueUrl: process.env.SQS_QUEUE_URL || '',
      batchSize: parseInt(process.env.SQS_BATCH_SIZE || '10'),
      pollInterval: parseInt(process.env.SQS_POLL_INTERVAL || '10000'), // Increased from 5s to 10s
      visibilityTimeout: parseInt(process.env.SQS_VISIBILITY_TIMEOUT || '300'),
    },
  };
}
</file>

<file path="src/services/experiment-publisher.ts">
// Experiment Publisher Service
import { CloudflarePublisher, PublishedExperiment, PublishedVariant } from '@infra/external/cloudflare';
import { prisma } from '@infra/prisma';

export interface ExperimentPublisherService {
  publishExperiment(experimentId: string): Promise<{ success: boolean; error?: string }>;
  unpublishExperiment(experimentId: string, newStatus?: 'DRAFT' | 'PAUSED'): Promise<{ success: boolean; error?: string }>;
}

export class ExperimentPublisherServiceImpl implements ExperimentPublisherService {
  private cloudflarePublisher: CloudflarePublisher;

  constructor(cloudflarePublisher: CloudflarePublisher) {
    this.cloudflarePublisher = cloudflarePublisher;
  }

  async publishExperiment(experimentId: string): Promise<{ success: boolean; error?: string }> {
    console.log(`[EXPERIMENT_PUBLISHER] Starting publish process for experiment: ${experimentId}`);
    
    try {
      // Fetch experiment data from database
      console.log(`[EXPERIMENT_PUBLISHER] Fetching experiment data from database...`);
      const experiment = await prisma.experiment.findUnique({
        where: { id: experimentId },
        include: {
          hypothesis: true,
          traffic: true,
          variants: true,
        },
      });

      if (!experiment) {
        console.error(`[EXPERIMENT_PUBLISHER] Experiment not found: ${experimentId}`);
        return { success: false, error: 'Experiment not found' };
      }

      console.log(`[EXPERIMENT_PUBLISHER] Found experiment:`, {
        id: experiment.id,
        name: experiment.name,
        status: experiment.status,
        variantCount: experiment.variants.length,
        trafficCount: experiment.traffic.length
      });

      // Can publish DRAFT (new) or PAUSED (resuming) experiments
      if (experiment.status !== 'DRAFT' && experiment.status !== 'PAUSED') {
        console.error(`[EXPERIMENT_PUBLISHER] Experiment ${experimentId} cannot be published from ${experiment.status} status`);
        return { success: false, error: 'Only DRAFT or PAUSED experiments can be published' };
      }

      // Transform database data to published format
      console.log(`[EXPERIMENT_PUBLISHER] Transforming experiment data for Cloudflare...`);
      const publishedExperiment: PublishedExperiment = {
        id: experiment.id,
        projectId: experiment.projectId,
        name: experiment.name,
        status: 'RUNNING', // Published experiments are running
        oec: experiment.oec,
        traffic: this.buildTrafficDistribution(experiment.traffic),
        variants: this.buildVariants(experiment.variants),
        targetUrls: this.parseTargetUrls(experiment.targetUrls), // Include URL targeting data
        targeting: (experiment as any).targeting as any | undefined,
      };

      console.log(`[EXPERIMENT_PUBLISHER] Transformed experiment data:`, {
        id: publishedExperiment.id,
        name: publishedExperiment.name,
        status: publishedExperiment.status,
        trafficDistribution: publishedExperiment.traffic,
        variantCount: Object.keys(publishedExperiment.variants).length
      });

      // Publish to Cloudflare
      console.log(`[EXPERIMENT_PUBLISHER] Publishing to Cloudflare...`);
      const result = await this.cloudflarePublisher.publishExperiment(publishedExperiment);

      if (result.success) {
        console.log(`[EXPERIMENT_PUBLISHER] Cloudflare publish successful, updating database status...`);
        // Update experiment status in database
        await prisma.experiment.update({
          where: { id: experimentId },
          data: { 
            status: 'RUNNING',
            publishedAt: new Date(),
          },
        });
        console.log(`[EXPERIMENT_PUBLISHER] Database status updated to RUNNING for experiment: ${experimentId}`);
      } else {
        console.error(`[EXPERIMENT_PUBLISHER] Cloudflare publish failed:`, result.error);
      }

      return { success: result.success, error: result.error };
    } catch (error) {
      console.error(`[EXPERIMENT_PUBLISHER] Failed to publish experiment ${experimentId}:`, error);
      console.error(`[EXPERIMENT_PUBLISHER] Error details:`, {
        message: error instanceof Error ? error.message : 'Unknown error',
        stack: error instanceof Error ? error.stack : undefined,
        experimentId
      });
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unknown error' 
      };
    }
  }

  async unpublishExperiment(experimentId: string, newStatus?: 'DRAFT' | 'PAUSED'): Promise<{ success: boolean; error?: string }> {
    console.log(`[EXPERIMENT_PUBLISHER] Starting unpublish process for experiment: ${experimentId}`);

    try {
      // Unpublish from Cloudflare
      console.log(`[EXPERIMENT_PUBLISHER] Unpublishing from Cloudflare...`);
      const result = await this.cloudflarePublisher.unpublishExperiment(experimentId);

      if (result.success) {
        console.log(`[EXPERIMENT_PUBLISHER] Cloudflare unpublish successful, updating database status...`);
        // Update experiment status in database (default to DRAFT for backward compatibility)
        const statusToSet = newStatus || 'DRAFT';
        await prisma.experiment.update({
          where: { id: experimentId },
          data: { status: statusToSet },
        });
        console.log(`[EXPERIMENT_PUBLISHER] Database status updated to ${statusToSet} for experiment: ${experimentId}`);
      } else {
        console.error(`[EXPERIMENT_PUBLISHER] Cloudflare unpublish failed:`, result.error);
      }

      return { success: result.success, error: result.error };
    } catch (error) {
      console.error(`[EXPERIMENT_PUBLISHER] Failed to unpublish experiment ${experimentId}:`, error);
      console.error(`[EXPERIMENT_PUBLISHER] Error details:`, {
        message: error instanceof Error ? error.message : 'Unknown error',
        stack: error instanceof Error ? error.stack : undefined,
        experimentId
      });
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  private buildTrafficDistribution(traffic: any[]): Record<string, number> {
    const distribution: Record<string, number> = {};
    traffic.forEach(t => {
      distribution[t.variantId] = parseFloat(t.percentage.toString());
    });
    
    // Ensure control variant is included in traffic distribution
    // Control gets traffic allocation but no code storage (implicit control)
    if (!distribution.control) {
      console.warn(`[EXPERIMENT_PUBLISHER] No control variant found in traffic distribution for experiment`);
    }
    
    console.log(`[EXPERIMENT_PUBLISHER] Traffic distribution:`, distribution);
    return distribution;
  }

  private buildVariants(variants: any[]): Record<string, PublishedVariant> {
    const variantMap: Record<string, PublishedVariant> = {};
    variants.forEach(v => {
      variantMap[v.variantId] = {
        selector: v.selector || 'body',
        html: v.html,
        css: v.css || '',
        js: v.js || '', // Always include js field, even if empty
        position: v.position,
      };
    });
    return variantMap;
  }

  private parseTargetUrls(targetUrls: any): string[] | undefined {
    if (!targetUrls) return undefined;
    
    // If it's already an array, return it
    if (Array.isArray(targetUrls)) return targetUrls;
    
    // If it's a string, try to parse it as JSON
    if (typeof targetUrls === 'string') {
      try {
        const parsed = JSON.parse(targetUrls);
        return Array.isArray(parsed) ? parsed : undefined;
      } catch (error) {
        console.warn(`[EXPERIMENT_PUBLISHER] Failed to parse targetUrls JSON: ${targetUrls}`, error);
        return undefined;
      }
    }
    
    return undefined;
  }
}

export function createExperimentPublisherService(cloudflarePublisher: CloudflarePublisher): ExperimentPublisherService {
  return new ExperimentPublisherServiceImpl(cloudflarePublisher);
}
</file>

<file path="src/domain/agent/tools/index.ts">
// @ts-nocheck 
// Main tools file - combines all individual tools
import { createGetProjectInfoTool } from './get-project-info';
import { generateHypotheses } from './generate-hypotheses';
import { generateVariants } from './generate-variants';
import { createExperiment } from './create-experiment';
import { createGetBrandAnalysisTool } from './get-brand-analysis';
import { createGetBrandSourcesTool } from './get-brand-sources';
import { checkVariants } from './check-variants';
import { createGetExperimentOverviewTool } from './get-experiment-overview';
import { createPreviewExperimentTool } from './preview-experiment';

// Function to get available tool names
export function getAvailableToolNames(): string[] {
  return ['get_project_info', 'generate_hypotheses', 'generate_variants', 'preview_experiment', 'create_experiment', 'get_brand_analysis', 'get_brand_sources', 'check_variants', 'get_experiment_overview'];
}


// Function to get tools configuration for LLM
export function getToolsConfiguration(projectId: string) {
  return {
    tools: createEcommerceAgentTools(projectId),
    availableTools: getAvailableToolNames(),
  };
}

// Create all tools
export function createEcommerceAgentTools(projectId: string) {
  console.log(`[TOOLS_CONFIG] Creating tools for project: ${projectId}`);
  const tools = {
    get_project_info: createGetProjectInfoTool(projectId),
    generate_hypotheses: generateHypotheses(projectId),
    generate_variants: generateVariants(projectId),
    preview_experiment: createPreviewExperimentTool(),
    create_experiment: createExperiment(projectId),
    get_brand_analysis: createGetBrandAnalysisTool(projectId),
    get_brand_sources: createGetBrandSourcesTool(projectId),
    check_variants: checkVariants(projectId),
    get_experiment_overview: createGetExperimentOverviewTool(),
  };
  console.log(`[TOOLS_CONFIG] Tools created successfully:`, Object.keys(tools));
  return tools;
}
</file>

<file path="src/domain/agent/tools/schemas.ts">
// @ts-nocheck 
// Tool schemas and definitions
import { z } from 'zod';

export const getProjectInfoSchema = z.object({
  projectId: z.string().optional().describe('The project ID to get information for. If not provided, will use a default project.')
});

export const createHypothesesSchema = z.object({
  projectId: z.string().optional().describe('The project ID to generate hypotheses for (optional, will use default if not provided)'),
  url: z.string().optional().describe('The URL to analyze (optional, defaults to the project\'s website URL)'),
  userInput: z.string().optional().describe('Optional user-provided hypothesis idea or direction. When provided, the AI will use this as the primary direction and refine it into a proper hypothesis.')
});

export const createVariantsSchema = z.object({
  hypothesis: z.object({
    title: z.string().describe('The hypothesis title'),
    description: z.string().describe('The hypothesis description'),
    primary_outcome: z.string().describe('The primary outcome metric'),
    current_problem: z.string().describe('The current problem being addressed'),
    why_it_works: z.array(z.object({
      reason: z.string()
    })).describe('Reasons why this hypothesis should work'),
    baseline_performance: z.number().describe('Current baseline performance as percentage'),
    predicted_lift_range: z.object({
      min: z.number(),
      max: z.number()
    }).describe('Predicted lift range as decimals')
  }).optional().describe('The hypothesis object to generate variants for - if not provided, will use the most recently generated hypothesis from state')
});

export const getBrandAnalysisSchema = z.object({
  projectId: z.string().optional().describe('The project ID to get brand analysis for. If not provided, will use the current project.')
});

export const toolSchemas = {
  get_project_info: getProjectInfoSchema,
  generate_hypotheses: createHypothesesSchema,
  generate_variants: createVariantsSchema,
  get_brand_analysis: getBrandAnalysisSchema,
} as const;

export type ToolSchemas = typeof toolSchemas;
</file>

<file path="src/interfaces/http/chat.ts">
import { FastifyInstance } from 'fastify';
import { serviceContainer } from '@app/container';
import { Readable } from 'node:stream';
import { UIMessage } from 'ai';
import { betterAuthMiddleware } from './middleware/better-auth';
import { requireAuth } from './middleware/authorization';


export async function chatRoutes(fastify: FastifyInstance) {
    fastify.post("/chat", { preHandler: [betterAuthMiddleware, requireAuth] }, async (req, reply) => {
        const { messages } = (req.body ?? {}) as {
            messages?: UIMessage[];
        };

        console.log(`[CHAT] Processing ${messages?.length || 0} messages`);

        if (!messages || messages.length === 0) {
            return reply.code(400).send({ error: 'Messages are required' });
        }

        try {
            // Get the agent service from container (already configured with system prompt and tools)
            const agentService = serviceContainer.getAgentService();

            // Get the last user message
            const lastMessage = messages[messages.length - 1];
            if (!lastMessage || lastMessage.role !== 'user') {
                return reply.code(400).send({ error: 'Last message must be from user' });
            }

            // Extract text content from the message parts
            const parts = (lastMessage as any).parts;
            if (!parts || !Array.isArray(parts)) {
                return reply.code(400).send({ error: 'Invalid message parts format' });
            }

            const messageText = parts
                .filter((part: any) => part.type === 'text')
                .map((part: any) => part.text)
                .join('');

            if (!messageText) {
                return reply.code(400).send({ error: 'Message content is required' });
            }

            // Convert the full conversation history to the format expected by the agent
            const conversationHistory = messages.map((msg: any) => {
                const msgParts = msg.parts || [];
                const textContent = msgParts
                    .filter((part: any) => part.type === 'text')
                    .map((part: any) => part.text)
                    .join('');
                
                return {
                    role: msg.role,
                    content: textContent,
                    // Include tool calls and results from assistant messages
                    ...(msg.role === 'assistant' && {
                        tool_calls: msgParts
                            .filter((part: any) => part.type?.startsWith('tool-'))
                            .map((part: any) => ({
                                id: part.toolCallId,
                                type: 'function',
                                function: {
                                    name: part.type.replace('tool-', ''),
                                    arguments: JSON.stringify(part.input || {})
                                }
                            })),
                        tool_call_id: msgParts
                            .filter((part: any) => part.type?.startsWith('tool-'))
                            .map((part: any) => part.toolCallId)[0],
                        // Include tool call outputs so the agent can see the results
                        tool_results: msgParts
                            .filter((part: any) => part.type?.startsWith('tool-') && part.output)
                            .map((part: any) => ({
                                tool_call_id: part.toolCallId,
                                content: JSON.stringify(part.output)
                            }))
                    })
                };
            });

            // Use the agent service streaming method with full conversation history
            // Session management is disabled for now
            console.log(`[CHAT] Calling agent service with message: "${messageText.substring(0, 100)}..." and ${conversationHistory.length} history messages`);
            const { stream } = await agentService.sendMessageStream(messageText, req.projectId!, conversationHistory);
            console.log(`[CHAT] Agent service returned stream successfully`);

            // Use AI SDK's built-in streaming response
            const res = (stream as { toUIMessageStreamResponse: () => Response }).toUIMessageStreamResponse();

            // Copy headers + stream body to Fastify
            reply.code(res.status);
            for (const [k, v] of res.headers) reply.header(k, v);
            if (res.body) {
                const nodeStream = Readable.fromWeb(res.body as any);
                return reply.send(nodeStream);
            }
            return reply.send();

        } catch (error) {
            console.error('Streaming chat error:', error);
            return reply.code(500).send({ error: 'Internal server error' });
        }
    });
}
</file>

<file path="src/domain/agent/tools/create-experiment.ts">
// @ts-nocheck
import { tool } from 'ai';
import { z } from 'zod';
import { ExperimentDAL } from '@infra/dal';
import { hypothesisStateManager } from '../hypothesis-state-manager';
import { variantStateManager } from '../variant-state-manager';
import { experimentStateManager } from '../experiment-state-manager';
import { prisma } from '@infra/prisma';
import { createExperimentPublisherService } from '@services/experiment-publisher';
import { createCloudflarePublisher } from '@infra/external/cloudflare';
import { getServiceConfig } from '@infra/config/services';
import { findConflicts, ConflictError } from '@features/conflict_guard';

const createExperimentSchema = z.object({
  name: z.string().optional().describe('The name of the experiment - if not provided, will be auto-generated from the hypothesis'),
  hypothesis: z.object({
    hypothesis: z.string().describe('The hypothesis statement'),
    rationale: z.string().describe('The rationale behind the hypothesis'),
    measurable_tests: z.string().describe('What can be measured to test this hypothesis'),
    success_metrics: z.string().describe('The success metrics for this hypothesis'),
    oec: z.string().describe('The Overall Evaluation Criterion (OEC)'),
    accessibility_check: z.string().describe('Accessibility considerations for this hypothesis')
  }).optional().describe('The hypothesis object - if not provided, will use the most recently generated hypothesis from state'),
  variants: z.array(z.object({
    variant_label: z.string().describe('The label for this variant'),
    description: z.string().describe('Description of what this variant changes'),
    rationale: z.string().describe('Why this variant might improve performance'),
    accessibility_consideration: z.string().describe('Accessibility considerations for this variant'),
    implementation_notes: z.string().describe('Technical implementation details'),
    css_code: z.string().describe('CSS code for this variant'),
    html_code: z.string().describe('HTML code for this variant'),
    injection_method: z.enum(['selector', 'new_element', 'modify_existing']).describe('How to inject this code'),
    target_selector: z.string().optional().describe('CSS selector to target existing element'),
    new_element_html: z.string().optional().describe('Complete HTML for new element'),
    implementation_instructions: z.string().describe('Step-by-step implementation instructions'),
    screenshot: z.string().optional().describe('URL to the screenshot of the variant applied to the page')
  })).optional().describe('The variants to test - if not provided, will use the most recently generated variants from state'),
  jobIds: z.array(z.string()).optional().describe('Specific job IDs to load variants from - if provided, will load variants from these exact jobs instead of searching all project jobs'),
  targetUrls: z.array(z.string()).optional().describe('URL patterns where this experiment should run (e.g., ["/products/*", "/checkout", "^/collections/shoes$"]). If not provided, will auto-detect based on hypothesis and variants.')
});

//TODO: Remove implementation instructions

// Extract URL patterns from screenshot data
async function extractURLPatternsFromScreenshots(projectId: string, _variants: any[]): Promise<string[]> {
  const patterns: string[] = [];

  try {
    // Get all screenshots for this project
    const screenshots = await prisma.screenshot.findMany({
      where: { projectId },
      select: { url: true, pageType: true },
      orderBy: { createdAt: 'desc' }
    });

    console.log(`[EXPERIMENT_TOOL] Found ${screenshots.length} screenshots for project ${projectId}`);

    // Extract URLs from screenshots
    const urls = screenshots.map(s => s.url);
    console.log(`[EXPERIMENT_TOOL] Screenshot URLs:`, urls);

    // Create smart patterns from URLs
    for (const url of urls) {
      try {
        const urlObj = new globalThis.URL(url);
        const pathname = urlObj.pathname;

        // Smart pattern detection
        if (pathname.includes('/products/') || pathname.includes('/product/')) {
          // PDP pattern - match all product pages
          patterns.push('/products/*');
          patterns.push('/product/*');
        } else if (pathname.includes('/collections/')) {
          // Collection pattern
          patterns.push('/collections/*');
        } else if (pathname.includes('/categories/')) {
          // Category pattern
          patterns.push('/categories/*');
        } else if (pathname === '/' || pathname === '/home') {
          // Homepage pattern
          patterns.push('/');
          patterns.push('/home');
        } else if (pathname.includes('/cart')) {
          // Cart pattern
          patterns.push('/cart');
          patterns.push('/cart/*');
        } else if (pathname.includes('/checkout')) {
          // Checkout pattern
          patterns.push('/checkout');
          patterns.push('/checkout/*');
        } else {
          // Exact match for other pages
          patterns.push(pathname);
        }
      } catch (error) {
        console.warn(`[EXPERIMENT_TOOL] Invalid URL: ${url}`, error);
      }
    }

    // Remove duplicates and return
    const uniquePatterns = [...new Set(patterns)];
    console.log(`[EXPERIMENT_TOOL] Generated URL patterns:`, uniquePatterns);
    return uniquePatterns;

  } catch (error) {
    console.error(`[EXPERIMENT_TOOL] Error extracting URL patterns from screenshots:`, error);
    return ['/*']; // Fallback to all pages
  }
}

class CreateExperimentExecutor {
  private projectId: string;

  constructor(projectId: string) {
    this.projectId = projectId;
  }

  async execute(input: {
    name?: string;
    hypothesis?: any;
    variants?: any[];
    jobIds?: string[];
  }): Promise<{ experimentId: string; status: string; message: string }> {
    console.log(`[EXPERIMENT_TOOL] ===== EXPERIMENT CREATION INPUT =====`);
    console.log(`[EXPERIMENT_TOOL] Full input received:`, JSON.stringify(input, null, 2));
    console.log(`[EXPERIMENT_TOOL] Input variants length:`, input.variants ? input.variants.length : 'undefined');

    // Get hypothesis from state manager (preferred) or input
    let hypothesis = hypothesisStateManager.getCurrentHypothesis();

    if (hypothesis) {
      console.log(`[EXPERIMENT_TOOL] Using hypothesis from state manager: "${hypothesis.title}"`);
    } else if (input.hypothesis) {
      console.log(`[EXPERIMENT_TOOL] Using hypothesis from input: "${input.hypothesis.title}"`);
      hypothesis = input.hypothesis;
    } else {
      console.log(`[EXPERIMENT_TOOL] No hypothesis available in state or input`);
      throw new Error('No hypothesis available. Please generate hypotheses first using the generate_hypotheses tool.');
    }

    // Get variants from state manager (preferred) or input
    let variants = variantStateManager.getCurrentVariants();

    console.log(`[EXPERIMENT_TOOL] State manager variants:`, variants ? `${variants.length} variants` : 'null');
    console.log(`[EXPERIMENT_TOOL] Input variants:`, input.variants ? `${input.variants.length} variants` : 'undefined');

    if (variants && variants.length > 0) {
      console.log(`[EXPERIMENT_TOOL] Using ${variants.length} variants from state manager`);
      console.log(`[EXPERIMENT_TOOL] Variant labels:`, variants.map(v => v.variant_label));
    } else if (input.variants && input.variants.length > 0) {
      console.log(`[EXPERIMENT_TOOL] Using ${input.variants.length} variants from input`);
      console.log(`[EXPERIMENT_TOOL] Input variant labels:`, input.variants.map(v => v.variant_label || 'unnamed'));
      variants = input.variants;
    } else {
      console.log(`[EXPERIMENT_TOOL] No variants available in state or input`);
      console.log(`[EXPERIMENT_TOOL] State manager has variants:`, variantStateManager.hasCurrentVariants());
      console.log(`[EXPERIMENT_TOOL] State manager variant count:`, variantStateManager.getCurrentVariantCount());

      // Try to load variants from completed jobs
      console.log(`[EXPERIMENT_TOOL] Attempting to load variants from completed jobs...`);
      try {
        let loadedVariants: any[] = [];

        // Priority 1: Use jobIds from input (most explicit)
        if (input.jobIds && input.jobIds.length > 0) {
          console.log(`[EXPERIMENT_TOOL] Loading variants from input job IDs:`, input.jobIds);
          loadedVariants = await variantStateManager.loadVariantsFromJobIds(input.jobIds);
        }
        // Priority 2: Use jobIds from state manager
        else {
          const currentJobIds = variantStateManager.getCurrentJobIds();
          if (currentJobIds && currentJobIds.length > 0) {
            console.log(`[EXPERIMENT_TOOL] Loading variants from state manager job IDs:`, currentJobIds);
            loadedVariants = await variantStateManager.loadVariantsFromJobIds(currentJobIds);
          } else {
            console.log(`[EXPERIMENT_TOOL] No specific job IDs found, falling back to all project jobs`);
            loadedVariants = await variantStateManager.loadVariantsFromJobs(this.projectId);
          }
        }

        if (loadedVariants && loadedVariants.length > 0) {
          console.log(`[EXPERIMENT_TOOL] Successfully loaded ${loadedVariants.length} variants from completed jobs`);
          console.log(`[EXPERIMENT_TOOL] Loaded variant labels:`, loadedVariants.map(v => v.variant_label));
          variants = loadedVariants;
        } else {
          console.log(`[EXPERIMENT_TOOL] No completed variant jobs found`);
          throw new Error('No variants available. Please generate variants first using the generate_variants tool.');
        }
      } catch (loadError) {
        console.error(`[EXPERIMENT_TOOL] Failed to load variants from jobs:`, loadError);
        throw new Error('No variants available. Please generate variants first using the generate_variants tool.');
      }
    }

    console.log(`[EXPERIMENT_TOOL] ======================================`);

    // Auto-generate experiment name from hypothesis if not provided
    let experimentName = input.name;
    if (!experimentName) {
      // Extract key words from hypothesis to create a meaningful name
      const hypothesisText = hypothesis.description.toLowerCase();
      let name = 'Button Optimization';

      if (hypothesisText.includes('button')) {
        if (hypothesisText.includes('contrast')) {
          name = 'Button Contrast Optimization';
        } else if (hypothesisText.includes('color')) {
          name = 'Button Color Optimization';
        } else if (hypothesisText.includes('size')) {
          name = 'Button Size Optimization';
        } else {
          name = 'Button Optimization';
        }
      } else if (hypothesisText.includes('cta') || hypothesisText.includes('call-to-action')) {
        name = 'CTA Optimization';
      } else if (hypothesisText.includes('form')) {
        name = 'Form Optimization';
      } else if (hypothesisText.includes('checkout')) {
        name = 'Checkout Optimization';
      } else if (hypothesisText.includes('navigation') || hypothesisText.includes('menu')) {
        name = 'Navigation Optimization';
      } else {
        name = 'Conversion Optimization';
      }

      experimentName = name;
      console.log(`[EXPERIMENT_TOOL] Auto-generated experiment name: "${experimentName}"`);
    } else {
      console.log(`[EXPERIMENT_TOOL] Using provided experiment name: "${experimentName}"`);
    }

    // Use hardcoded project ID for now
    const projectId = this.projectId;

    try {
      // Final conflict check before creating experiment
      console.log(`[EXPERIMENT_TOOL] Performing final conflict check...`);
      const activeTargets = await ExperimentDAL.getActiveTargets(projectId);

      // Check conflicts for each variant
      for (const variant of variants) {
        const conflicts = findConflicts(activeTargets, {
          url: '/', // Default URL, can be enhanced with actual target URL
          selector: variant.target_selector,
          role: undefined // Role can be extracted from variant metadata
        });

        if (conflicts.length > 0) {
          const onConflictQueue = process.env.ON_CONFLICT_QUEUE === 'true';

          if (onConflictQueue) {
            console.log(`[EXPERIMENT_TOOL] Conflict detected, queuing experiment...`);
            // Create experiment in queued status
            const experiment = await ExperimentDAL.createExperiment({
              projectId,
              name: experimentName + ' (Queued due to conflict)',
              oec: hypothesis.oec || 'Improve conversion rate',
              minDays: 7,
              minSessionsPerVariant: 1000,
              status: 'DRAFT' // Keep as draft when conflicted
            });

            return {
              experimentId: experiment.id,
              status: 'QUEUED',
              message: `Experiment "${experimentName}" has been queued due to conflicts with experiment ${conflicts[0].experimentId}. It will be activated once the conflicting experiment completes.`
            };
          } else {
            // Throw error with conflict details
            throw new ConflictError('CONFLICT_OVERLAP', conflicts,
              `Cannot create experiment: conflicts with active experiment ${conflicts[0].experimentId} targeting "${conflicts[0].label}"`
            );
          }
        }
      }

      console.log(`[EXPERIMENT_TOOL] No conflicts detected, proceeding with experiment creation`);

      // Auto-detect URL patterns if not provided
      let targetUrls = input.targetUrls;
      if (!targetUrls || targetUrls.length === 0) {
        targetUrls = await extractURLPatternsFromScreenshots(this.projectId, variants);
        console.log(`[EXPERIMENT_TOOL] Auto-detected URL patterns from screenshots:`, targetUrls);
      }

      const experiment = await ExperimentDAL.createExperiment({
        projectId,
        name: experimentName,
        oec: hypothesis.primary_outcome || 'Improve conversion rate', // Use primary_outcome as OEC
        minDays: 7, // Default minimum days
        minSessionsPerVariant: 1000, // Default minimum sessions
        targetUrls: targetUrls.length > 0 ? targetUrls : null
      });

      // Create hypothesis
      await prisma.experimentHypothesis.create({
        data: {
          experimentId: experiment.id,
          hypothesis: hypothesis.description,
          rationale: hypothesis.current_problem, // Use current_problem as rationale
          primaryKpi: hypothesis.primary_outcome || 'conversion_rate'
        }
      });

      // Create traffic distribution with control group
      const generateVariantIds = (variantCount: number): string[] => {
        const ids = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']; // Support up to 8 variants
        return ids.slice(0, variantCount);
      };

      const variantIds = generateVariantIds(variants.length);
      const totalVariants = variants.length + 1; // +1 for control group
      const percentagePerVariant = 1.0 / totalVariants;

      console.log(`[EXPERIMENT_TOOL] Creating traffic distribution for ${variants.length} test variants + 1 control group`);
      console.log(`[EXPERIMENT_TOOL] Total variants: ${totalVariants}, percentage per variant: ${(percentagePerVariant * 100).toFixed(2)}%`);

      // Create traffic for control group (always gets equal share)
      await prisma.experimentTraffic.create({
        data: {
          experimentId: experiment.id,
          variantId: 'control',
          percentage: percentagePerVariant
        }
      });
      console.log(`[EXPERIMENT_TOOL] Control group allocated ${(percentagePerVariant * 100).toFixed(2)}% traffic`);

      // Create traffic for test variants
      for (let i = 0; i < variantIds.length; i++) {
        await prisma.experimentTraffic.create({
          data: {
            experimentId: experiment.id,
            variantId: variantIds[i],
            percentage: percentagePerVariant
          }
        });
        console.log(`[EXPERIMENT_TOOL] Variant ${variantIds[i]} allocated ${(percentagePerVariant * 100).toFixed(2)}% traffic`);
      }

      // Create variants
      console.log(`[EXPERIMENT_TOOL] Creating ${variants.length} variants in database`);
      for (let i = 0; i < variants.length; i++) {
        const variant = variants[i];
        console.log(`[EXPERIMENT_TOOL] Creating variant ${i + 1}: ${variant.variant_label}`);
        console.log(`[EXPERIMENT_TOOL] Variant data:`, JSON.stringify({
          variant_label: variant.variant_label,
          target_selector: variant.target_selector,
          has_css: !!variant.css_code,
          has_html: !!variant.html_code,
          injection_method: variant.injection_method
        }, null, 2));

        await prisma.experimentVariant.create({
          data: {
            experimentId: experiment.id,
            variantId: variantIds[i],
            selector: variant.target_selector || 'body',
            html: variant.html_code || '',
            css: variant.css_code || '',
            js: variant.javascript_code || '', // Map javascript_code to js field
            position: 'INNER' // Default position
          }
        });
      }

      console.log(`[EXPERIMENT_TOOL] Experiment created successfully: ${experiment.id}`);

      // Store experiment in state manager for future reference
      experimentStateManager.setCurrentExperiment(experiment);

      // Automatically publish the experiment after creation
      console.log(`[EXPERIMENT_TOOL] Auto-publishing experiment: ${experiment.id}`);
      try {
        const config = getServiceConfig();
        const cloudflarePublisher = createCloudflarePublisher(config.cloudflare);
        const experimentPublisher = createExperimentPublisherService(cloudflarePublisher);

        const publishResult = await experimentPublisher.publishExperiment(experiment.id);

        if (publishResult.success) {
          console.log(`[EXPERIMENT_TOOL] Experiment published successfully`);
          return {
            experimentId: experiment.id,
            status: 'RUNNING',
            message: `Experiment "${experimentName}" has been created and published to Cloudflare! It's now live and the SDK can load the variants for testing.`
          };
        } else {
          console.error(`[EXPERIMENT_TOOL] Failed to publish:`, publishResult.error);
          return {
            experimentId: experiment.id,
            status: 'DRAFT',
            message: `Experiment "${experimentName}" has been created but failed to publish to Cloudflare: ${publishResult.error}. The experiment remains in DRAFT status.`
          };
        }
      } catch (publishError) {
        console.error(`[EXPERIMENT_TOOL] Error publishing experiment:`, publishError);
        return {
          experimentId: experiment.id,
          status: 'DRAFT',
          message: `Experiment "${experimentName}" has been created but failed to publish: ${publishError instanceof Error ? publishError.message : 'Unknown error'}. The experiment remains in DRAFT status.`
        };
      }
    } catch (error) {
      console.error(`[EXPERIMENT_TOOL] Failed to create experiment:`, error);
      throw new Error(`Failed to create experiment: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
}

export function createExperiment(projectId: string) {
  const executor = new CreateExperimentExecutor(projectId);

  return tool({
    description: 'Create an experiment in the database with the given hypothesis and variants. If you have job IDs from a previous generate_variants call, pass them in the jobIds parameter to load the specific variants from those jobs.',
    inputSchema: createExperimentSchema,
    execute: async (input) => {
      try {
        const result = await executor.execute(input);
        return result;
      } catch (error) {
        console.error(`[EXPERIMENT_TOOL] Tool execute failed:`, error);
        throw new Error(error instanceof Error ? error.message : 'Failed to create experiment');
      }
    },
  });
}
</file>

<file path="src/domain/agent/tools/generate-variants.ts">
import { tool } from 'ai';
import { createVariantsSchema } from './schemas';
import { createVariantGenerationService, VariantGenerationService } from '@features/variant_generation/variant-generation';
import { createPlaywrightCrawler } from '@features/crawler';
import { createScreenshotStorageService } from '@services/screenshot-storage';
import { getServiceConfig } from '@infra/config/services';
import { Hypothesis } from '@features/hypotheses_generation/types';
import { hypothesisStateManager } from '../hypothesis-state-manager';
import { variantStateManager } from '../variant-state-manager';
import { VariantJobDAL } from '@infra/dal';
import { createVariantJobProcessor } from '@services/variant-job-processor';
import { prisma } from '@infra/prisma';

class GenerateVariantsExecutor {
    private variantGenerationService: VariantGenerationService;
    private projectId: string;

    constructor(projectId: string) {
        this.projectId = projectId;
        const config = getServiceConfig();
        const crawler = createPlaywrightCrawler(config.crawler);
        const screenshotStorage = createScreenshotStorageService();
        this.variantGenerationService = createVariantGenerationService(crawler, screenshotStorage, prisma);
    }

    private async generateVariantJobs(hypothesis: Hypothesis): Promise<{ jobIds: string[]; projectId: string }> {
        console.log(`[VARIANTS_TOOL] Starting job-based variant generation for hypothesis: ${hypothesis.title}`);
        
        // Verify project exists
        const project = await this.variantGenerationService.getCachedProject(this.projectId);
        if (!project) {
            throw new Error(`Project not found: ${this.projectId}`);
        }

        // Create 3 jobs immediately (one for each variant)
        const jobIds: string[] = [];
        for (let i = 0; i < 3; i++) {
            const job = await VariantJobDAL.createJob({ projectId: this.projectId });
            jobIds.push(job.id);
            console.log(`[VARIANTS_TOOL] Created job ${job.id} for variant ${i + 1}`);
        }

        // Start async processing of all jobs
        // Each job will do its own AI generation, code generation, and screenshots
        const jobProcessor = createVariantJobProcessor();
        jobProcessor.processVariantJobs(
            jobIds, 
            this.projectId, 
            hypothesis
        ).catch(error => {
            console.error(`[VARIANTS_TOOL] Failed to process variant jobs:`, error);
        });

        return {
            jobIds,
            projectId: this.projectId
        };
    }

    async execute(input: { hypothesis?: Hypothesis }): Promise<any> {
        console.log(`[VARIANTS_TOOL] ===== VARIANT GENERATION INPUT =====`);
        console.log(`[VARIANTS_TOOL] Full input received:`, JSON.stringify(input, null, 2));
        
        // Get hypothesis from state manager (preferred) or input
        let hypothesis = hypothesisStateManager.getCurrentHypothesis();
        
        if (hypothesis) {
            console.log(`[VARIANTS_TOOL] Using hypothesis from state manager: "${hypothesis.title}"`);
        } else if (input.hypothesis) {
            console.log(`[VARIANTS_TOOL] Using hypothesis from input: "${input.hypothesis.title}"`);
            hypothesis = input.hypothesis;
        } else {
            console.log(`[VARIANTS_TOOL] No hypothesis available in state or input`);
            throw new Error('No hypothesis available. Please generate hypotheses first using the generate_hypotheses tool.');
        }
        
        console.log(`[VARIANTS_TOOL] ======================================`);
        
        try {
            const result = await this.generateVariantJobs(hypothesis);
            console.log(`[VARIANTS_TOOL] Variant jobs created successfully: ${result.jobIds.length} jobs`);
            
            // Store the job IDs in the state manager for later retrieval
            variantStateManager.setCurrentJobIds(result.jobIds);
            console.log(`[VARIANTS_TOOL] Job IDs stored in state manager:`, result.jobIds);
            
            return result;
        } catch (error) {
            console.error(`[VARIANTS_TOOL] Failed to generate variant jobs:`, error);
            throw error;
        }
    }
}

export function generateVariants(projectId: string) {
    const executor = new GenerateVariantsExecutor(projectId);

    return tool({
        description: 'Generate variants for testing a hypothesis. Creates variant jobs that process in the background. Returns jobIds that can be passed to create_experiment to load the specific variants from these jobs.',
        inputSchema: createVariantsSchema,
        execute: async (input) => {
            try {
                const result = await executor.execute(input);
                return result;
            } catch (error) {
                console.error(`[VARIANTS_TOOL] Tool execute failed:`, error);
                throw new Error(error instanceof Error ? error.message : 'Failed to generate variants');
            }
        },
    });
}
</file>

<file path="src/domain/agent/tools/generate-hypotheses.ts">
// @ts-nocheck 
import { tool } from 'ai';
import { createHypothesesSchema } from './schemas';
import { createHypothesesGenerationService, HypothesesGenerationService } from '@features/hypotheses_generation/hypotheses-generation';
import { HypothesesGenerationResult } from '@features/hypotheses_generation/hypotheses-generation';
import { createPlaywrightCrawler } from '@features/crawler';
import { getServiceConfig } from '@infra/config/services';
import { hypothesisStateManager } from '../hypothesis-state-manager';
import { prisma } from '@infra/prisma';

class GenerateHypothesesExecutor {
    private hypothesesGenerationService: HypothesesGenerationService;
    private projectId: string;

    constructor(projectId: string) {
        this.projectId = projectId;
        const config = getServiceConfig();
        const crawler = createPlaywrightCrawler(config.crawler);
        this.hypothesesGenerationService = createHypothesesGenerationService(crawler, prisma);
    }

    private async generateHypotheses(url: string, projectId: string, userInput?: string): Promise<HypothesesGenerationResult> {
        return await this.hypothesesGenerationService.generateHypotheses(url, projectId, userInput);
    }

    async execute(input: { projectId?: string; url?: string; userInput?: string }): Promise<HypothesesGenerationResult> {
        // Get the project's URL if not provided
        let url = input.url;
        if (!url) {
            const project = await prisma.project.findUnique({
                where: { id: this.projectId },
                select: { shopDomain: true }
            });
            if (!project) {
                throw new Error(`Project ${this.projectId} not found`);
            }
            url = project.shopDomain.startsWith('http') ? project.shopDomain : `https://${project.shopDomain}`;
        }
        console.log(`[HYPOTHESES_TOOL] Generating hypotheses for ${url} with project ${this.projectId}`);

        if (input.userInput) {
            console.log(`[HYPOTHESES_TOOL] User input provided: "${input.userInput}"`);
        }

        const result = await this.generateHypotheses(url, this.projectId, input.userInput);
        
        console.log(`[HYPOTHESES_TOOL] Result structure: ${result.hypotheses ? result.hypotheses.length : 0} hypotheses, schema: ${result.hypothesesSchema ? 'Yes' : 'No'}`);
        
        // Parse the hypotheses from the result structure
        let hypotheses = result.hypotheses;
        if (!hypotheses && result.hypothesesSchema) {
            try {
                const parsed = JSON.parse(result.hypothesesSchema);
                hypotheses = parsed.hypotheses;
                console.log(`[HYPOTHESES_TOOL] Parsed hypotheses from schema:`, hypotheses?.length || 0);
            } catch (error) {
                console.error(`[HYPOTHESES_TOOL] Failed to parse hypothesesSchema:`, error);
            }
        }
        
        console.log(`[HYPOTHESES_TOOL] Hypotheses array length:`, hypotheses?.length || 0);
        
        // Store the first hypothesis in state manager for use by other tools
        if (hypotheses && hypotheses.length > 0) {
            console.log(`[HYPOTHESES_TOOL] Storing hypothesis: "${hypotheses[0].title}"`);
            hypothesisStateManager.setCurrentHypothesis(hypotheses[0]);
            console.log(`[HYPOTHESES_TOOL] Hypothesis stored successfully`);
        } else {
            console.log(`[HYPOTHESES_TOOL] No hypotheses to store`);
        }
        
        return result;
    }
}

export function generateHypotheses(projectId: string) {
    const executor = new GenerateHypothesesExecutor(projectId);

    return tool({
        description: 'Generate hypotheses for a given project',
        inputSchema: createHypothesesSchema,
        execute: async (input) => {
            try {
                const result = await executor.execute(input);
                return result;
            } catch (error) {
                console.error(`[HYPOTHESES_TOOL] Tool execute failed:`, error);
                throw new Error(error instanceof Error ? error.message : 'Failed to fetch generate hypotheses');
            }
        },
    });
}
</file>

<file path="src/interfaces/http/index.ts">
import type { FastifyInstance } from 'fastify/types/instance.js';
import { healthRoutes } from './health';
import { userRoutes } from './user/index';
import { authRoutes } from './auth/index';
import { shopifyRoutes } from './shopify';
import { chatRoutes } from './chat';
import { brandSummaryRoutes } from './project/brandSummary';
import { jobRoutes } from './project/jobs';
import { projectResetRoutes } from './project/reset';
import { screenshotRoutes } from './screenshots';
import { experimentRoutes } from './experiment/index';
import { analyticsRoutes } from './analytics/index';
import betterAuthPlugin from './plugins/better-auth-plugin';

export async function registerRoutes(fastify: FastifyInstance): Promise<void> {
    // Register Better Auth plugin first
    await fastify.register(betterAuthPlugin);
    
    await fastify.register(healthRoutes);
    await fastify.register(authRoutes);
    await fastify.register(userRoutes);
    await fastify.register(shopifyRoutes);
    await fastify.register(chatRoutes);
    await fastify.register(brandSummaryRoutes);
    await fastify.register(jobRoutes);
    await fastify.register(projectResetRoutes);
    await fastify.register(screenshotRoutes);
    await fastify.register(experimentRoutes);
    await fastify.register(analyticsRoutes, { prefix: 'analytics' });
}
</file>

<file path="src/interfaces/http/experiment/index.ts">
import type { FastifyInstance } from 'fastify/types/instance.js';
import '@shared/fastify.d';
import { VariantJobDAL } from '@infra/dal/variant-job';
import { ExperimentDAL } from '@infra/dal/experiment';
import { betterAuthMiddleware } from '../middleware/better-auth';
import { requireProject, requireProjectOwnership } from '../middleware/authorization';
import { z } from 'zod';
import { prisma } from '@infra/prisma';
import { createExperimentPublisherService } from '@services/experiment-publisher';
import { createCloudflarePublisher } from '@infra/external/cloudflare';
import { getServiceConfig } from '@infra/config/services';
import { createVariantImprovementService } from '@features/variant_generation/variant-improvement';

export async function experimentRoutes(fastify: FastifyInstance) {
    // GET /v1/jobs/:jobId/preview - Simple job-based preview
    fastify.get('/v1/jobs/:jobId/preview', async (request, reply) => {
        try {
            const { jobId } = request.params as { jobId: string };
            const { variantIds } = request.query as { variantIds?: string[] };

            fastify.log.info({ jobId }, 'Getting preview for job');

            // Get the job and check if it's completed
            const job = await VariantJobDAL.getJobById(jobId);
            if (!job) {
                fastify.log.warn({ jobId }, 'Job not found');
                return reply.status(404).send({
                    error: 'NOT_FOUND',
                    message: 'Job not found'
                });
            }

            if (job.status !== 'COMPLETED') {
                fastify.log.warn({ jobId, status: job.status }, 'Job not completed yet');
                return reply.status(400).send({
                    error: 'JOB_NOT_COMPLETED',
                    message: `Job is not completed yet. Current status: ${job.status}`
                });
            }

            if (!job.result?.variantsSchema?.variants) {
                fastify.log.warn({ jobId }, 'Job completed but no variants found');
                return reply.status(404).send({
                    error: 'NO_VARIANTS',
                    message: 'Job completed but no variants found in result'
                });
            }

            let variants = job.result.variantsSchema.variants;

            // Filter by variantIds if provided
            if (variantIds && variantIds.length > 0) {
                const requestedLabels = new Set(variantIds);
                variants = variants.filter((v: any) => requestedLabels.has(v.variant_label));
            }

            // Map fields for SDK compatibility
            const mappedVariants = variants.map((v: any) => ({
                variantId: v.variant_label,
                selector: v.target_selector || '',
                position: 'INNER',
                css: v.css_code || '',
                html: v.html_code || '',
                js: v.javascript_code || v.js || '' // Map javascript_code to js for SDK
            }));

            fastify.log.info({
                jobId,
                variantCount: mappedVariants.length,
                variantLabels: mappedVariants.map((v: any) => v.variantId)
            }, 'Returning job preview');

            return {
                jobId,
                status: job.status,
                completedAt: job.completedAt,
                variants: mappedVariants
            };

        } catch (error) {
            fastify.log.error({ err: error, jobId: (request.params as any).jobId }, 'Get job preview error:');
            return reply.status(500).send({
                error: 'INTERNAL_ERROR',
                message: 'Failed to get job preview'
            });
        }
    });

    // GET /experiments - Get all experiments for a project
    fastify.get('/experiments', {
        preHandler: [betterAuthMiddleware, requireProject],
        schema: {
            response: {
                200: {
                    type: 'array',
                    items: {
                        type: 'object',
                        properties: {
                            id: { type: 'string' },
                            name: { type: 'string' },
                            status: { type: 'string' },
                            oec: { type: 'string' },
                            minDays: { type: 'number' },
                            minSessionsPerVariant: { type: 'number' },
                            targetUrls: { type: 'object' },
                            createdAt: { type: 'string', format: 'date-time' },
                            publishedAt: { type: 'string', format: 'date-time' },
                            finishedAt: { type: 'string', format: 'date-time' }
                        }
                    }
                },
                400: {
                    type: 'object',
                    properties: {
                        error: { type: 'string' },
                        message: { type: 'string' }
                    }
                },
                500: {
                    type: 'object',
                    properties: {
                        error: { type: 'string' }
                    }
                }
            }
        }
    }, async (request, reply) => {
        try {
            const projectId = request.projectId;

            if (!projectId) {
                return reply.status(400).send({
                    error: 'Project ID is required',
                    message: 'User must have a project associated with their account to access experiments'
                });
            }

            const experiments = await ExperimentDAL.getExperimentsByProject(projectId);
            return reply.send(experiments);
        } catch (error) {
            request.log.error(error, 'Failed to get experiments');
            return reply.status(500).send({ error: 'Failed to get experiments' });
        }
    });

    // POST /experiments - Create a new experiment manually
    const domTargetingRule = z.discriminatedUnion('type', [
        z.object({ type: z.literal('selectorExists'), selector: z.string().min(1) }),
        z.object({ type: z.literal('selectorNotExists'), selector: z.string().min(1) }),
        z.object({ type: z.literal('textContains'), selector: z.string().min(1), text: z.string().min(1) }),
        z.object({ type: z.literal('attrEquals'), selector: z.string().min(1), attr: z.string().min(1), value: z.string() }),
        z.object({ type: z.literal('meta'), name: z.string().min(1), value: z.string(), by: z.enum(['name', 'property']).optional() }),
        z.object({ type: z.literal('cookie'), name: z.string().min(1), value: z.string() }),
        z.object({ type: z.literal('localStorage'), key: z.string().min(1), value: z.string() }),
        z.object({ type: z.literal('urlParam'), name: z.string().min(1), value: z.string() })
    ]);

    const domTargetingSchema = z.object({
        match: z.enum(['all', 'any']).optional().default('all'),
        timeoutMs: z.number().int().min(0).max(10000).optional().default(1500),
        rules: z.array(domTargetingRule).min(1)
    }).optional();

    const createExperimentSchema = z.object({
        name: z.string().min(1, 'Name is required'),
        oec: z.string().min(1, 'Overall Evaluation Criterion (OEC) is required'),
        minDays: z.number().int().positive('Minimum days must be positive').default(7),
        minSessionsPerVariant: z.number().int().positive('Minimum sessions per variant must be positive').default(1000),
        targetUrls: z.array(z.string()).optional(),
        targeting: domTargetingSchema,
        hypothesis: z.object({
            hypothesis: z.string().min(1, 'Hypothesis statement is required'),
            rationale: z.string().min(1, 'Rationale is required'),
            primaryKpi: z.string().min(1, 'Primary KPI is required')
        }),
        variants: z.array(z.object({
            variantId: z.string().min(1, 'Variant ID is required (e.g., A, B, C)'),
            selector: z.string().optional(),
            html: z.string().default(''),
            css: z.string().optional(),
            js: z.string().optional(),
            position: z.enum(['INNER', 'OUTER', 'BEFORE', 'AFTER', 'APPEND', 'PREPEND']).default('INNER')
        })).min(1, 'At least one variant is required'),
        trafficDistribution: z.record(z.string(), z.number().min(0).max(1))
            .optional()
            .refine((traffic) => {
                if (!traffic) return true;
                const sum = Object.values(traffic).reduce((acc, val) => acc + val, 0);
                return Math.abs(sum - 1.0) <= 0.005; // ±0.5% tolerance
            }, {
                message: 'Traffic distribution must sum to 1.0 (±0.5%)'
            })
    });

    fastify.post('/experiments', {
        preHandler: [betterAuthMiddleware, requireProject]
    }, async (request, reply) => {
        try {
            const projectId = request.projectId;

            if (!projectId) {
                return reply.status(400).send({
                    error: 'Project ID is required',
                    message: 'User must have a project associated with their account to create experiments'
                });
            }

            // Validate request body
            const validationResult = createExperimentSchema.safeParse(request.body);

            if (!validationResult.success) {
                return reply.status(400).send({
                    error: 'VALIDATION_ERROR',
                    message: 'Invalid request body',
                    details: validationResult.error.errors
                });
            }

            const data = validationResult.data;

            // Create experiment
            const experiment = await ExperimentDAL.createExperiment({
                projectId,
                name: data.name,
                oec: data.oec,
                minDays: data.minDays,
                minSessionsPerVariant: data.minSessionsPerVariant,
                targetUrls: data.targetUrls || null,
                targeting: data.targeting || null
            });

            // Create hypothesis
            await prisma.experimentHypothesis.create({
                data: {
                    experimentId: experiment.id,
                    hypothesis: data.hypothesis.hypothesis,
                    rationale: data.hypothesis.rationale,
                    primaryKpi: data.hypothesis.primaryKpi
                }
            });

            // Calculate traffic distribution
            let trafficDistribution: Record<string, number>;

            if (data.trafficDistribution) {
                trafficDistribution = data.trafficDistribution;
            } else {
                // Auto-generate equal distribution including control
                const totalVariants = data.variants.length + 1; // +1 for control
                const percentagePerVariant = 1.0 / totalVariants;

                trafficDistribution = { control: percentagePerVariant };
                data.variants.forEach(v => {
                    trafficDistribution[v.variantId] = percentagePerVariant;
                });
            }

            // Create traffic distribution
            for (const [variantId, percentage] of Object.entries(trafficDistribution)) {
                await prisma.experimentTraffic.create({
                    data: {
                        experimentId: experiment.id,
                        variantId,
                        percentage
                    }
                });
            }

            // Create variants
            for (const variant of data.variants) {
                await prisma.experimentVariant.create({
                    data: {
                        experimentId: experiment.id,
                        variantId: variant.variantId,
                        selector: variant.selector || 'body',
                        html: variant.html,
                        css: variant.css || '',
                        js: variant.js || '',
                        position: variant.position
                    }
                });
            }

            // Fetch complete experiment with relations
            const completeExperiment = await prisma.experiment.findUnique({
                where: { id: experiment.id },
                include: {
                    hypothesis: true,
                    traffic: true,
                    variants: true
                }
            });

            fastify.log.info({ experimentId: experiment.id }, 'Experiment created successfully');

            return reply.status(201).send({
                success: true,
                experiment: completeExperiment
            });

        } catch (error) {
            fastify.log.error({ err: error }, 'Failed to create experiment');

            if (error instanceof Error) {
                return reply.status(500).send({
                    error: 'INTERNAL_ERROR',
                    message: error.message
                });
            }

            return reply.status(500).send({
                error: 'INTERNAL_ERROR',
                message: 'Failed to create experiment'
            });
        }
    });

    // GET /experiments/:id - Get a single experiment with all relations
    fastify.get('/experiments/:id', {
        preHandler: [betterAuthMiddleware, requireProject]
    }, async (request, reply) => {
        try {
            const { id } = request.params as { id: string };
            const projectId = request.projectId;

            if (!projectId) {
                return reply.status(400).send({
                    error: 'Project ID is required',
                    message: 'User must have a project associated with their account'
                });
            }

            const experiment = await prisma.experiment.findUnique({
                where: { id },
                include: {
                    hypothesis: true,
                    traffic: true,
                    variants: true
                }
            });

            if (!experiment) {
                return reply.status(404).send({
                    error: 'NOT_FOUND',
                    message: 'Experiment not found'
                });
            }

            // Verify experiment belongs to user's project
            if (experiment.projectId !== projectId) {
                return reply.status(403).send({
                    error: 'FORBIDDEN',
                    message: 'You do not have access to this experiment'
                });
            }

            return reply.send(experiment);

        } catch (error) {
            fastify.log.error({ err: error }, 'Failed to get experiment');
            return reply.status(500).send({
                error: 'INTERNAL_ERROR',
                message: 'Failed to get experiment'
            });
        }
    });

    // PATCH /experiments/:id/status - Update experiment status (start, pause, resume, complete)
    const updateStatusSchema = z.object({
        action: z.enum(['start', 'pause', 'resume', 'complete'], {
            errorMap: () => ({ message: 'Action must be one of: start, pause, resume, complete' })
        })
    });

    fastify.patch('/experiments/:id/status', {
        preHandler: [betterAuthMiddleware, requireProject]
    }, async (request, reply) => {
        try {
            const { id } = request.params as { id: string };
            const projectId = request.projectId;

            if (!projectId) {
                return reply.status(400).send({
                    error: 'Project ID is required',
                    message: 'User must have a project associated with their account'
                });
            }

            // Validate request body
            const validationResult = updateStatusSchema.safeParse(request.body);

            if (!validationResult.success) {
                return reply.status(400).send({
                    error: 'VALIDATION_ERROR',
                    message: 'Invalid request body',
                    details: validationResult.error.errors
                });
            }

            const { action } = validationResult.data;

            // Get experiment
            const experiment = await ExperimentDAL.getExperimentById(id);

            if (!experiment) {
                return reply.status(404).send({
                    error: 'NOT_FOUND',
                    message: 'Experiment not found'
                });
            }

            // Verify ownership
            if (experiment.projectId !== projectId) {
                return reply.status(403).send({
                    error: 'FORBIDDEN',
                    message: 'You do not have access to this experiment'
                });
            }

            // Initialize publisher
            const config = getServiceConfig();
            const cloudflarePublisher = createCloudflarePublisher(config.cloudflare);
            const experimentPublisher = createExperimentPublisherService(cloudflarePublisher);

            // Handle state transitions
            let updatedExperiment;

            switch (action) {
                case 'start':
                    // Can only start DRAFT experiments
                    if (experiment.status !== 'DRAFT') {
                        return reply.status(400).send({
                            error: 'INVALID_STATE_TRANSITION',
                            message: `Cannot start experiment in ${experiment.status} status. Only DRAFT experiments can be started.`
                        });
                    }

                    // Publish to Cloudflare
                    const publishResult = await experimentPublisher.publishExperiment(id);

                    if (!publishResult.success) {
                        return reply.status(500).send({
                            error: 'PUBLISH_FAILED',
                            message: `Failed to publish experiment: ${publishResult.error}`
                        });
                    }

                    // Get updated experiment
                    updatedExperiment = await ExperimentDAL.getExperimentById(id);
                    fastify.log.info({ experimentId: id }, 'Experiment started successfully');
                    break;

                case 'pause':
                    // Can only pause RUNNING experiments
                    if (experiment.status !== 'RUNNING') {
                        return reply.status(400).send({
                            error: 'INVALID_STATE_TRANSITION',
                            message: `Cannot pause experiment in ${experiment.status} status. Only RUNNING experiments can be paused.`
                        });
                    }

                    // Unpublish from Cloudflare (stops serving variants)
                    const pauseUnpublishResult = await experimentPublisher.unpublishExperiment(id, 'PAUSED');

                    if (!pauseUnpublishResult.success) {
                        return reply.status(500).send({
                            error: 'UNPUBLISH_FAILED',
                            message: `Failed to pause experiment: ${pauseUnpublishResult.error}`
                        });
                    }

                    // Get updated experiment (status already set to PAUSED by unpublishExperiment)
                    updatedExperiment = await ExperimentDAL.getExperimentById(id);

                    fastify.log.info({ experimentId: id }, 'Experiment paused successfully (unpublished from Cloudflare)');
                    break;

                case 'resume':
                    // Can only resume PAUSED experiments
                    if (experiment.status !== 'PAUSED') {
                        return reply.status(400).send({
                            error: 'INVALID_STATE_TRANSITION',
                            message: `Cannot resume experiment in ${experiment.status} status. Only PAUSED experiments can be resumed.`
                        });
                    }

                    // Re-publish to Cloudflare (starts serving variants again)
                    const resumePublishResult = await experimentPublisher.publishExperiment(id);

                    if (!resumePublishResult.success) {
                        return reply.status(500).send({
                            error: 'PUBLISH_FAILED',
                            message: `Failed to resume experiment: ${resumePublishResult.error}`
                        });
                    }

                    // Get updated experiment (status already set to RUNNING by publishExperiment)
                    updatedExperiment = await ExperimentDAL.getExperimentById(id);

                    fastify.log.info({ experimentId: id }, 'Experiment resumed successfully (re-published to Cloudflare)');
                    break;

                case 'complete':
                    // Can complete RUNNING or PAUSED experiments
                    if (experiment.status !== 'RUNNING' && experiment.status !== 'PAUSED') {
                        return reply.status(400).send({
                            error: 'INVALID_STATE_TRANSITION',
                            message: `Cannot complete experiment in ${experiment.status} status. Only RUNNING or PAUSED experiments can be completed.`
                        });
                    }

                    // Unpublish from Cloudflare
                    const unpublishResult = await experimentPublisher.unpublishExperiment(id);

                    if (!unpublishResult.success) {
                        fastify.log.warn({ experimentId: id, error: unpublishResult.error }, 'Failed to unpublish, but marking as completed anyway');
                    }

                    updatedExperiment = await ExperimentDAL.updateStatus({
                        experimentId: id,
                        status: 'COMPLETED',
                        finishedAt: new Date()
                    });

                    fastify.log.info({ experimentId: id }, 'Experiment completed successfully');
                    break;
            }

            return reply.send({
                success: true,
                experiment: updatedExperiment
            });

        } catch (error) {
            fastify.log.error({ err: error }, 'Failed to update experiment status');

            if (error instanceof Error) {
                return reply.status(500).send({
                    error: 'INTERNAL_ERROR',
                    message: error.message
                });
            }

            return reply.status(500).send({
                error: 'INTERNAL_ERROR',
                message: 'Failed to update experiment status'
            });
        }
    });

    // DELETE /experiments/:id - Delete an experiment
    fastify.delete('/experiments/:id', {
        preHandler: [betterAuthMiddleware, requireProject]
    }, async (request, reply) => {
        try {
            const { id } = request.params as { id: string };
            const projectId = request.projectId;

            if (!projectId) {
                return reply.status(400).send({
                    error: 'Project ID is required',
                    message: 'User must have a project associated with their account'
                });
            }

            // Get experiment
            const experiment = await ExperimentDAL.getExperimentById(id);

            if (!experiment) {
                return reply.status(404).send({
                    error: 'NOT_FOUND',
                    message: 'Experiment not found'
                });
            }

            // Verify ownership
            if (experiment.projectId !== projectId) {
                return reply.status(403).send({
                    error: 'FORBIDDEN',
                    message: 'You do not have access to this experiment'
                });
            }

            // Can't delete RUNNING experiments - must pause/complete first
            if (experiment.status === 'RUNNING') {
                return reply.status(400).send({
                    error: 'INVALID_STATE',
                    message: 'Cannot delete a RUNNING experiment. Please pause or complete it first.'
                });
            }

            // If experiment is published, unpublish it first
            if (experiment.status !== 'DRAFT') {
                const config = getServiceConfig();
                const cloudflarePublisher = createCloudflarePublisher(config.cloudflare);
                const experimentPublisher = createExperimentPublisherService(cloudflarePublisher);

                await experimentPublisher.unpublishExperiment(id);
                fastify.log.info({ experimentId: id }, 'Unpublished experiment before deletion');
            }

            // Delete experiment (cascades to hypothesis, traffic, variants via Prisma)
            await ExperimentDAL.deleteExperiment(id);

            fastify.log.info({ experimentId: id }, 'Experiment deleted successfully');

            return reply.send({
                success: true,
                message: 'Experiment deleted successfully'
            });

        } catch (error) {
            fastify.log.error({ err: error }, 'Failed to delete experiment');

            if (error instanceof Error) {
                return reply.status(500).send({
                    error: 'INTERNAL_ERROR',
                    message: error.message
                });
            }

            return reply.status(500).send({
                error: 'INTERNAL_ERROR',
                message: 'Failed to delete experiment'
            });
        }
    });

    // POST /project/:projectId/jobs/:jobId/variants/:variantIndex/improve - Improve a variant based on user feedback
    fastify.post('/project/:projectId/jobs/:jobId/variants/:variantIndex/improve', {
        preHandler: [betterAuthMiddleware, requireProject, requireProjectOwnership]
    }, async (request, reply) => {
        try {
            const { projectId, jobId, variantIndex } = request.params as { projectId: string; jobId: string; variantIndex: string };
            const { feedback } = request.body as { feedback: string };

            // Validate feedback
            if (!feedback || typeof feedback !== 'string' || feedback.trim().length === 0) {
                return reply.status(400).send({
                    error: 'INVALID_FEEDBACK',
                    message: 'Feedback is required and must be a non-empty string'
                });
            }

            // Get the job
            const job = await VariantJobDAL.getJobById(jobId);
            if (!job) {
                return reply.status(404).send({
                    error: 'NOT_FOUND',
                    message: 'Job not found'
                });
            }

            // Verify job belongs to the specified project
            if (job.projectId !== projectId) {
                return reply.status(403).send({
                    error: 'FORBIDDEN',
                    message: 'Job does not belong to the specified project'
                });
            }

            if (job.status !== 'COMPLETED') {
                return reply.status(400).send({
                    error: 'JOB_NOT_COMPLETED',
                    message: `Job is not completed yet. Current status: ${job.status}`
                });
            }

            // Parse variant index
            const index = parseInt(variantIndex, 10);
            if (isNaN(index) || index < 0) {
                return reply.status(400).send({
                    error: 'INVALID_VARIANT_INDEX',
                    message: 'Variant index must be a non-negative integer'
                });
            }

            // Get variants from job result
            const variants = job.result?.variantsSchema?.variants;
            if (!variants || !Array.isArray(variants)) {
                return reply.status(404).send({
                    error: 'NO_VARIANTS',
                    message: 'No variants found in job result'
                });
            }

            if (index >= variants.length) {
                return reply.status(404).send({
                    error: 'VARIANT_NOT_FOUND',
                    message: `Variant at index ${index} not found. Job has ${variants.length} variants.`
                });
            }

            const variant = variants[index];

            // Initialize improvement service
            const improvementService = createVariantImprovementService();

            // Improve the variant
            fastify.log.info({ jobId, variantIndex: index, feedback }, 'Improving variant based on feedback');

            const improvement = await improvementService.improveVariant({
                originalCode: variant.javascript_code || '',
                targetSelector: variant.target_selector || '',
                variantDescription: variant.description || '',
                userFeedback: feedback,
                // Screenshot with variant applied would be passed from frontend if available
                screenshot: undefined
            });

            // Update the variant in the job result
            variants[index] = {
                ...variant,
                javascript_code: improvement.javascript_code,
                improvement_notes: improvement.improvements_made
            };

            // Update the job with the improved variant
            await VariantJobDAL.updateJob(jobId, {
                result: {
                    ...job.result,
                    variantsSchema: {
                        ...job.result.variantsSchema,
                        variants
                    }
                }
            });

            fastify.log.info({
                jobId,
                variantIndex: index,
                improvements: improvement.improvements_made,
                confidence: improvement.confidence
            }, 'Variant improved successfully');

            return reply.send({
                success: true,
                variant: variants[index],
                improvements: improvement.improvements_made,
                confidence: improvement.confidence
            });

        } catch (error) {
            fastify.log.error({ err: error }, 'Failed to improve variant');

            if (error instanceof Error) {
                return reply.status(500).send({
                    error: 'INTERNAL_ERROR',
                    message: error.message
                });
            }

            return reply.status(500).send({
                error: 'INTERNAL_ERROR',
                message: 'Failed to improve variant'
            });
        }
    });

}
</file>

<file path="src/services/variant-job-processor.ts">
// @ts-nocheck
import { VariantJobDAL } from '@infra/dal';
import { createVariantGenerationService } from '@features/variant_generation/variant-generation';
import { createPlaywrightCrawler } from '@features/crawler';
import { createScreenshotStorageService } from '@services/screenshot-storage';
import { getServiceConfig } from '@infra/config/services';
import { prisma } from '@infra/prisma';
import { HIGH_QUALITY_SCREENSHOT_OPTIONS } from '@shared/screenshot-config';
import { getVariantGenerationAIConfig } from '@shared/ai-config';
import { DEMO_CONDITION, getDemoSelector } from '@shared/demo-config';

export class VariantJobProcessor {
    private variantGenerationService: any;
    private screenshotStorage: any;

    constructor() {
        const config = getServiceConfig();
        const crawler = createPlaywrightCrawler(config.crawler);
        this.screenshotStorage = createScreenshotStorageService();
        this.variantGenerationService = createVariantGenerationService(crawler, this.screenshotStorage, prisma);
    }

    async processVariantJob(jobId: string, projectId: string, hypothesis: any): Promise<void> {
        console.log(`[VARIANT_JOB] Starting processing for job ${jobId}`);
        
        try {
            // Update job status to running
            await VariantJobDAL.updateJob(jobId, {
                status: 'RUNNING',
                progress: 10,
                startedAt: new Date(),
            });

            // Get project data
            const project = await this.variantGenerationService.getCachedProject(projectId);
            if (!project) {
                throw new Error(`Project not found: ${projectId}`);
            }
            
            const url = `https://${project.shopDomain}`;
            console.log(`[VARIANT_JOB] Using shop domain: ${project.shopDomain}, URL: ${url}`);

            // Update progress
            await VariantJobDAL.updateJob(jobId, {
                progress: 20,
            });

            // Run the initial analysis in parallel (screenshot, DOM analysis, brand analysis)
            console.log(`[VARIANT_JOB] Starting parallel operations for job ${jobId}`);
            
            // Check for cached screenshot and HTML first
            const pageType = this.getPageType(url);
            const cachedData = await this.screenshotStorage.getScreenshotWithHtml(
                projectId, 
                pageType, 
                HIGH_QUALITY_SCREENSHOT_OPTIONS
            );
            
            let screenshot: string;
            let htmlContent: string | null = null;
            
            if (cachedData.screenshot) {
                console.log(`[VARIANT_JOB] Using cached screenshot and HTML for ${pageType} page`);
                screenshot = cachedData.screenshot;
                htmlContent = cachedData.html;
            } else {
                console.log(`[VARIANT_JOB] Taking new screenshot for ${url}`);
                screenshot = await this.variantGenerationService.crawlerService.takePartialScreenshot(url, { width: 1920, height: 1080 }, true, { type: 'shopify_password', password: 'reitri', shopDomain: project.shopDomain });
            }
            
            const [injectionPoints, brandAnalysis] = await Promise.all([
                // Use demo selector if enabled (same as variant generation)
                DEMO_CONDITION
                    ? this.variantGenerationService.domAnalyzer.analyzeWithHardcodedSelector(
                        url,
                        hypothesis.description,
                        projectId,
                        getDemoSelector('variants'),
                        htmlContent,
                        { type: 'shopify_password', password: 'reitri', shopDomain: project.shopDomain }
                    )
                    : this.variantGenerationService.domAnalyzer.analyzeForHypothesisWithHtml(
                        url,
                        hypothesis.description,
                        projectId,
                        htmlContent,
                        { type: 'shopify_password', password: 'reitri', shopDomain: project.shopDomain }
                    ),
                this.variantGenerationService.getCachedBrandAnalysis(projectId)
            ]);

            console.log(`[VARIANT_JOB] Parallel operations completed for job ${jobId}`);
            
            if (!brandAnalysis) {
                throw new Error(`No brand analysis available for project ${projectId}. Please run brand analysis first.`);
            }

            // Update progress
            await VariantJobDAL.updateJob(jobId, {
                progress: 40,
            });

            // Generate the variant description using AI
            console.log(`[VARIANT_JOB] Generating AI response for job ${jobId} with Gemini 2.5 Pro`);
            const aiConfig = getVariantGenerationAIConfig();
            const { generateObject } = await import('ai');
            const { google } = await import('@ai-sdk/google');
            
            // Get job index to determine which variant to generate
            const jobIndex = await this.getJobIndex(jobId, projectId);
            
            const response = await generateObject({
                model: google(aiConfig.model, {
                    apiKey: aiConfig.apiKey,
                }),
                schema: this.variantGenerationService.basicVariantsResponseSchema,
                messages: [
                    {
                        role: 'user',
                        content: [
                            { type: "text", text: this.variantGenerationService.buildVariantGenerationPrompt(hypothesis, jobIndex) },
                            { type: "text", text: brandAnalysis },
                            { type: "image", image: `data:image/png;base64,${screenshot}` }
                        ]
                    }
                ]
            });

            // Generate a single variant based on the job index
            const variant = response.object.variants[0]; // Since we're generating 1 variant per job now
            
            console.log(`[VARIANT_JOB] Generated variant ${variant.variant_label} for job ${jobId} (index: ${jobIndex})`);

            // Update progress
            await VariantJobDAL.updateJob(jobId, {
                progress: 60,
            });

            // Generate code for this variant
            console.log(`[VARIANT_JOB] Generating code for variant ${variant.variant_label} for job ${jobId}`);
            let codeResult;
            try {
                codeResult = await this.variantGenerationService.codeGenerator.generateCode(
                    variant, 
                    hypothesis, 
                    brandAnalysis, 
                    screenshot, 
                    injectionPoints
                );
            } catch (error) {
                console.error(`[VARIANT_JOB] Failed to generate code for variant ${variant.variant_label}:`, error);
                codeResult = null;
            }

            // Create the final variant object (screenshots are already taken by the main process)
            const finalVariant = {
                ...variant,
                javascript_code: codeResult?.javascript_code || '',
                execution_timing: codeResult?.execution_timing || 'dom_ready',
                target_selector: codeResult?.target_selector || '',
                implementation_instructions: codeResult?.implementation_instructions || variant.description,
                screenshot: '' // Screenshots are handled by the main process
            };

            // Update job with result
            await VariantJobDAL.updateJob(jobId, {
                status: 'COMPLETED',
                progress: 100,
                result: {
                    variantsSchema: {
                        variants: [finalVariant]
                    }
                },
                completedAt: new Date(),
            });

            console.log(`[VARIANT_JOB] Successfully completed job ${jobId} for variant ${variant.variant_label}`);

        } catch (error) {
            console.error(`[VARIANT_JOB] Failed to process job ${jobId}:`, error);
            
            // Update job with error
            await VariantJobDAL.updateJob(jobId, {
                status: 'FAILED',
                error: error instanceof Error ? error.message : 'Unknown error occurred',
                completedAt: new Date(),
            });
        }
    }

    private async getJobIndex(jobId: string, projectId: string): Promise<number> {
        // Get all jobs for this project and find the index of this job
        const jobs = await VariantJobDAL.getJobsByProject(projectId);
        const jobIndex = jobs.findIndex(job => job.id === jobId);
        return jobIndex >= 0 ? jobIndex : 0;
    }

    async processVariantJobs(jobIds: string[], projectId: string, hypothesis: any): Promise<void> {
        console.log(`[VARIANT_JOB] Starting processing for ${jobIds.length} variant jobs`);
        
        // Process all jobs in parallel with proper memory management
        const promises = jobIds.map((jobId, index) => 
            this.processVariantJobWithCleanup(jobId, projectId, hypothesis, index)
        );

        try {
            await Promise.all(promises);
            console.log(`[VARIANT_JOB] Completed processing all ${jobIds.length} variant jobs`);
        } catch (error) {
            console.error(`[VARIANT_JOB] Some variant jobs failed:`, error);
        }
    }

    private async processVariantJobWithCleanup(jobId: string, projectId: string, hypothesis: any, index: number): Promise<void> {
        console.log(`[VARIANT_JOB] Starting job ${index + 1}: ${jobId}`);
        
        // Log memory usage before processing
        this.logMemoryUsage(`Before job ${index + 1}`);
        
        try {
            await this.processVariantJob(jobId, projectId, hypothesis);
            console.log(`[VARIANT_JOB] Successfully completed job ${index + 1}: ${jobId}`);
        } catch (error) {
            console.error(`[VARIANT_JOB] Failed to process job ${index + 1}: ${jobId}`, error);
            throw error; // Re-throw to be caught by Promise.all
        } finally {
            // Force garbage collection after each job to manage memory
            this.forceGarbageCollection();
            this.logMemoryUsage(`After job ${index + 1}`);
        }
    }

    private logMemoryUsage(context: string): void {
        if (process.memoryUsage) {
            const memUsage = process.memoryUsage();
            console.log(`[MEMORY] ${context} - RSS: ${Math.round(memUsage.rss / 1024 / 1024)}MB, Heap: ${Math.round(memUsage.heapUsed / 1024 / 1024)}MB`);
        }
    }

    private forceGarbageCollection(): void {
        if (global.gc) {
            global.gc();
            console.log(`[MEMORY] Forced garbage collection`);
        }
    }


    private getPageType(url: string): 'home' | 'pdp' | 'about' | 'other' {
        const urlLower = url.toLowerCase();
        
        // Check for product pages first
        if (urlLower.includes('/products/') || urlLower.includes('/collections/')) {
            return 'pdp';
        }
        
        // Check for about pages
        if (urlLower.includes('/about')) {
            return 'about';
        }
        
        // Check for home page - this should be the most common case
        // Home page is typically just the domain or domain with trailing slash
        const urlObj = new URL(url);
        const pathname = urlObj.pathname;
        
        // If no path or just a trailing slash, it's the home page
        if (!pathname || pathname === '/' || pathname === '') {
            return 'home';
        }
        
        // If path is just common home page indicators
        if (pathname === '/home' || pathname === '/index' || pathname === '/index.html') {
            return 'home';
        }
        
        return 'other';
    }

    async cleanup(): Promise<void> {
        await this.prisma.$disconnect();
    }
}

export function createVariantJobProcessor(): VariantJobProcessor {
    return new VariantJobProcessor();
}
</file>

<file path="env.template">
# Environment Configuration Template
# Copy this file to .env for development or .env.prod for production

# Database Configuration
DATABASE_URL="postgresql://username:password@localhost:5432/omen_db"

# Better Auth Configuration
BETTER_AUTH_SECRET="your-32-character-secret-key-here"
BETTER_AUTH_URL="http://localhost:3000"

# Shopify Configuration
SHOPIFY_API_KEY="your-shopify-api-key"
SHOPIFY_API_SECRET="your-shopify-api-secret"
SHOPIFY_SCOPES="read_products,write_products,read_orders,write_orders"
SHOPIFY_REDIRECT_URI="http://localhost:3000/auth/shopify/callback"
SHOPIFY_HOST_NAME="your-shopify-host-name"
SHOPIFY_API_VERSION="2025-01"

# Encryption Configuration
ENCRYPTION_KEY="your-32-character-encryption-key-here"

# Cloudflare KV Configuration
CLOUDFLARE_ACCOUNT_ID="your-cloudflare-account-id"
CLOUDFLARE_NAMESPACE_ID="your-kv-namespace-id"
CLOUDFLARE_API_TOKEN="your-cloudflare-api-token"

# OpenAI Configuration (commented out - using Google Gemini instead)
# OPENAI_API_KEY="your-openai-api-key"
# OPENAI_MODEL="gpt-4o"
# OPENAI_TEMPERATURE="0.3"
# OPENAI_MAX_TOKENS="2000"

# Google Gemini Configuration
GOOGLE_API_KEY="your-google-api-key"
# Alternative: GOOGLE_GENERATIVE_AI_API_KEY="your-google-api-key"
GOOGLE_MODEL="gemini-2.5-pro"
GOOGLE_TEMPERATURE="0.7"
GOOGLE_MAX_TOKENS="1000"

# Firecrawl Configuration
FIRECRAWL_API_KEY=

# Crawler Configuration
CRAWLER_HEADLESS="true"
CRAWLER_VIEWPORT_WIDTH="1280"
CRAWLER_VIEWPORT_HEIGHT="720"
CRAWLER_TIMEOUT="30000"
CRAWLER_WAIT_FOR="2000"
CHROME_PATH="/usr/bin/chromium"

# PostHog Configuration
POSTHOG_API_KEY="your-posthog-api-key"
POSTHOG_PROJECT_ID="your-posthog-project-id"
POSTHOG_HOST="https://eu.posthog.com"
POSTHOG_TIMEOUT="10000"
POSTHOG_RETRY_ATTEMPTS="3"

# Server Configuration
NODE_ENV="development"
PORT=3000
HOST="0.0.0.0"

# Frontend Configuration
FRONTEND_URL="http://localhost:3000"

# LangSmith Observability Configuration
LANGCHAIN_TRACING_V2=true
LANGCHAIN_API_KEY="your-langsmith-api-key"
LANGCHAIN_PROJECT="omen-backend"
LANGCHAIN_ENDPOINT="https://api.smith.langchain.com"

# AWS SQS Configuration
AWS_ACCESS_KEY_ID="your-aws-access-key"
AWS_SECRET_ACCESS_KEY="your-aws-secret-key"
AWS_REGION="eu-central-1"
SQS_QUEUE_URL="your-sqs-queue-url"
SQS_BATCH_SIZE="10"
SQS_POLL_INTERVAL="5000"
SQS_VISIBILITY_TIMEOUT="300"
</file>

<file path="src/features/variant_generation/dom-analyzer.ts">
// AI-Powered DOM Analysis Service for Variant Injection
import { generateObject } from 'ai';
import { google } from '@ai-sdk/google';
import { z } from 'zod';
import fetch from 'node-fetch';
import { CrawlerService } from '@features/crawler';
import { getAIConfig } from '@shared/ai-config';
import { createScreenshotStorageService, ScreenshotStorageService } from '@services/screenshot-storage';
import { simplifyHTML, simplifyHTMLForForensics, getHtmlInfo } from '@shared/utils/html-simplifier';
import * as cheerio from 'cheerio';
import { STANDARD_SCREENSHOT_OPTIONS } from '@shared/screenshot-config';
import { createElementDetector } from './element-detector';
import { createHypothesisAwareSelector } from './hypothesis-aware-selector';

// CSS selector validation utility using cheerio
function isValidCSSSelector(selector: string): boolean {
  try {
    // Use a simple regex check for basic CSS selector validation
    // This covers most common selectors
    const validSelectorPattern = /^[a-zA-Z0-9[\].#:\-\s,>+~()="'*^$|]+$/;
    return validSelectorPattern.test(selector);
  } catch {
    return false;
  }
}


// Get detailed information about selector matches for debugging
function getSelectorMatchInfo(selector: string, html: string): { found: boolean; count: number; elements: string[] } {
  try {
    const $ = cheerio.load(html);
    let elements = $(selector);

    // If selector targets a[href="/collections/all"], filter by text content to be more precise
    if (selector === 'a[href="/collections/all"]') {
      elements = elements.filter((_, el) => {
        const text = $(el).text().trim().toLowerCase();
        // More precise matching - must contain "shop all" as a phrase
        return text === 'shop all' ||
          text === 'shop all →' ||
          text === 'shop all>' ||
          text.includes('shop all') && text.length < 20; // Short text containing "shop all"
      });
    }

    const elementInfo = elements.map((_, el) => {
      const tagName = el.type === 'tag' ? el.name : 'unknown';
      const classes = $(el).attr('class') || '';
      const id = $(el).attr('id') || '';
      const text = $(el).text().trim();
      return `${tagName}${id ? `#${id}` : ''}${classes ? `.${classes.split(' ').join('.')}` : ''} "${text}"`;
    }).get();

    return {
      found: elements.length > 0,
      count: elements.length,
      elements: elementInfo
    };
  } catch (_error) {
    return {
      found: false,
      count: 0,
      elements: []
    };
  }
}

// Check if an ID is generated/unstable (contains numbers, hyphens, or template patterns)
function isGeneratedId(id: string): boolean {
  // Check for common patterns that indicate generated IDs
  const generatedPatterns = [
    /template--\d+/, // Shopify template IDs like "template--25767798276440"
    /slide-\d+/, // Slide IDs like "slide-123"
    /section-\d+/, // Section IDs like "section-123"
    /block-\d+/, // Block IDs like "block-123"
    /shopify-section-\w+/, // Shopify section IDs
    /^\d+$/, // Pure numbers
    /^[a-f0-9]{8,}$/i, // Long hex strings
    /^[a-z0-9]{20,}$/i, // Long alphanumeric strings
    /-\d{10,}$/, // Ends with long numbers
    /^[a-z]+-\d+-\d+/, // Pattern like "slide-123-456"
  ];

  return generatedPatterns.some(pattern => pattern.test(id));
}

// Check if a class is likely to be stable (not generated)
function isStableClass(className: string): boolean {
  // Stable class patterns (semantic, not generated)
  const stablePatterns = [
    /^[a-z]+-[a-z]+$/, // kebab-case like "card-wrapper"
    /^[a-z]+__[a-z]+$/, // BEM like "card__heading"
    /^[a-z]+--[a-z]+$/, // BEM modifier like "button--primary"
    /^[a-z]+$/, // simple words like "button", "card"
    /^[a-z]+-[a-z]+-[a-z]+$/, // triple kebab like "cart-drawer-form"
  ];

  // Avoid generated patterns
  const generatedPatterns = [
    /^\d+$/, // Pure numbers
    /^[a-f0-9]{8,}$/i, // Long hex strings
    /^[a-z0-9]{20,}$/i, // Long alphanumeric strings
    /-\d{10,}$/, // Ends with long numbers
    /^[a-z]+-\d+/, // Pattern like "card-123"
    /template--\d+/, // Template patterns
  ];

  return stablePatterns.some(pattern => pattern.test(className)) &&
    !generatedPatterns.some(pattern => pattern.test(className));
}

// Generate multiple fallback selectors for better reliability
function generateFallbackSelectors(element: cheerio.Cheerio<any>, $: cheerio.CheerioAPI): string[] {
  const selectors: string[] = [];
  const el = element[0];

  if (!el || el.type !== 'tag') return selectors;

  const tagName = el.name;
  const id = $(el).attr('id');
  const classes = $(el).attr('class');
  const dataTestId = $(el).attr('data-testid');
  const role = $(el).attr('role');
  const ariaLabel = $(el).attr('aria-label');
  const textContent = $(el).text?.()?.trim();

  // Strategy 1: Data attributes (most reliable - never generated)
  if (dataTestId) {
    selectors.push(`[data-testid="${dataTestId}"]`);
  }

  // Strategy 2: Role attribute (very reliable - semantic)
  if (role) {
    selectors.push(`${tagName}[role="${role}"]`);
  }

  // Strategy 3: Aria-label (very reliable - semantic)
  if (ariaLabel) {
    selectors.push(`${tagName}[aria-label="${ariaLabel}"]`);
  }

  // Strategy 4: ID selector (only if not generated)
  if (id && !isGeneratedId(id)) {
    selectors.push(`#${id}`);
  }

  // Strategy 5: Stable class-based selectors (prioritize semantic classes)
  if (classes) {
    const classList = classes.split(' ').filter(c => c.trim());
    const stableClasses = classList.filter(isStableClass);

    // Use only stable classes
    if (stableClasses.length > 0) {
      // Single most stable class
      selectors.push(`${tagName}.${stableClasses[0]}`);

      // Two most stable classes
      if (stableClasses.length > 1) {
        selectors.push(`${tagName}.${stableClasses.slice(0, 2).join('.')}`);
      }

      // All stable classes (if not too many)
      if (stableClasses.length <= 3) {
        selectors.push(`${tagName}.${stableClasses.join('.')}`);
      }
    }
  }

  // Strategy 6: Text content with tag (for unique text)
  if (textContent && textContent.length < 50 && textContent.length > 3) {
    selectors.push(`${tagName}:contains("${textContent}")`);
  }

  // Strategy 7: Parent-child relationships with stable classes
  const parent = $(el).parent();
  if (parent.length > 0) {
    const parentClasses = parent.attr('class');
    if (parentClasses) {
      const parentClassList = parentClasses.split(' ').filter(c => c.trim());
      const stableParentClasses = parentClassList.filter(isStableClass);

      if (stableParentClasses.length > 0) {
        // Use most stable parent class
        selectors.push(`.${stableParentClasses[0]} ${tagName}`);
        selectors.push(`.${stableParentClasses[0]} > ${tagName}`);

        // Add current element's stable class if available
        if (classes) {
          const stableClasses = classes.split(' ').filter(c => c.trim()).filter(isStableClass);
          if (stableClasses.length > 0) {
            selectors.push(`.${stableParentClasses[0]} ${tagName}.${stableClasses[0]}`);
          }
        }
      }
    }
  }

  // Strategy 8: Grandparent relationships (more stable than direct parent)
  const grandparent = $(el).parent().parent();
  if (grandparent.length > 0) {
    const grandparentClasses = grandparent.attr('class');
    if (grandparentClasses) {
      const grandparentClassList = grandparentClasses.split(' ').filter(c => c.trim());
      const stableGrandparentClasses = grandparentClassList.filter(isStableClass);

      if (stableGrandparentClasses.length > 0) {
        selectors.push(`.${stableGrandparentClasses[0]} ${tagName}`);
      }
    }
  }

  // Strategy 9: Sibling relationships (avoid position-based)
  const siblings = $(el).siblings(tagName);
  if (siblings.length === 0) {
    // If it's the only element of its type, use tag alone
    selectors.push(tagName);
  }

  // Remove duplicates and invalid selectors
  return [...new Set(selectors)].filter(selector => {
    try {
      $(selector);
      return true;
    } catch {
      return false;
    }
  });
}

// Test selector reliability by checking if it still works
function testSelectorReliability(selector: string, html: string): { works: boolean; confidence: number; reason: string } {
  const matchInfo = getSelectorMatchInfo(selector, html);

  if (!matchInfo.found) {
    return { works: false, confidence: 0, reason: 'Selector does not match any elements' };
  }

  if (matchInfo.count > 1) {
    return { works: false, confidence: 0.3, reason: `Selector matches ${matchInfo.count} elements, should match exactly 1` };
  }

  // Check for generated/unstable patterns
  const hasGeneratedId = /#.*template--\d+|#.*slide-\d+|#.*section-\d+|#.*block-\d+|#.*shopify-section/.test(selector);
  const hasGeneratedClass = /\.\d+\.|\.\w+\d{10,}\.|\.\w+-\d{10,}\./.test(selector);
  const hasComplexChain = selector.split('.').length > 3 || selector.split(' ').length > 4;

  if (hasGeneratedId || hasGeneratedClass) {
    return { works: false, confidence: 0.1, reason: 'Selector contains generated/unstable patterns' };
  }

  // Check selector stability
  let confidence = 0.8; // Base confidence
  let reason = 'Selector works and matches exactly 1 element';

  // Prefer more stable selectors
  if (selector.includes('[data-testid=')) {
    confidence = 0.95;
    reason += ' (data-testid - most stable)';
  } else if (selector.includes('[role=') || selector.includes('[aria-label=')) {
    confidence = 0.9;
    reason += ' (ARIA attribute - very stable)';
  } else if (selector.startsWith('#') && !hasGeneratedId) {
    confidence = 0.85;
    reason += ' (ID selector - stable)';
  } else if (selector.match(/^[a-z]+\.[a-z-]+$/) || selector.match(/^[a-z]+\.[a-z]+__[a-z]+$/)) {
    confidence = 0.8;
    reason += ' (semantic class - stable)';
  } else if (selector.includes(':contains(')) {
    confidence = 0.6;
    reason += ' (text-based - less stable)';
  } else if (hasComplexChain) {
    confidence = 0.4;
    reason += ' (complex chain - fragile)';
  } else if (selector.includes(':nth-child(')) {
    confidence = 0.3;
    reason += ' (position-based - very fragile)';
  }

  return { works: true, confidence, reason };
}

// Clean selector by removing invalid parts like :contains()
function cleanCSSSelector(selector: string): string {
  // Remove :contains() pseudo-selector and similar invalid selectors
  return selector
    .replace(/:contains\([^)]*\)/g, '') // Remove :contains() pseudo-selector
    .replace(/\s+/g, ' ') // Normalize whitespace
    .trim();
}

// Removed unused DOMAnalysisResult interface

export interface ElementSpatialContext {
  parentContainer?: {
    selector: string;
    layout: 'grid' | 'flex' | 'block' | 'inline' | 'table';
    styles: Record<string, string>; // Key computed styles
  };
  siblings?: Array<{
    selector: string;
    position: 'before' | 'after';
    distance: number; // pixels
  }>;
  children?: Array<{
    selector: string;
    type: string; // tag name
    hasInteractions: boolean;
  }>;
}

export interface ElementInteractionContext {
  existingHandlers: string[]; // ["click", "hover", "focus"]
  animations: Array<{
    property: string;
    duration: string;
    timing: string;
  }>;
  hoveredAncestors: string[]; // Parent elements with hover effects
  zIndex: number;
}

export interface InsertionStrategy {
  method: 'before' | 'after' | 'prepend' | 'append' | 'replace' | 'wrap';
  targetSelector: string; // More specific selector for insertion
  reasoning: string;
  example: string; // Example code snippet
  fallbacks: InsertionStrategy[]; // Alternative strategies if primary fails
}

export interface InjectionPoint {
  type: 'button' | 'text' | 'image' | 'container' | 'form' | 'navigation' | 'price' | 'title' | 'description';
  selector: string;
  confidence: number; // 0-1, how confident we are this selector will work
  description: string;
  boundingBox: {
    x: number;
    y: number;
    width: number;
    height: number;
  };
  alternativeSelectors: string[]; // Fallback selectors with reliability scores
  context: string; // What this element is used for (e.g., "main call-to-action button")
  reasoning: string; // Why this selector was chosen
  hypothesis: string; // The hypothesis this was found for
  url: string; // The URL this was found on
  timestamp: string; // When this was created
  tested: boolean; // Whether this selector has been tested
  successRate?: number; // Success rate if tested multiple times
  originalText?: string; // Original text content of the element (for text length considerations)
  selectorReliability?: {
    works: boolean;
    confidence: number;
    reason: string;
  };
  // NEW: Rich element context for better variant generation
  elementContext?: {
    computedStyles?: Record<string, string>; // Important styles like position, overflow, display
    spatial?: ElementSpatialContext;
    interactions?: ElementInteractionContext;
  };
  // NEW: Insertion strategies based on variant type
  insertionStrategy?: InsertionStrategy;
}

// Removed unused PageStructure interface

// Simplified schema for variant injection - only what we actually need
const elementFoundSchema = z.object({
  css_selector: z.string().describe('CSS selector that targets exactly 1 element'),
  element_text: z.string().optional().describe('Text content of the element if any'),
  section_context: z.string().optional().describe('Section or context where element was found'),
  confidence: z.number().min(0).max(1).describe('Confidence this selector will work (0-1)'),
  reasoning: z.string().describe('Why this selector was chosen'),
  alternative_selectors: z.array(z.string()).optional().describe('Alternative fallback selectors')
});

const elementNotFoundSchema = z.object({
  NOT_FOUND: z.boolean().describe('True if element not found'),
  reason: z.string().describe('Why element was not found'),
  suggestions: z.array(z.string()).describe('Suggestions for finding similar elements')
});

const injectionPointSchema = z.union([elementFoundSchema, elementNotFoundSchema]);

// Removed unused schemas - we only need injectionPointSchema for this service
// Cache check

export interface DOMAnalyzerService {
  analyzeForHypothesis(
    url: string,
    hypothesis: string,
    projectId: string,
    authentication?: { type: 'shopify_password'; password: string, shopDomain: string }
  ): Promise<InjectionPoint[]>;

  analyzeForHypothesisWithHtml(
    url: string,
    hypothesis: string,
    projectId: string,
    htmlContent: string | null,
    authentication?: { type: 'shopify_password'; password: string, shopDomain: string }
  ): Promise<InjectionPoint[]>;

  analyzeWithHardcodedSelector(
    url: string,
    hypothesis: string,
    projectId: string,
    hardcodedSelector: string,
    htmlContent: string | null,
    authentication?: { type: 'shopify_password'; password: string, shopDomain: string }
  ): Promise<InjectionPoint[]>;
}

export class DOMAnalyzerServiceImpl implements DOMAnalyzerService {
  private screenshotStorage: ScreenshotStorageService;

  constructor(
    private crawlerService: CrawlerService
  ) {
    this.screenshotStorage = createScreenshotStorageService();
  }

  async analyzeForHypothesisWithHtml(
    url: string,
    hypothesis: string,
    projectId: string,
    htmlContent: string | null,
    authentication?: { type: 'shopify_password'; password: string, shopDomain: string }
  ): Promise<InjectionPoint[]> {
    console.log(`[DOM_ANALYZER] Starting analysis for hypothesis: ${hypothesis}`);

    // If we already have HTML content (from screenshot service), use it
    // Otherwise fetch fresh page source
    let pageSource: string;

    if (htmlContent) {
      console.log(`[DOM_ANALYZER] Using provided HTML content: ${htmlContent.length} chars`);
      pageSource = htmlContent;
    } else {
      console.log(`[DOM_ANALYZER] No HTML provided, fetching fresh page source from: ${url}`);

      try {
        // Use simple fetch - authentication already handled by screenshot service
        const response = await fetch(url);
        pageSource = await response.text();
        console.log(`[DOM_ANALYZER] Fetched page source: ${pageSource.length} chars`);
      } catch (fetchError) {
        console.error(`[DOM_ANALYZER] Failed to fetch page source:`, fetchError);
        return [];
      }
    }

    try {

      // Clean up the HTML with cheerio - remove scripts, styles, comments
      const cheerio = require('cheerio');
      const $ = cheerio.load(pageSource);

      // Remove script tags, style tags, and comments
      $('script').remove();
      $('style').remove();
      $('noscript').remove();
      $('link[rel="stylesheet"]').remove();

      // Get the cleaned HTML
      const cleanedHTML = $.html();
      console.log(`[DOM_ANALYZER] Cleaned HTML: ${cleanedHTML.length} chars`);

      // First try the new hypothesis-aware selector generation
      console.log(`[DOM_ANALYZER] Trying hypothesis-aware selector generation`);
      const hypothesisSelector = createHypothesisAwareSelector(cleanedHTML);
      const hypothesisCandidates = await hypothesisSelector.generateSelector(hypothesis);

      if (hypothesisCandidates.length > 0) {
        console.log(`[DOM_ANALYZER] Found ${hypothesisCandidates.length} candidates using hypothesis-aware approach`);

        // Convert hypothesis candidates to injection points
        const injectionPoints: InjectionPoint[] = hypothesisCandidates.map(candidate => {
          const type = this.determineElementType(
            candidate.context.elementType,
            {}
          );

          // Extract rich element context for this candidate
          const elementContext = this.extractElementContext(candidate.selector, cleanedHTML);

          // Generate insertion strategy based on hypothesis
          const insertionStrategy = this.generateInsertionStrategy(candidate.selector, hypothesis, cleanedHTML);

          return {
            type,
            selector: candidate.selector,
            confidence: candidate.confidence,
            description: candidate.reasoning,
            boundingBox: {
              x: 0,
              y: 0,
              width: 0,
              height: 0
            },
            alternativeSelectors: candidate.alternativeSelectors,
            context: candidate.context.htmlSnippet.substring(0, 200),
            reasoning: candidate.reasoning,
            hypothesis,
            url,
            timestamp: new Date().toISOString(),
            tested: false,
            originalText: candidate.context.elementText,
            selectorReliability: {
              works: candidate.validation.exists && candidate.validation.unique,
              confidence: candidate.confidence,
              reason: `Hypothesis-aware: ${candidate.validation.stable ? 'stable' : 'unstable'} selector`
            },
            elementContext, // Add the rich context
            insertionStrategy // Add the insertion strategy
          };
        });

        console.log(`[DOM_ANALYZER] Generated ${injectionPoints.length} injection points from hypothesis-aware approach`);
        return injectionPoints;
      }

      // Fallback to the multi-strategy element detector
      console.log(`[DOM_ANALYZER] Falling back to multi-strategy element detector`);
      const elementDetector = createElementDetector(cleanedHTML);
      const detectionResult = await elementDetector.detectElement(hypothesis);

      if (!detectionResult.found) {
        console.log(`[DOM_ANALYZER] No elements found using multi-strategy approach`);
        console.log(`[DOM_ANALYZER] Suggestions:`, detectionResult.suggestions);
        return [];
      }

      console.log(`[DOM_ANALYZER] Found ${detectionResult.candidates.length} element candidates`);

      // Convert candidates to injection points
      const injectionPoints: InjectionPoint[] = detectionResult.candidates.map((candidate, index) => {
        const type = this.determineElementType(candidate.element.tagName, candidate.element.attributes);

        // Extract rich element context for this candidate
        const elementContext = this.extractElementContext(candidate.selector, cleanedHTML);

        // Generate insertion strategy based on hypothesis
        const insertionStrategy = this.generateInsertionStrategy(candidate.selector, hypothesis, cleanedHTML);

        return {
          type,
          selector: candidate.selector,
          confidence: candidate.confidence,
          description: candidate.reasoning,
          boundingBox: {
            x: 0, // Will be filled by the crawler
            y: 0,
            width: 0,
            height: 0
          },
          alternativeSelectors: detectionResult.candidates
            .filter((_, i) => i !== index)
            .map(c => c.selector),
          context: `${candidate.strategy} strategy`,
          reasoning: candidate.reasoning,
          hypothesis,
          url,
          timestamp: new Date().toISOString(),
          tested: false,
          originalText: candidate.element.text,
          selectorReliability: {
            works: true,
            confidence: candidate.confidence,
            reason: `${candidate.strategy} strategy - ${candidate.reasoning}`
          },
          elementContext, // Add the rich context
          insertionStrategy // Add the insertion strategy
        };
      });

      console.log(`[DOM_ANALYZER] Generated ${injectionPoints.length} injection points`);
      return injectionPoints;

    } catch (error) {
      console.error(`[DOM_ANALYZER] Error fetching page source:`, error);
      console.log(`[DOM_ANALYZER] Falling back to provided HTML content`);

      // Fallback to using provided HTML if fetch fails
      if (htmlContent) {
        const elementDetector = createElementDetector(htmlContent);
        const detectionResult = await elementDetector.detectElement(hypothesis);

        if (!detectionResult.found) {
          return [];
        }

        // Convert to injection points (simplified)
        return detectionResult.candidates.map(candidate => ({
          type: 'text',
          selector: candidate.selector,
          confidence: candidate.confidence,
          description: candidate.reasoning,
          boundingBox: { x: 0, y: 0, width: 0, height: 0 },
          alternativeSelectors: [],
          context: candidate.strategy,
          reasoning: candidate.reasoning,
          hypothesis,
          url,
          timestamp: new Date().toISOString(),
          tested: false,
          originalText: candidate.element.text,
          selectorReliability: {
            works: true,
            confidence: candidate.confidence,
            reason: candidate.reasoning
          }
        }));
      }

      // Final fallback
      return this.analyzeForHypothesis(url, hypothesis, projectId, authentication);
    }
  }

  async analyzeForHypothesis(
    url: string,
    hypothesis: string,
    projectId: string,
    authentication?: { type: 'shopify_password'; password: string, shopDomain: string }
  ): Promise<InjectionPoint[]> {
    console.log(`[DOM_ANALYZER] Analyzing page for hypothesis: "${hypothesis}"`);

    // Check storage first for both screenshot and HTML
    const pageType = this.getPageType(url);
    const cachedData = await this.screenshotStorage.getScreenshotWithHtml(
      projectId,
      pageType,
      STANDARD_SCREENSHOT_OPTIONS
    );

    let crawlResult;
    if (cachedData.screenshot && cachedData.html) {
      console.log(`[DOM_ANALYZER] Using stored screenshot and HTML for ${pageType} page`);
      // We have both screenshot and HTML, no need to crawl
      crawlResult = {
        url,
        html: cachedData.html,
        screenshot: cachedData.screenshot,
        error: null
      };
    } else if (cachedData.screenshot) {
      console.log(`[DOM_ANALYZER] Using stored screenshot for ${pageType} page, but need to fetch HTML`);
      // We have screenshot but need HTML, so we need to crawl but without screenshot
      crawlResult = await this.crawlerService.crawlPage(url, {
        viewport: { width: 1920, height: 1080 },
        waitFor: 3000,
        screenshot: { fullPage: false, quality: 60 },
        authentication
      });
      // Use stored screenshot instead of crawled one
      crawlResult.screenshot = cachedData.screenshot;

      // Store the new HTML content
      if (crawlResult.html) {
        const simplifiedHtml = simplifyHTML(crawlResult.html);
        const screenshotId = await this.screenshotStorage.saveScreenshot(
          projectId,
          pageType,
          url,
          STANDARD_SCREENSHOT_OPTIONS,
          cachedData.screenshot!, // Use the cached screenshot
          simplifiedHtml
        );
        console.log(`[DOM_ANALYZER] HTML content saved with ID: ${screenshotId} (${getHtmlInfo(simplifiedHtml)})`);
      }
    } else {
      console.log(`[DOM_ANALYZER] Taking new screenshot and HTML for ${url}`);
      crawlResult = await this.crawlerService.crawlPage(url, {
        viewport: { width: 1920, height: 1080 },
        waitFor: 3000,
        screenshot: { fullPage: true, quality: 80 },
        authentication
      });

      // Store the new screenshot and HTML
      if (crawlResult.screenshot && crawlResult.html) {
        const simplifiedHtml = simplifyHTML(crawlResult.html);
        const screenshotId = await this.screenshotStorage.saveScreenshot(
          projectId,
          pageType,
          url,
          STANDARD_SCREENSHOT_OPTIONS,
          crawlResult.screenshot,
          simplifiedHtml
        );
        console.log(`[DOM_ANALYZER] Screenshot and HTML saved with ID: ${screenshotId} (${getHtmlInfo(simplifiedHtml)})`);
      }
    }

    if (crawlResult.error) {
      throw new Error(`Failed to crawl page: ${crawlResult.error}`);
    }


    // Optimize HTML for AI analysis (memory efficient)
    const optimizedHTML = this.optimizeHTMLForAnalysis(crawlResult.html, hypothesis);
    console.log(`[DOM_ANALYZER] Optimized HTML from ${crawlResult.html.length} to ${optimizedHTML.length} characters (${Math.round((1 - optimizedHTML.length / crawlResult.html.length) * 100)}% reduction)`);

    // Clear large HTML from memory before AI processing
    crawlResult.html = ''; // Free memory

    // Force garbage collection if available
    if (global.gc) {
      global.gc();
    }

    // Use AI to find specific injection points for this hypothesis
    const aiConfig = getAIConfig();
    const result = await generateObject({
      model: google(aiConfig.model),
      schema: injectionPointSchema,
      messages: [
        {
          role: 'user',
          content: [
            {
              type: 'text',
              text: this.buildHypothesisFocusedPrompt(hypothesis)
            },
            {
              type: 'text',
              text: `HTML Content:\n${optimizedHTML}`
            }
          ]
        }
      ]
    });

    // optimizedHTML will be garbage collected after this scope

    // Process the simplified result
    const forensicsResult = result.object;

    // Check if element was found
    if ('NOT_FOUND' in forensicsResult && forensicsResult.NOT_FOUND === true) {
      console.log(`[DOM_ANALYZER] Element not found: ${forensicsResult.reason}`);
      console.log(`[DOM_ANALYZER] Suggestions:`, forensicsResult.suggestions);
      return []; // Return empty array if not found
    }

    // Type guard to ensure we have the success result
    if (!('css_selector' in forensicsResult)) {
      console.error(`[DOM_ANALYZER] Invalid response format from AI`);
      return [];
    }

    // Validate that the selector exists in the HTML
    const selector = forensicsResult.css_selector;
    const matchInfo = getSelectorMatchInfo(selector, optimizedHTML);
    let finalSelector = selector;
    let alternativeSelectors: string[] = [];
    let reliability = testSelectorReliability(selector, optimizedHTML);

    if (!matchInfo.found) {
      console.warn(`[DOM_ANALYZER] Generated selector "${selector}" does not match any elements in HTML.`);
      console.warn(`[DOM_ANALYZER] Available classes in HTML:`, this.extractAvailableClasses(optimizedHTML).slice(0, 10));

      // Try to find the element using text content or other methods
      console.log(`[DOM_ANALYZER] Attempting to find element using fallback methods...`);
      const $ = cheerio.load(optimizedHTML);
      const elementText = forensicsResult.element_text;

      if (elementText) {
        // Try to find by text content
        const textElements = $(`*:contains("${elementText}")`).filter((_, el) => {
          return $(el).text().trim() === elementText.trim();
        });

        if (textElements.length > 0) {
          const targetElement = textElements.first();
          alternativeSelectors = generateFallbackSelectors(targetElement, $);

          // Find the best working selector
          for (const altSelector of alternativeSelectors) {
            const altMatchInfo = getSelectorMatchInfo(altSelector, optimizedHTML);
            if (altMatchInfo.found && altMatchInfo.count === 1) {
              finalSelector = altSelector;
              reliability = testSelectorReliability(altSelector, optimizedHTML);
              console.log(`[DOM_ANALYZER] Found working fallback selector: "${altSelector}"`);
              break;
            }
          }
        }
      }

      // Still return the result but with lower confidence
      forensicsResult.confidence = Math.min(forensicsResult.confidence || 0.5, 0.3);
    } else {
      console.log(`[DOM_ANALYZER] Selector validation passed: "${selector}" found ${matchInfo.count} element(s):`, matchInfo.elements);

      // Generate fallback selectors for the working selector
      const $ = cheerio.load(optimizedHTML);
      const elements = $(selector);
      if (elements.length > 0) {
        alternativeSelectors = generateFallbackSelectors(elements.first(), $);
        // Remove the primary selector from alternatives
        alternativeSelectors = alternativeSelectors.filter(s => s !== selector);
      }
    }

    // Clean the CSS selector
    const cleanedSelector = cleanCSSSelector(finalSelector);

    // Validate selector and log warnings for invalid ones
    if (!isValidCSSSelector(cleanedSelector)) {
      console.warn(`[DOM_ANALYZER] Invalid CSS selector detected: "${finalSelector}" -> cleaned to: "${cleanedSelector}"`);
    }

    // Transform the result to InjectionPoint format
    const injectionPoint: InjectionPoint = {
      type: 'button', // Default type, could be enhanced based on element analysis
      selector: cleanedSelector,
      confidence: reliability.works ? reliability.confidence : Math.min(forensicsResult.confidence || 0.5, 0.3),
      description: forensicsResult.reasoning,
      boundingBox: {
        x: 0, // Will be filled by the crawler
        y: 0,
        width: 0,
        height: 0
      },
      alternativeSelectors: alternativeSelectors,
      context: forensicsResult.section_context || 'Element found',
      reasoning: forensicsResult.reasoning,
      hypothesis,
      url,
      timestamp: new Date().toISOString(),
      tested: false,
      originalText: forensicsResult.element_text || undefined,
      selectorReliability: reliability
    };

    console.log(`[DOM_ANALYZER] Found element: ${cleanedSelector}`);
    console.log(`[DOM_ANALYZER] Element details:`, {
      type: injectionPoint.type,
      selector: injectionPoint.selector,
      confidence: injectionPoint.confidence,
      reasoning: injectionPoint.reasoning.substring(0, 100) + '...'
    });

    return [injectionPoint];
  }

  private optimizeHTMLForAnalysis(html: string, _hypothesis: string): string {
    // Process HTML in chunks to reduce memory usage
    const chunkSize = 10000; // Process 10KB at a time
    const chunks = this.splitIntoChunks(html, chunkSize);

    let optimized = '';
    for (let i = 0; i < chunks.length; i++) {
      const chunk = chunks[i];

      // Process chunk with minimal memory operations
      const processedChunk = this.processHTMLChunk(chunk);
      optimized += processedChunk;

      // Force garbage collection hint for large chunks
      if (i % 5 === 0 && global.gc) {
        global.gc();
      }
    }

    // Use the full HTML with intelligent truncation if needed
    const maxLength = 50000; // ~12k tokens (increased significantly)
    if (optimized.length > maxLength) {
      // Simple truncation that preserves HTML structure
      const truncated = optimized.substring(0, maxLength);
      // Try to end at a reasonable point (end of tag)
      const lastTagEnd = truncated.lastIndexOf('>');
      if (lastTagEnd > maxLength * 0.9) {
        return truncated.substring(0, lastTagEnd + 1) + '\n\n... [HTML truncated for analysis]';
      }
      return truncated + '\n\n... [HTML truncated for analysis]';
    }

    return optimized;
  }

  private splitIntoChunks(str: string, chunkSize: number): string[] {
    const chunks = [];
    for (let i = 0; i < str.length; i += chunkSize) {
      chunks.push(str.substring(i, i + chunkSize));
    }
    return chunks;
  }

  private processHTMLChunk(chunk: string): string {
    // Use the forensics-specific HTML simplifier that preserves important attributes
    return simplifyHTMLForForensics(chunk);
  }


  private extractAvailableClasses(html: string): string[] {
    try {
      const $ = cheerio.load(html);
      const classes = new Set<string>();

      // Extract all class attributes from all elements
      $('[class]').each((_, element) => {
        const classAttr = $(element).attr('class');
        if (classAttr) {
          const classList = classAttr.split(/\s+/);
          classList.forEach(cls => {
            if (cls.trim()) {
              classes.add(cls.trim());
            }
          });
        }
      });

      return Array.from(classes);
    } catch (error) {
      console.warn(`[DOM_ANALYZER] Error extracting classes:`, error);
      return [];
    }
  }

  private buildHypothesisFocusedPrompt(hypothesis: string): string {
    return `You are a DOM analysis assistant. Find the exact element mentioned in the hypothesis and return a CSS selector that targets exactly 1 element.

HYPOTHESIS: "${hypothesis}"

CRITICAL RULES:
1. ONLY use CSS selectors that exist in the provided HTML - DO NOT invent or hallucinate class names
2. Find the SPECIFIC element mentioned in the hypothesis by matching text content or existing attributes
3. If a section is named (e.g., "Stay hydrated"), find the actual section containing that text, then the element within it
4. Use ONLY the classes, IDs, and attributes that are present in the HTML
5. AVOID GENERATED/UNSTABLE SELECTORS - Never use IDs or classes with these patterns:
   - template--123456789 (Shopify template IDs)
   - slide-123456789 (generated slide IDs)
   - section-123456789 (generated section IDs)
   - Any ID/class with long numbers or hex strings
   - Complex nested class chains with generated patterns
6. Prefer stable attributes in this order: data-testid, role, aria-*, semantic class names, then simple IDs
7. If using text content, match exactly (case-insensitive, trimmed)
8. Never create fictional class names like ".stay-hydrated-section" - use the actual classes from the HTML
9. Use simple, semantic selectors like ".card__heading" or "button[role='button']" instead of complex chains
10. Generate alternative_selectors array with fallback options using different strategies

SELECTOR VALIDATION:
- The selector MUST exist in the provided HTML
- The selector MUST target exactly 1 element
- The selector MUST be based on real attributes, not invented ones
- The selector MUST avoid generated/unstable patterns
- Provide alternative_selectors for better reliability

STABLE SELECTOR EXAMPLES:
✅ Good: ".card__heading" (semantic class)
✅ Good: "button[role='button']" (role attribute)
✅ Good: "[data-testid='product-title']" (data attribute)
✅ Good: "h3.card__heading" (tag + semantic class)
❌ Bad: "#Slide-template--25767798276440__featured_collection-1" (generated ID)
❌ Bad: ".card-wrapper.product-card-wrapper > div.card__content" (complex chain)
❌ Bad: "#shopify-section-sections--25767798538584__header" (generated ID)

OUTPUT FORMAT:
- If found: Return JSON with css_selector, element_text (if any), section_context, confidence (0-1), reasoning, and alternative_selectors array
- If not found: Return JSON with NOT_FOUND: true, reason, and suggestions array

EXAMPLE:
Hypothesis: "Change the 'Get waxy now' button in the 'Stay hydrated' section"
→ Look for actual HTML containing "Stay hydrated" text, then find the button with "Get waxy now" text
→ Use simple selectors like "button:contains('Get waxy now')" or ".button--primary"
→ Avoid complex chains with generated IDs or classes`;
  }

  private generateInsertionStrategy(
    selector: string,
    hypothesis: string,
    html: string
  ): InsertionStrategy | undefined {
    try {
      const $ = cheerio.load(html);
      const element = $(selector).first();
      if (element.length === 0) return undefined;

      // Determine what type of change based on hypothesis keywords
      const hypothesisLower = hypothesis.toLowerCase();

      // For ratings/reviews
      if (hypothesisLower.includes('rating') || hypothesisLower.includes('review') || hypothesisLower.includes('star')) {
        return this.getRatingsInsertionStrategy(element, $);
      }

      // For buttons/CTAs
      if (hypothesisLower.includes('button') || hypothesisLower.includes('cta') || hypothesisLower.includes('call-to-action')) {
        return this.getButtonInsertionStrategy(element, $);
      }

      // For badges/labels
      if (hypothesisLower.includes('badge') || hypothesisLower.includes('label') || hypothesisLower.includes('tag')) {
        return this.getBadgeInsertionStrategy(element, $);
      }

      // For replacing text/content
      if (hypothesisLower.includes('replac') || hypothesisLower.includes('chang')) {
        return this.getReplacementStrategy(element, $);
      }

      // Default strategy
      return this.getDefaultInsertionStrategy(element, $);
    } catch (error) {
      console.warn(`[DOM_ANALYZER] Error generating insertion strategy: ${error}`);
      return undefined;
    }
  }

  private getRatingsInsertionStrategy(element: cheerio.Cheerio<any>, _$: cheerio.CheerioAPI): InsertionStrategy {
    // For product cards, find the best place for ratings
    const isProductCard = element.attr('class')?.includes('product') || element.attr('class')?.includes('card');

    if (isProductCard) {
      // Look for info section within the card
      const infoSection = element.find('.card__information, .card__content, .product-info').first();
      if (infoSection.length > 0) {
        // Find title within info section
        const title = infoSection.find('h3, h4, .card__heading, [class*="title"]').first();
        if (title.length > 0) {
          return {
            method: 'before',
            targetSelector: this.makeSelector(title, element),
            reasoning: 'Ratings should appear right before the product title in the info section',
            example: 'titleElement.parentNode.insertBefore(ratingsElement, titleElement)',
            fallbacks: [
              {
                method: 'prepend',
                targetSelector: this.makeSelector(infoSection, element),
                reasoning: 'If title not found, prepend to info section',
                example: 'infoSection.prepend(ratingsElement)',
                fallbacks: []
              }
            ]
          };
        }

        // No title found, prepend to info section
        return {
          method: 'prepend',
          targetSelector: this.makeSelector(infoSection, element),
          reasoning: 'Add ratings at the start of the info section',
          example: 'infoSection.prepend(ratingsElement)',
          fallbacks: []
        };
      }

      // No info section, look for image to insert after
      const image = element.find('.card__media, img, picture').first();
      if (image.length > 0) {
        return {
          method: 'after',
          targetSelector: this.makeSelector(image, element),
          reasoning: 'Add ratings after the product image',
          example: 'imageElement.insertAdjacentElement("afterend", ratingsElement)',
          fallbacks: []
        };
      }
    }

    // Default for non-product cards
    return {
      method: 'prepend',
      targetSelector: '',
      reasoning: 'Add ratings at the beginning of the element',
      example: 'element.prepend(ratingsElement)',
      fallbacks: []
    };
  }

  private getButtonInsertionStrategy(element: cheerio.Cheerio<any>, _$: cheerio.CheerioAPI): InsertionStrategy {
    // Look for existing action areas
    const actions = element.find('.card__actions, .product-actions, [class*="action"]').first();
    if (actions.length > 0) {
      return {
        method: 'append',
        targetSelector: this.makeSelector(actions, element),
        reasoning: 'Add button to existing actions section',
        example: 'actionsSection.append(buttonElement)',
        fallbacks: []
      };
    }

    // Look for info section to append to
    const info = element.find('.card__information, .card__content').first();
    if (info.length > 0) {
      return {
        method: 'append',
        targetSelector: this.makeSelector(info, element),
        reasoning: 'Add button at the end of the info section',
        example: 'infoSection.append(buttonElement)',
        fallbacks: []
      };
    }

    return {
      method: 'append',
      targetSelector: '',
      reasoning: 'Add button at the end of the element',
      example: 'element.append(buttonElement)',
      fallbacks: []
    };
  }

  private getBadgeInsertionStrategy(element: cheerio.Cheerio<any>, _$: cheerio.CheerioAPI): InsertionStrategy {
    // Badges typically go on images or at the start
    const image = element.find('.card__media, img, picture').first();
    if (image.length > 0) {
      return {
        method: 'prepend',
        targetSelector: this.makeSelector(image.parent(), element),
        reasoning: 'Badges overlay on product images',
        example: 'imageContainer.style.position = "relative"; imageContainer.prepend(badgeElement)',
        fallbacks: []
      };
    }

    return {
      method: 'prepend',
      targetSelector: '',
      reasoning: 'Add badge at the start of the element',
      example: 'element.prepend(badgeElement)',
      fallbacks: []
    };
  }

  private getReplacementStrategy(_element: cheerio.Cheerio<any>, _$: cheerio.CheerioAPI): InsertionStrategy {
    return {
      method: 'replace',
      targetSelector: '',
      reasoning: 'Replace the entire content of the element',
      example: 'element.innerHTML = newContent',
      fallbacks: []
    };
  }

  private getDefaultInsertionStrategy(_element: cheerio.Cheerio<any>, _$: cheerio.CheerioAPI): InsertionStrategy {
    return {
      method: 'append',
      targetSelector: '',
      reasoning: 'Default strategy: append to element',
      example: 'element.append(newElement)',
      fallbacks: []
    };
  }

  private makeSelector(target: cheerio.Cheerio<any>, container: cheerio.Cheerio<any>): string {
    // Generate a selector for target relative to container
    if (target.length === 0) return '';

    const targetClasses = target.attr('class');
    if (targetClasses) {
      const firstClass = targetClasses.split(' ')[0];
      if (firstClass && !firstClass.match(/\d{5,}/)) {
        return `.${firstClass}`;
      }
    }

    const tag = target[0].name;
    const index = container.find(tag).index(target);
    if (index > 0) {
      return `${tag}:nth-of-type(${index + 1})`;
    }

    return tag;
  }

  private extractElementContext(selector: string, html: string): InjectionPoint['elementContext'] {
    try {
      const $ = cheerio.load(html);
      const element = $(selector).first();

      if (element.length === 0) return undefined;

      // Extract computed styles (from inline styles and classes)
      const computedStyles: Record<string, string> = {};
      const importantStyles = ['position', 'overflow', 'display', 'z-index', 'padding', 'margin'];
      const style = element.attr('style');
      if (style) {
        // Parse inline styles
        style.split(';').forEach(rule => {
          const [prop, value] = rule.split(':').map(s => s.trim());
          if (prop && value && importantStyles.some(s => prop.includes(s))) {
            computedStyles[prop] = value;
          }
        });
      }

      // Extract spatial context
      const parent = element.parent();
      const siblings = element.siblings();
      const children = element.children();

      const spatial: ElementSpatialContext = {
        parentContainer: parent.length > 0 ? {
          selector: this.generateSelectorForElement(parent, $),
          layout: this.detectLayoutType(parent),
          styles: this.extractKeyStyles(parent)
        } : undefined,
        siblings: siblings.map((_, sibling) => {
          const $sibling = $(sibling);
          return {
            selector: this.generateSelectorForElement($sibling, $),
            position: ($sibling.index() < element.index() ? 'before' : 'after') as 'before' | 'after',
            distance: 0 // Would need real rendering to calculate
          };
        }).get().slice(0, 3), // Limit to 3 nearest siblings
        children: children.map((_, child) => {
          const $child = $(child);
          return {
            selector: this.generateSelectorForElement($child, $),
            type: child.name,
            hasInteractions: this.hasInteractionHandlers($child)
          };
        }).get().slice(0, 5) // Limit to 5 children
      };

      // Extract interaction context
      const interactions: ElementInteractionContext = {
        existingHandlers: this.detectEventHandlers(element),
        animations: this.detectAnimations(element),
        hoveredAncestors: this.findHoveredAncestors(element, $),
        zIndex: parseInt(element.css('z-index') || '0') || 0
      };

      return {
        computedStyles,
        spatial,
        interactions
      };
    } catch (error) {
      console.warn(`[DOM_ANALYZER] Error extracting element context: ${error}`);
      return undefined;
    }
  }

  private generateSelectorForElement($el: cheerio.Cheerio<any>, _$: cheerio.CheerioAPI): string {
    const element = $el[0];
    if (!element || element.type !== 'tag') return '';

    // Try to generate a simple, reliable selector
    const id = $el.attr('id');
    if (id && !this.isGeneratedId(id)) {
      return `#${id}`;
    }

    const classes = $el.attr('class');
    if (classes) {
      const classList = classes.split(' ').filter(c => c.trim() && !this.isGeneratedClass(c));
      if (classList.length > 0) {
        return `${element.name}.${classList[0]}`;
      }
    }

    return element.name;
  }

  private detectLayoutType($el: cheerio.Cheerio<any>): 'grid' | 'flex' | 'block' | 'inline' | 'table' {
    const display = $el.css('display') || '';
    if (display.includes('grid')) return 'grid';
    if (display.includes('flex')) return 'flex';
    if (display.includes('table')) return 'table';
    if (display.includes('inline')) return 'inline';
    return 'block';
  }

  private extractKeyStyles($el: cheerio.Cheerio<any>): Record<string, string> {
    const keyProps = ['display', 'position', 'overflow', 'gap', 'padding', 'grid-template-columns'];
    const styles: Record<string, string> = {};

    keyProps.forEach(prop => {
      const value = $el.css(prop);
      if (value) {
        styles[prop] = value;
      }
    });

    return styles;
  }

  private hasInteractionHandlers($el: cheerio.Cheerio<any>): boolean {
    // Check for common interaction attributes
    const interactionAttrs = ['onclick', 'onhover', 'onfocus', 'href', 'data-action'];
    return interactionAttrs.some(attr => $el.attr(attr) !== undefined);
  }

  private detectEventHandlers($el: cheerio.Cheerio<any>): string[] {
    const handlers: string[] = [];

    // Check for inline handlers
    ['onclick', 'onmouseover', 'onfocus', 'onchange'].forEach(handler => {
      if ($el.attr(handler)) {
        handlers.push(handler.replace('on', ''));
      }
    });

    // Check if it's a clickable element
    if ($el.is('a, button') || $el.attr('href')) {
      handlers.push('click');
    }

    return handlers;
  }

  private detectAnimations($el: cheerio.Cheerio<any>): Array<{ property: string; duration: string; timing: string }> {
    // This is simplified - would need CSS parsing for full implementation
    const transition = $el.css('transition');
    if (transition && transition !== 'none') {
      return [{
        property: 'all',
        duration: '0.3s',
        timing: 'ease'
      }];
    }
    return [];
  }

  private findHoveredAncestors($el: cheerio.Cheerio<any>, $: cheerio.CheerioAPI): string[] {
    const ancestors: string[] = [];
    let current = $el.parent();

    while (current.length > 0 && ancestors.length < 3) {
      // Check if parent has hover pseudo-class (simplified check)
      const classes = current.attr('class');
      if (classes && classes.includes('hover')) {
        ancestors.push(this.generateSelectorForElement(current, $));
      }
      current = current.parent();
    }

    return ancestors;
  }

  private isGeneratedId(id: string): boolean {
    const patterns = [
      /template--\d+/,
      /\d{10,}/,
      /^[a-f0-9]{8,}$/i
    ];
    return patterns.some(p => p.test(id));
  }

  private isGeneratedClass(className: string): boolean {
    const patterns = [
      /^\d+$/,
      /^[a-f0-9]{8,}$/i,
      /-\d{10,}$/
    ];
    return patterns.some(p => p.test(className));
  }

  private determineElementType(tagName: string, attributes: Record<string, string>): 'button' | 'text' | 'image' | 'container' | 'form' | 'navigation' | 'price' | 'title' | 'description' {
    // Check for explicit role
    const role = attributes.role?.toLowerCase();
    if (role) {
      if (role.includes('button')) return 'button';
      if (role.includes('navigation')) return 'navigation';
      if (role.includes('form')) return 'form';
    }

    // Check tag name
    if (tagName === 'button' || tagName === 'input' && attributes.type === 'button') {
      return 'button';
    }

    if (tagName === 'img') {
      return 'image';
    }

    if (tagName === 'form') {
      return 'form';
    }

    if (tagName === 'nav') {
      return 'navigation';
    }

    if (['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tagName)) {
      return 'title';
    }

    // Check for price-related classes or attributes
    const classList = attributes.class?.toLowerCase() || '';
    const text = attributes.text?.toLowerCase() || '';

    if (classList.includes('price') || classList.includes('cost') || text.includes('$') || text.includes('€') || text.includes('£')) {
      return 'price';
    }

    if (classList.includes('description') || classList.includes('content') || classList.includes('text')) {
      return 'description';
    }

    // Default to container for divs, spans, etc.
    if (['div', 'span', 'section', 'article', 'aside'].includes(tagName)) {
      return 'container';
    }

    // Default to text for other elements
    return 'text';
  }

  private getPageType(url: string): 'home' | 'pdp' | 'about' | 'other' {
    const urlLower = url.toLowerCase();

    // Check for product pages first
    if (urlLower.includes('/products/') || urlLower.includes('/collections/')) {
      return 'pdp';
    }

    // Check for about pages
    if (urlLower.includes('/about')) {
      return 'about';
    }

    // Check for home page - this should be the most common case
    // Home page is typically just the domain or domain with trailing slash
    const urlObj = new URL(url);
    const pathname = urlObj.pathname;

    // If no path or just a trailing slash, it's the home page
    if (!pathname || pathname === '/' || pathname === '') {
      return 'home';
    }

    // If path is just common home page indicators
    if (pathname === '/home' || pathname === '/index' || pathname === '/index.html') {
      return 'home';
    }

    return 'other';
  }

  async analyzeWithHardcodedSelector(
    url: string,
    hypothesis: string,
    _projectId: string,
    hardcodedSelector: string,
    htmlContent: string | null,
    authentication?: { type: 'shopify_password'; password: string, shopDomain: string }
  ): Promise<InjectionPoint[]> {
    console.log(`[DOM_ANALYZER] Using hardcoded selector: ${hardcodedSelector}`);

    let html: string;

    if (htmlContent) {
      console.log(`[DOM_ANALYZER] Using provided HTML content (${htmlContent.length} chars)`);
      html = htmlContent;
    } else {
      console.log(`[DOM_ANALYZER] Crawling page for HTML content`);
      const crawlResult = await this.crawlerService.crawlPage(url, {
        viewport: { width: 1920, height: 1080 },
        waitFor: 3000,
        authentication
      });

      if (crawlResult.error) {
        throw new Error(`Failed to crawl page: ${crawlResult.error}`);
      }

      html = crawlResult.html || '';
    }

    // Validate the hardcoded selector exists in the HTML
    const matchInfo = getSelectorMatchInfo(hardcodedSelector, html);
    console.log(`[DOM_ANALYZER] Hardcoded selector validation:`, matchInfo);

    if (!matchInfo.found) {
      console.warn(`[DOM_ANALYZER] Hardcoded selector not found in HTML: ${hardcodedSelector}`);
      return [];
    }

    if (matchInfo.count > 1) {
      console.warn(`[DOM_ANALYZER] Hardcoded selector matches ${matchInfo.count} elements, using first one`);
    }

    // Create injection point from hardcoded selector
    const $ = cheerio.load(html);
    let element = $(hardcodedSelector);

    // If selector targets a[href="/collections/all"], filter by text content to be more precise
    if (hardcodedSelector === 'a[href="/collections/all"]') {
      element = element.filter((_, el) => {
        const text = $(el).text().trim().toLowerCase();
        // More precise matching - must contain "shop all" as a phrase
        return text === 'shop all' ||
          text === 'shop all →' ||
          text === 'shop all>' ||
          text.includes('shop all') && text.length < 20; // Short text containing "shop all"
      });
    }

    const targetElement = element.first();

    if (targetElement.length === 0) {
      console.warn(`[DOM_ANALYZER] Element not found with hardcoded selector: ${hardcodedSelector}`);
      return [];
    }

    const elementText = targetElement.text()?.trim() || '';
    const elementNode = targetElement[0];
    const elementType = this.determineElementType(
      elementNode && elementNode.type === 'tag' ? elementNode.name : 'div',
      targetElement.attr() || {}
    );

    // Generate alternative selectors for fallback
    const alternativeSelectors = generateFallbackSelectors(targetElement, $);

    // Get bounding box (simplified - just use 0,0,100,50 as placeholder)
    const boundingBox = {
      x: 0,
      y: 0,
      width: 100,
      height: 50
    };

    const injectionPoint: InjectionPoint = {
      type: elementType,
      selector: hardcodedSelector,
      confidence: 1.0, // High confidence since it's hardcoded
      description: `Hardcoded selector targeting ${elementType} element: ${elementText}`,
      boundingBox,
      alternativeSelectors: alternativeSelectors.slice(0, 3), // Limit to top 3 alternatives
      context: `Hardcoded element: ${elementText}`,
      reasoning: `Hardcoded selector targeting ${elementType} element`,
      hypothesis: hypothesis,
      url: url,
      timestamp: new Date().toISOString(),
      tested: false,
      originalText: elementText
    };

    console.log(`[DOM_ANALYZER] Created injection point from hardcoded selector:`, {
      selector: injectionPoint.selector,
      confidence: injectionPoint.confidence,
      type: injectionPoint.type,
      description: injectionPoint.description?.substring(0, 50) + '...',
      context: injectionPoint.context
    });

    return [injectionPoint];
  }
}

// Factory function
export function createDOMAnalyzer(crawler: CrawlerService): DOMAnalyzerService {
  return new DOMAnalyzerServiceImpl(crawler);
}
</file>

<file path="prisma/schema.prisma">
generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-1.1.x", "linux-arm64-openssl-1.1.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  project   Project?

  // Better Auth fields
  name          String
  emailVerified Boolean      @default(false)
  image         String?
  sessions      Session[]
  accounts      Account[]
  members       Member[]
  invitations   Invitation[]

  // Legacy Auth0 field (will be removed after migration)
  auth0Id   String?  @unique

  @@map("users")
}

model Project {
  id               String            @id @default(cuid())
  shopDomain       String            @unique
  isShopify        Boolean           @default(true) // true for Shopify stores, false for other platforms
  brandAnalysis    Json?
  accessTokenEnc   String?           // Optional - only required for Shopify stores
  userId           String            @unique
  createdAt        DateTime          @default(now())
  brandSummaryJobs BrandSummaryJob[]
  chatMessages     ChatMessage[]
  experiments      Experiment[]
  user             User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  screenshots      Screenshot[]
  variantJobs      VariantJob[]
  analyticsEvents  AnalyticsEvent[]

  @@map("projects")
}

model Experiment {
  id                    String                @id @default(cuid())
  projectId             String
  name                  String
  status                JobStatus             @default(DRAFT)
  createdAt             DateTime              @default(now())
  publishedAt           DateTime?
  finishedAt            DateTime?
  oec                   String
  minDays               Int
  minSessionsPerVariant Int
  targetUrls            Json?                 // URL patterns for targeting
  targeting             Json?                 // Declarative DOM targeting rules
  hypothesis            ExperimentHypothesis?
  traffic               ExperimentTraffic[]
  variants              ExperimentVariant[]
  project               Project               @relation(fields: [projectId], references: [id], onDelete: Cascade)
  analyticsEvents       AnalyticsEvent[]

  @@index([projectId, status])
  @@map("experiments")
}

model ChatMessage {
  id        String      @id @default(cuid())
  projectId String
  role      MessageRole
  content   Json
  createdAt DateTime    @default(now())
  project   Project     @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([projectId, createdAt])
  @@map("chat_messages")
}

model BrandSummaryJob {
  id          String    @id @default(cuid())
  projectId   String
  status      JobStatus @default(PENDING)
  progress    Int?      @default(0)
  result      Json?
  error       String?
  createdAt   DateTime  @default(now())
  startedAt   DateTime?
  completedAt DateTime?
  project     Project   @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([projectId, status, createdAt])
  @@index([status, createdAt])
  @@map("brand_summary_jobs")
}

model VariantJob {
  id          String    @id @default(cuid())
  projectId   String
  status      JobStatus @default(PENDING)
  progress    Int?      @default(0)
  result      Json?
  error       String?
  createdAt   DateTime  @default(now())
  startedAt   DateTime?
  completedAt DateTime?
  project     Project   @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([projectId, status, createdAt])
  @@index([status, createdAt])
  @@map("variant_jobs")
}

model ExperimentHypothesis {
  id           String     @id @default(cuid())
  experimentId String     @unique
  hypothesis   String
  rationale    String
  primaryKpi   String
  createdAt    DateTime   @default(now())
  experiment   Experiment @relation(fields: [experimentId], references: [id], onDelete: Cascade)

  @@map("experiment_hypotheses")
}

model ExperimentTraffic {
  id           String     @id @default(cuid())
  experimentId String
  variantId    String
  percentage   Decimal    @db.Decimal(5, 4)
  experiment   Experiment @relation(fields: [experimentId], references: [id], onDelete: Cascade)

  @@unique([experimentId, variantId])
  @@index([experimentId])
  @@map("experiment_traffic")
}

model ExperimentVariant {
  id           String         @id @default(cuid())
  experimentId String
  variantId    String
  selector     String?
  html         String
  css          String?
  js           String?
  position     InjectPosition
  experiment   Experiment     @relation(fields: [experimentId], references: [id], onDelete: Cascade)

  @@unique([experimentId, variantId])
  @@index([experimentId])
  @@map("experiment_variants")
}

model Screenshot {
  id              String   @id @default(cuid())
  projectId       String
  url             String
  pageType        String
  variantId       String? // Optional variant identifier for variant screenshots
  viewportWidth   Int
  viewportHeight  Int
  fullPage        Boolean
  quality         Int
  data            Bytes
  htmlContent     String?  @db.Text
  markdownContent String?  @db.Text
  fileSize        Int
  createdAt       DateTime @default(now())
  expiresAt       DateTime
  accessedAt      DateTime @default(now())
  accessCount     Int      @default(0)
  project         Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@unique([projectId, pageType, variantId, viewportWidth, viewportHeight, fullPage, quality])
  @@index([projectId])
  @@index([expiresAt])
  @@index([pageType])
  @@index([variantId])
  @@map("screenshots")
}

enum JobStatus {
  DRAFT
  PENDING
  RUNNING
  PAUSED
  COMPLETED
  FAILED
}

enum MessageRole {
  USER
  AGENT
  TOOL
  SYSTEM
}

enum InjectPosition {
  INNER
  OUTER
  BEFORE
  AFTER
  APPEND
  PREPEND
}

enum EventType {
  EXPOSURE
  PAGEVIEW
  CONVERSION
  PURCHASE
  CUSTOM
}

model AnalyticsEvent {
  id           String    @id @default(cuid())
  projectId    String
  experimentId String?
  eventType    EventType @default(EXPOSURE)
  sessionId    String // Primary identifier for user tracking
  viewId       String? // Only for exposure events (SPA navigation)
  properties   Json // Flexible event-specific data
  timestamp    BigInt // Unix timestamp from client
  createdAt    DateTime @default(now())

  // Relations
  project    Project     @relation(fields: [projectId], references: [id], onDelete: Cascade)
  experiment Experiment? @relation(fields: [experimentId], references: [id], onDelete: Cascade)

  // Indexes
  @@index([projectId, eventType])
  @@index([eventType, timestamp])
  @@index([sessionId])
  @@index([experimentId])
  @@index([sessionId, eventType]) // For pageview funnel analysis
  @@map("analytics_events")
}

// Better Auth models
model Session {
  id                   String   @id
  expiresAt            DateTime
  token                String
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  ipAddress            String?
  userAgent            String?
  userId               String
  user                 User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  activeOrganizationId String?

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@map("account")
}

model Verification {
  id         String   @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @default(now()) @updatedAt

  @@map("verification")
}

model Organization {
  id          String       @id
  name        String
  slug        String
  logo        String?
  createdAt   DateTime
  metadata    String?
  members     Member[]
  invitations Invitation[]

  @@unique([slug])
  @@map("organization")
}

model Member {
  id             String       @id
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  userId         String
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  role           String
  createdAt      DateTime

  @@map("member")
}

model Invitation {
  id             String       @id
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  email          String
  role           String?
  status         String
  expiresAt      DateTime
  inviterId      String
  user           User         @relation(fields: [inviterId], references: [id], onDelete: Cascade)

  @@map("invitation")
}
</file>

<file path="src/app/container.ts">
// Service Container for Dependency Injection
import { createPlaywrightCrawler, type CrawlerService } from '@features/crawler';
import { createAgentService, type AgentService } from '@domain/agent';
import { ECOMMERCE_AGENT_SYSTEM_PROMPT } from '@domain/agent/prompts';
// Brand analysis is now function-based, no service needed
import { createHypothesesGenerationService, HypothesesGenerationService } from '@features/hypotheses_generation/hypotheses-generation';
import { createScreenshotStorageService, type ScreenshotStorageService } from '@services/screenshot-storage';
import { createScreenshotAnalyticsService, type ScreenshotAnalyticsService } from '@services/screenshot-analytics';
import { createJobCleanupService, type JobCleanupService } from '@services/job-cleanup';
import { createAnalyticsService, createSQSConsumerService, type AnalyticsService, type SQSConsumerService } from '@services/analytics';
import { PrismaAnalyticsRepository } from '@infra/dal/analytics';
import { getServiceConfig } from '@infra/config/services';
import { prisma } from '@infra/prisma';

class ServiceContainer {
  private services: Map<string, unknown> = new Map();
  private config = getServiceConfig();


  getCrawlerService(): CrawlerService {
    if (!this.services.has('crawler')) {
      const crawlerService = createPlaywrightCrawler(this.config.crawler);
      this.services.set('crawler', crawlerService);
    }
    return this.services.get('crawler') as CrawlerService;
  }

  // Brand analysis is now function-based, no service needed


  getAgentService(): AgentService {
    if (!this.services.has('agent')) {
      const agentService = createAgentService({
        systemPrompt: ECOMMERCE_AGENT_SYSTEM_PROMPT,
        maxContextMessages: 20,
        enableToolCalls: true,
        enableWelcomeFlow: true,
      });
      this.services.set('agent', agentService);
    }
    return this.services.get('agent') as AgentService;
  }

  getHypothesisGenerator(): HypothesesGenerationService {
    if (!this.services.has('hypothesesGeneration')) {
      const crawler = this.getCrawlerService();
      const hypothesesGenerator = createHypothesesGenerationService(crawler, prisma);
      this.services.set('hypothesesGeneration', hypothesesGenerator);
    }
    return this.services.get('hypothesesGeneration') as HypothesesGenerationService;
  }

  getScreenshotStorageService(): ScreenshotStorageService {
    if (!this.services.has('screenshotStorage')) {
      const screenshotStorageService = createScreenshotStorageService();
      this.services.set('screenshotStorage', screenshotStorageService);
    }
    return this.services.get('screenshotStorage') as ScreenshotStorageService;
  }

  getJobCleanupService(): JobCleanupService {
    if (!this.services.has('jobCleanup')) {
      const jobCleanupService = createJobCleanupService();
      this.services.set('jobCleanup', jobCleanupService);
    }
    return this.services.get('jobCleanup') as JobCleanupService;
  }

  getScreenshotAnalyticsService(): ScreenshotAnalyticsService {
    if (!this.services.has('screenshotAnalytics')) {
      const screenshotAnalyticsService = createScreenshotAnalyticsService();
      this.services.set('screenshotAnalytics', screenshotAnalyticsService);
    }
    return this.services.get('screenshotAnalytics') as ScreenshotAnalyticsService;
  }

  getAnalyticsService(): AnalyticsService {
    if (!this.services.has('analytics')) {
      const repository = new PrismaAnalyticsRepository(prisma);
      const analyticsService = createAnalyticsService(repository);
      this.services.set('analytics', analyticsService);
    }
    return this.services.get('analytics') as AnalyticsService;
  }

  getSQSConsumerService(): SQSConsumerService {
    if (!this.services.has('sqsConsumer')) {
      const analyticsService = this.getAnalyticsService();
      const sqsConsumerService = createSQSConsumerService(this.config.sqs, analyticsService);
      this.services.set('sqsConsumer', sqsConsumerService);
    }
    return this.services.get('sqsConsumer') as SQSConsumerService;
  }

  async cleanup(): Promise<void> {
    // Cleanup any services that need it
    const crawler = this.services.get('crawler') as any;
    if (crawler && typeof crawler.close === 'function') {
      await crawler.close();
    }

    // Close Prisma client singleton
    await prisma.$disconnect();

    this.services.clear();
  }
}

// Singleton instance
export const serviceContainer = new ServiceContainer();
</file>

<file path="src/domain/agent/agent.ts">
// Agent Domain Service - Provider-agnostic conversation management
import { getToolsConfiguration } from './tools';
import { createEcommerceAgentSystemPrompt } from './prompts';
import { ai } from '@infra/config/langsmith';
import { stepCountIs } from 'ai';
// import { openai } from '@ai-sdk/openai';
import { google } from '@ai-sdk/google';
import { getAIConfig, AI_CONFIGS } from '@shared/ai-config';
import type {
  AgentService,
  AgentConfig,
  ChatMessage,
} from './types';

export class AgentServiceImpl implements AgentService {
  private aiConfig: ReturnType<typeof getAIConfig>;

  constructor(
    private config: AgentConfig = {}
  ) {
    this.aiConfig = getAIConfig();
  }


  async sendMessageStream(message: string, projectId: string, conversationHistory?: any[]): Promise<{ stream: unknown; messageId: string }> {
    console.log(`[AGENT] Processing message: "${message.substring(0, 50)}${message.length > 50 ? '...' : ''}"`);
    if (conversationHistory) {
      console.log(`[AGENT] Using conversation history (${conversationHistory.length} messages)`);
    }

    // Build messages with system prompt
    const llmMessages: ChatMessage[] = [];

    // Add conversation history if provided, otherwise just add the current message
    if (conversationHistory && conversationHistory.length > 0) {
      conversationHistory.forEach((msg) => {

        llmMessages.push({
          role: msg.role as 'user' | 'assistant' | 'system',
          content: msg.content,
          ...(msg.tool_calls && { tool_calls: msg.tool_calls }),
          ...(msg.tool_call_id && { tool_call_id: msg.tool_call_id }),
          ...(msg.tool_results && { tool_results: msg.tool_results }),
        });
      });
    } else {
      // Add user message if no conversation history
      llmMessages.push({
        role: 'user',
        content: message,
      });
    }

    // Prepare tools if enabled
    let llmOptions: { tools?: any } = {};
    let systemPrompt = this.config.systemPrompt;

    if (this.config.enableToolCalls) {
      const toolsConfig = getToolsConfiguration(projectId);
      // Generate dynamic system prompt based on available tools
      systemPrompt = createEcommerceAgentSystemPrompt(toolsConfig.availableTools);

      llmOptions = {
        tools: toolsConfig.tools,
      };

      console.log(`[AGENT] Tools enabled: ${toolsConfig.availableTools.join(', ')} for project ${projectId}`);
    }

    // Convert messages to AI SDK format
    const aiMessages = llmMessages.map((msg) => {
      const content = typeof msg.content === 'string'
        ? msg.content
        : msg.content
          .filter(block => block.type === 'text')
          .map(block => block.text || '')
          .join('');

      const aiMessage = {
        role: msg.role as 'user' | 'assistant' | 'system',
        content,
        ...(msg.tool_calls && { toolCalls: msg.tool_calls }),
        ...(msg.tool_call_id && { toolCallId: msg.tool_call_id }),
        ...((msg as any).tool_results && { toolResults: (msg as any).tool_results }),
      };

      // Log tool results in AI messages for debugging
      if ((msg as any).tool_results && (msg as any).tool_results.length > 0) {
        const toolResults = (msg as any).tool_results;
        console.log(`[AGENT] AI Message has ${toolResults.length} tool results:`, toolResults.map((tr: any) => ({
          tool_call_id: tr.tool_call_id,
          content_length: tr.content ? tr.content.length : 0,
          has_variants: tr.content && tr.content.includes('variantsSchema') ? 'Yes' : 'No'
        })));
      }

      // Log tool calls for debugging
      if (msg.tool_calls && msg.tool_calls.length > 0) {
        console.log(`[AGENT] AI Message has tool calls:`, msg.tool_calls.map(tc => tc.function.name).join(', '));
      }

      return aiMessage;
    });

    // Add system prompt if provided (either from config or dynamic for tools)
    if (systemPrompt) {
      // Validate system prompt length (Google has limits)
      if (systemPrompt.length > 100000) {
        console.warn(`[AGENT] System prompt is very long (${systemPrompt.length} chars), this might cause issues`);
      }
      
      aiMessages.unshift({
        role: 'system',
        content: systemPrompt,
      });
    }

    // Use AI SDK streaming with tools enabled and multi-step calls
    const streamConfig: any = {
      model: google(this.aiConfig.model),
      messages: aiMessages,
      stopWhen: stepCountIs(5), // Allow up to 5 steps for multi-step tool calls
      ...AI_CONFIGS.STREAMING
    };

    if (llmOptions.tools) {
      streamConfig.tools = llmOptions.tools;
    }

    console.log(`[AGENT] Starting stream with ${aiMessages.length} messages and ${llmOptions.tools ? Object.keys(llmOptions.tools).length : 0} tools`);
    console.log(`[AGENT] System prompt length: ${systemPrompt ? systemPrompt.length : 0} characters`);
    console.log(`[AGENT] AI Config: model=${this.aiConfig.model}, temperature=${this.aiConfig.temperature}, maxTokens=${this.aiConfig.maxTokens}`);

    try {
      const result = ai.streamText(streamConfig);

      // Create a message ID for the response
      const messageId = `msg-${Date.now()}`;

      console.log(`[AGENT] Stream created successfully with message ID: ${messageId}`);
      return { stream: result, messageId };
    } catch (error) {
      console.error(`[AGENT] Error creating stream:`, error);
      throw new Error(`Failed to create AI stream: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
}

// Factory function
export function createAgentService(
  config?: AgentConfig
): AgentService {
  return new AgentServiceImpl(config);
}
</file>

<file path="src/features/brand_analysis/brand-analysis.ts">
// Brand Analysis Functions - Firecrawl Implementation with URL Selection
import type { BrandIntelligenceData } from './types';
import { ProjectDAL } from '@infra/dal';
import { FirecrawlService } from './firecrawl-service';
import { createScreenshotStorageService, ScreenshotStorageService } from '@services/screenshot-storage';
import { HIGH_QUALITY_SCREENSHOT_OPTIONS } from '@shared/screenshot-config';


export async function analyzeProject(projectId: string, shopDomain: string): Promise<BrandIntelligenceData> {
  // Initialize screenshot storage service
  const screenshotStorage = createScreenshotStorageService();

  try {
    console.log(`[BRAND_ANALYSIS] Starting Firecrawl analysis for project ${projectId}, shop: ${shopDomain}`);

    // Handle both Shopify domains (e.g., "shop.myshopify.com") and full URLs (e.g., "https://example.com")
    const baseUrl = shopDomain.startsWith('http://') || shopDomain.startsWith('https://')
      ? shopDomain
      : `https://${shopDomain}`;
    const firecrawlService = new FirecrawlService();

    // Step 1: Analyze the homepage
    console.log(`[BRAND_ANALYSIS] Step 1: Analyzing homepage: ${baseUrl}`);
    const homeResult = await firecrawlService.analyzePage(baseUrl, 'home');

    if (homeResult.error || !homeResult.data) {
      console.error(`[BRAND_ANALYSIS] Homepage analysis failed: ${homeResult.error}`);
      throw new Error(`Homepage analysis failed: ${homeResult.error}`);
    }

    console.log(`[BRAND_ANALYSIS] Homepage analysis completed successfully`);

    // Store homepage screenshot (with HTML and markdown)
    await storeScreenshot(projectId, 'home', baseUrl, homeResult.screenshot, homeResult.html, homeResult.markdown, screenshotStorage);

    // Step 2: Extract URLs from homepage HTML
    // const candidates = await extractUrlsFromHtml(homeResult.html || '', baseUrl);

    // Step 3: Select URLs for additional analysis
    // console.log(`[BRAND_ANALYSIS] Step 3: Selecting URLs from ${candidates.length} candidates`);
    // const response = await selectUrlsForAnalysis(candidates);
    // const urlSelector = new UrlSelector();
    // const urlsWithTypes = urlSelector.getUrlsWithTypes(response);
    // console.log(`[BRAND_ANALYSIS] Selected URLs to analyze:`, urlsWithTypes);

    // Check if we have additional pages to analyze
    // const hasAdditionalPages = urlsWithTypes.some(url => url.pageType !== 'home');
    
    let finalBrandIntelligence: BrandIntelligenceData;
    
    // let pageResults: Array<{ pageType: PageType; url: string; data?: BrandIntelligenceData; error?: string; html?: string; markdown?: string }> = [homeResult];
    // if (hasAdditionalPages) {
    //   // Step 4: Analyze additional pages
    //   pageResults = await analyzeAdditionalPages(urlsWithTypes, baseUrl, firecrawlService, homeResult, projectId, screenshotStorage);

    //   // Step 5: Synthesize results from all pages
    //   console.log(`[BRAND_ANALYSIS] Step 5: Synthesizing results from ${pageResults.length} pages`);
    //   finalBrandIntelligence = await synthesizePageAnalyses(pageResults);
    // } else {
      // Only homepage available, use it directly without synthesis
      console.log(`[BRAND_ANALYSIS] Only homepage available, using homepage data directly`);
      finalBrandIntelligence = homeResult.data;
    // }

    // Store the analysis results without sources (sources are now in screenshots table)
    await ProjectDAL.updateProjectBrandAnalysis(projectId, finalBrandIntelligence);
    console.log(`[BRAND_ANALYSIS] Brand analysis completed successfully for project ${projectId}`);

    return finalBrandIntelligence;
  } catch (error) {
    console.error(`[BRAND_ANALYSIS] Brand analysis failed for project ${shopDomain}:`, error);
    throw error;
  }
}

// Helper function to store screenshots
async function storeScreenshot(
  projectId: string,
  pageType: 'home' | 'pdp' | 'about',
  url: string,
  screenshot: string | undefined,
  html: string | undefined,
  markdown: string | undefined,
  screenshotStorage: ScreenshotStorageService
): Promise<void> {
  if (!screenshot) {
    console.log(`[BRAND_ANALYSIS] No screenshot available for ${pageType} page: ${url}`);
    return;
  }

  try {
    await screenshotStorage.saveScreenshot(
          projectId,
          pageType,
      url,
      HIGH_QUALITY_SCREENSHOT_OPTIONS,
      screenshot,
      html,
      markdown
    );
    console.log(`[BRAND_ANALYSIS] ${pageType} page screenshot saved successfully`);
  } catch (error) {
    console.error(`[BRAND_ANALYSIS] Failed to save ${pageType} page screenshot:`, error);
  }
}
</file>

<file path="src/domain/agent/prompts.ts">
// System prompts for the e-commerce optimization assistant

// Core identity and role definition
const CORE_IDENTITY = `You are Omen, an AI growth partner for eCommerce brands. You help merchants optimize their stores through data-driven experiments and brand analysis.

## Your Role
- Analyze e-commerce stores and identify optimization opportunities
- Generate hypotheses for A/B testing
- Create testable variants for experiments
- Provide brand analysis and insights
- Guide users through the complete experimentation workflow

## Your Communication Style
- Be personable, confident, and proactive
- Speak as a trusted advisor who understands their business
- Present insights as if you've personally analyzed their store
- Keep tone warm, approachable, and growth-focused
- Always provide actionable next steps
- Be conversational and engaging - like a knowledgeable co-pilot
- Show enthusiasm for optimization opportunities
- Use natural language and avoid robotic responses
- Ask follow-up questions to understand their goals better

## Conversation flow (MUST FOLLOW THIS ORDER)
1. **generate_hypotheses** → ALWAYS call this first (MANDATORY FIRST STEP)
   - CRITICAL: Always check if the user mentions ANY specific element, area, or idea they want to test
   - If user provides ANY hypothesis idea, YOU MUST pass it in the userInput parameter
   - Key phrases that indicate user input (always use userInput for these):
     * "focusing on [element]" → pass the entire user message
     * "I think we should [action]" → pass the entire user message
     * "add [something]" → pass the entire user message
     * "test [element/area]" → pass the entire user message
     * "improve [element]" → pass the entire user message
     * Any mention of specific page elements (footer, header, CTA, buttons, etc.)
   - The AI will refine their idea and structure it as a proper hypothesis
2. **generate_variants** → ONLY call after generate_hypotheses has been called
3. **check_variants** → ONLY call when user asks about variant status or when variants are ready
4. **preview_experiment** → ONLY call after check_variants shows variants are ready
5. **create_experiment** → ONLY call after preview_experiment has been shown

## CRITICAL TOOL CALLING RULES
- When user says "Yes, let's do it", "Let's create variants", or similar agreement to generate variants, you MUST call the generate_variants tool
- When user says "Let's create the experiment" or similar agreement to create experiment, you MUST call the create_experiment tool
- When user asks to "explain" or "clarify" something about existing data (hypothesis, variants, etc.), DO NOT regenerate - explain the existing data
- When variants are still being generated (RUNNING status), DO NOT suggest regenerating - just tell user to wait
- NEVER just describe what you would do - ALWAYS call the appropriate tool
- If you mention generating variants, you MUST call generate_variants tool in the same response
- If you mention creating an experiment, you MUST call create_experiment tool in the same response
- Tool calls are MANDATORY when user agrees to proceed with the next step

## RESPONSE GUIDELINES
- After calling generate_hypotheses: Give a brief acknowledgment and ask about next steps - DO NOT repeat hypothesis details or mention that details are shown in the UI (they're automatically displayed)
- After calling generate_variants: Give a brief acknowledgment that variants are being generated and let them know they can click the cards when ready - DO NOT repeat the same message multiple times
- After calling create_experiment: Confirm the experiment is live and explain what happens next
- After calling get_brand_analysis: Give a balanced summary highlighting both strengths and areas for improvement, then nudge toward starting the experiment - DO NOT recommend specific hypothesis directions
- When explaining variants: Provide clear explanations of each variant's approach and design rationale - DO NOT nudge users to preview variants as they may have already done so - focus on explaining the variants and nudging toward the next step
- Keep responses concise and focused on next steps, not repeating data from function calls

## EXAMPLE OF CORRECT BEHAVIOR
User: "Yes, let's do it"
Assistant: "Perfect! I'll generate the variants for you right now." [CALLS generate_variants tool]

User: "Let's go straight to experiment creation"
Assistant: "Great! I'll analyze your store and generate some hypotheses." [CALLS generate_hypotheses tool]
Assistant: "I've found a promising optimization opportunity! Ready to create some variants to test it?" [Brief follow-up, no data repetition or UI references]

User: "I want to create an experiment focusing on the footer, I think we should add a call to action there"
Assistant: "That's a great idea. A well-placed CTA in the footer can capture users who've scrolled to the bottom. Let me analyze your site and create a hypothesis based on your footer CTA idea." [CALLS generate_hypotheses with userInput: "I want to create an experiment focusing on the footer, I think we should add a call to action there"]
Assistant: "I've developed a hypothesis focused on adding a footer CTA. Ready to create some variants?" [Brief follow-up]

User: "I want to test making the CTA button more prominent"
Assistant: "Great idea! Let me analyze your store and refine that into a testable hypothesis." [CALLS generate_hypotheses with userInput: "I want to test making the CTA button more prominent"]
Assistant: "I've structured your idea into a proper hypothesis focused on improving CTA visibility. Ready to create some variants?" [Brief follow-up acknowledging their input]

User: "Let's test adding customer testimonials to the product page"
Assistant: "Excellent! Customer testimonials can be powerful for building trust. Let me analyze your product page and create a hypothesis around that." [CALLS generate_hypotheses with userInput: "Let's test adding customer testimonials to the product page"]
Assistant: "I've developed a hypothesis based on your testimonials idea. Shall we generate some variants to test this?" [Brief follow-up]

User: "Yes, let's do it"
Assistant: "Perfect! I'll generate the variants for you right now." [CALLS generate_variants tool]
Assistant: "You'll see the variants generating in the cards above. Click on them when they're ready to preview!" [Brief follow-up with key info]
Do NOT send a another message after the function call result is displayed

User: "Are my variants ready?"
Assistant: "Let me check the status of your variants." [CALLS check_variants tool]
Assistant: "Your variants are still being generated. This usually takes a few moments. I'll let you know as soon as they're ready!" [Follow-up when still processing - DO NOT suggest regenerating]

User: "Analyze my brand"
Assistant: "I'll analyze your brand right now." [CALLS get_brand_analysis tool]
Assistant: "I've just finished analyzing your brand, and I see a strong foundation with a clear focus on premium, high-performance snowboarding gear. Your brand voice comes across as serious and curated, which resonates well with your target audience of dedicated enthusiasts. However, there are some areas where we could strengthen your conversion potential. Ready to start our first experiment?" [Balanced summary with both strengths and opportunities, nudge toward experiment]

User: "Explain the variants"
Assistant: "Of course. I've designed three distinct variants to test our hypothesis. Here's a quick rundown: [Explains each variant's approach and design rationale] Each of these is designed to make that 'Shop All' link more prominent and clickable. Ready to move forward with testing these variants?" [Explains variants without nudging to preview, nudges toward next step]

## EXAMPLE OF INCORRECT BEHAVIOR (NEVER DO THIS)
User: "Yes, let's do it"  
Assistant: "Great! I'm now generating different versions of that button. This might take a few moments..." [NO TOOL CALL - WRONG!]

User: "Let's go straight to experiment creation"
Assistant: "I've got a fantastic hypothesis for you! Hypothesis: Enhance 'Shop all' CTA Prominence..." [REPEATING DATA - WRONG!]

User: "Analyze my brand"
Assistant: "Your brand specializes in high-end snowboarding equipment, focusing on premium snowboards designed for serious enthusiasts. You cater to a niche market of snowboarders who value quality and performance over budget options, emphasizing craftsmanship and community engagement. Premium, Serious, Curated, Modern..." [REPEATING ALL ANALYSIS DATA - WRONG!]

User: "Explain the key terms in the hypothesis"
Assistant: "Of course. I'll generate the hypothesis for you now, which will include all the key terms and their explanations." [CALLS generate_hypotheses - WRONG! Should explain existing hypothesis]

User: "Yes, let's do it"
Assistant: "Perfect! I'll generate the variants for you right now." [CALLS generate_variants tool]
Assistant: "I'm generating a few options for us to test. This should only take a moment. Once they're ready, I'll give you a preview of how they'll look on your site." [NO FOLLOW-UP WHEN READY - WRONG!]

User: "Explain the variants"
Assistant: "Of course. I've designed three distinct variants to test our hypothesis. Here's a quick rundown: [Explains variants] Click on them when they're ready to preview!" [NUDGING TO PREVIEW WHEN USER MAY HAVE ALREADY DONE SO - WRONG!]`;

// Static system prompt with all tools (for container use)
export const ECOMMERCE_AGENT_SYSTEM_PROMPT = `${CORE_IDENTITY}

## Available Tools
- get_project_info: Get detailed project and store information including store details and experiment statistics.
- generate_hypotheses: Generate optimization hypotheses for the current project. Returns structured hypothesis data that will be displayed in the UI. Handles project ID automatically. Supports optional userInput parameter - when users provide their own hypothesis ideas, pass them in the userInput field and the AI will refine and structure it.
- generate_variants: Start generating testable variants for a hypothesis. Creates background jobs that will process variants asynchronously. Automatically uses the most recently generated hypothesis from state. MANDATORY to call when user agrees to create variants.
- preview_experiment: Preview what an experiment would look like before creating it. Shows hypothesis, variants, and experiment details without saving to database. Automatically uses current hypothesis and variants from state.
- create_experiment: Create and publish an experiment in the database with hypothesis and variants data. Automatically uses the most recently generated hypothesis from state and publishes to Cloudflare.
- get_experiment_overview: Get a detailed overview of the current experiment including hypothesis, variants, traffic distribution, and status. Automatically uses the current experiment from state.
- get_brand_analysis: Get brand analysis data for the project including visual style, brand elements, personality insights, and language/messaging analysis.
- get_brand_sources: Get the stored page markdown content that was used for brand analysis. Use this to reference specific content when explaining analysis results.
- check_variants: Check the current status of variant generation jobs and load completed variants into the state manager. Returns detailed variant information including descriptions and implementation details.
`;

// Main composer function
export function createEcommerceAgentSystemPrompt(availableTools: string[]): string {
  const toolsList = availableTools.map(tool => `- ${tool}: ${getToolDescription(tool)}`).join('\n');

  return `${CORE_IDENTITY}

## Available Tools
${toolsList}
`;

}

function getToolDescription(toolName: string): string {
  const descriptions: Record<string, string> = {
    'get_project_info': 'Get detailed project and store information including store details and experiment statistics.',
    'generate_hypotheses': 'Generate optimization hypotheses for the current project. Returns structured hypothesis data that will be displayed in the UI. Handles project ID automatically. Supports optional userInput parameter - when users provide their own hypothesis ideas, pass them in the userInput field and the AI will refine and structure it.',
    'generate_variants': 'Start generating testable variants for a hypothesis. Creates background jobs that will process variants asynchronously. Automatically uses the most recently generated hypothesis from state. MANDATORY to call when user agrees to create variants.',
    'preview_experiment': 'Preview what an experiment would look like before creating it. Shows hypothesis, variants, and experiment details without saving to database. Automatically uses current hypothesis and variants from state.',
    'create_experiment': 'Create and publish an experiment in the database with hypothesis and variants data. Automatically uses the most recently generated hypothesis from state and publishes to Cloudflare.',
    'get_experiment_overview': 'Get a detailed overview of the current experiment including hypothesis, variants, traffic distribution, and status. Automatically uses the current experiment from state.',
    'get_brand_analysis': 'Get brand analysis data for the project including visual style, brand elements, personality insights, and language/messaging analysis.',
    'get_brand_sources': 'Get the stored page markdown content that was used for brand analysis. Use this to reference specific content when explaining analysis results.',
    'check_variants': 'Check the current status of variant generation jobs and load completed variants into the state manager. Returns detailed variant information including descriptions and implementation details.',
  };

  return descriptions[toolName] || 'Tool description not available';
}
</file>

<file path="src/features/crawler/playwright.ts">
// Playwright Web Crawler Service Implementation
import { chromium, Browser, Page } from 'playwright';
import type { CrawlerService, CrawlResult, CrawlOptions, CrawlerConfig } from './types';

export class PlaywrightCrawlerService implements CrawlerService {
  private browser: Browser | null = null;
  private config: CrawlerConfig;

  constructor(config: CrawlerConfig = {}) {
    this.config = {
      headless: true,
      defaultViewport: { width: 1280, height: 720 },
      defaultTimeout: 30000,
      defaultWaitFor: 2000,
      ...config
    };
  }

  async initialize(): Promise<void> {
    // Only create a new browser if one doesn't exist or is disconnected
    if (this.browser && this.browser.isConnected()) {
      return; // Browser is already running and connected
    }

    // Close existing browser if it exists but is disconnected
    if (this.browser) {
      try {
        await this.browser.close();
      } catch (error) {
        console.warn('[CRAWLER] Error closing disconnected browser:', error);
      }
    }

    this.browser = await chromium.launch({
      executablePath: process.env.CHROME_PATH || '/app/.chrome-for-testing/chrome-linux64/chrome',
      headless: this.config.headless,
      args: [
        '--disable-gpu',
        '--no-sandbox',
        '--disable-dev-shm-usage',
        '--single-process',
        '--disable-setuid-sandbox',
      ],
    });
  }

  async close(): Promise<void> {
    if (this.browser) {
      await this.browser.close();
      this.browser = null;
    }
  }

  async takePartialScreenshot(url: string, viewport: { width: number, height: number }, fullPage: boolean, authentication?: { type: 'shopify_password'; password: string, shopDomain: string }): Promise<string> {
    await this.initialize();

    // Handle both full URLs and domain-only formats
    if (!url.startsWith("http://") && !url.startsWith("https://")) {
      url = `https://${url}`;
    }

    if (!this.browser) {
      throw new Error('Browser not initialized');
    }

    const page = await this.browser.newPage();

    try {
      // Set viewport
      await page.setViewportSize(viewport);

      // Navigate to page
      await page.goto(url, { waitUntil: 'domcontentloaded' });
      await page.waitForLoadState('load', { timeout: 5000 }).catch(() => { });
      await page.waitForLoadState('networkidle', { timeout: 5000 }).catch(() => { });

      // Handle Shopify password authentication if needed
      if (authentication?.type === 'shopify_password') {
        await this.handleShopifyPasswordAuth(page, authentication);
      }


      await page.setExtraHTTPHeaders({
        'User-Agent': "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 Safari/537.36"
      });

      const lazyImagesLocator = page.locator('img[loading="lazy"]:visible');
      const lazyImages = await lazyImagesLocator.all();
      for (const lazyImage of lazyImages) {
        await lazyImage.scrollIntoViewIfNeeded();
      }

      /* eslint-disable no-undef */
      await page.evaluate(() => window.scrollTo(0, 0));
      await page.evaluate(() => {
        const selectors = ['.needsClick', '.needsclick'];
        for (const sel of selectors) {
          document.querySelectorAll(sel).forEach(el => (el as HTMLElement).remove());
        }
      });
      /* eslint-enable no-undef */

      // Handle cookie consent banners and popups
      await this.dismissCookieBanners(page);

      // Take screenshot
      return (await page.screenshot({
        type: 'png',
        fullPage: fullPage,
        path: `ss-${viewport.height}.png`
      })).toString('base64');
    }
    catch (error) {
      console.error(`[CRAWLER] Screenshot failed for ${url}:`, error);
      console.error(`[CRAWLER] Error details:`, {
        name: error instanceof Error ? error.name : 'Unknown',
        message: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : undefined
      });
      throw error; // Re-throw to let caller handle
    }
    finally {
      await page.close();
    }
  }

  private async handleShopifyPasswordAuth(page: import('playwright').Page, auth: { type: 'shopify_password'; password: string; shopDomain: string }): Promise<void> {
    try {
      // Check if we're on a Shopify password page by looking for the password input
      const passwordInput = await page.$('input[type="password"][id="password"][name="password"]');

      if (passwordInput) {
        console.log(`Detected Shopify password page for ${auth.shopDomain}, attempting to fill password`);

        // Fill in the password
        await passwordInput.fill(auth.password);

        // Find and click the submit button
        const submitButton = await page.$('button[type="submit"]');
        if (submitButton) {
          await submitButton.click();

          // Wait for navigation after form submission
          await page.waitForLoadState('load', { timeout: 10000 }).catch(() => { });
          await page.waitForLoadState('networkidle', { timeout: 5000 }).catch(() => { });

          console.log(`Successfully submitted password for ${auth.shopDomain}`);
        } else {
          console.warn(`Submit button not found for ${auth.shopDomain}`);
        }
      } else {
        console.log(`No password input found for ${auth.shopDomain}, proceeding without authentication`);
      }
    } catch (error) {
      console.error(`Error handling Shopify password authentication for ${auth.shopDomain}:`, error);
      // Don't throw the error, just log it and continue
    }
  }

  async crawlPage(url: string, options: CrawlOptions = {}): Promise<CrawlResult> {
    await this.initialize();

    if (!this.browser) {
      throw new Error('Browser not initialized');
    }

    const page = await this.browser.newPage();

    try {
      // Set viewport
      const viewport = options.viewport || this.config.defaultViewport!;
      await page.setViewportSize(viewport);

      // Set user agent if provided
      if (options.userAgent) {
        await page.setExtraHTTPHeaders({
          'User-Agent': options.userAgent
        });
      }

      // Set timeout
      const timeout = options.timeout || this.config.defaultTimeout!;
      page.setDefaultTimeout(timeout);

      // Navigate to page
      await page.goto(url, { waitUntil: 'domcontentloaded' });
      await page.waitForLoadState('load', { timeout: 5000 }).catch(() => { });
      await page.waitForLoadState('networkidle', { timeout: 3000 }).catch(() => { });

      // Handle Shopify password authentication if needed
      if (options.authentication?.type === 'shopify_password') {
        await this.handleShopifyPasswordAuth(page, options.authentication);
      }

      const lazyImagesLocator = page.locator('img[loading="lazy"]:visible');
      const lazyImages = await lazyImagesLocator.all();
      for (const lazyImage of lazyImages) {
        await lazyImage.scrollIntoViewIfNeeded();
      }

      /* eslint-disable no-undef */
      await page.evaluate(() => window.scrollTo(0, 0));
      await page.evaluate(() => {
        const selectors = ['.needsClick', '.needsclick'];
        for (const sel of selectors) {
          document.querySelectorAll(sel).forEach(el => (el as HTMLElement).remove());
        }
      });
      /* eslint-enable no-undef */

      // Handle cookie consent banners and popups
      await this.dismissCookieBanners(page);

      // Wait additional time if specified
      const waitFor = options.waitFor || this.config.defaultWaitFor!;
      if (waitFor > 0) {
        await page.waitForTimeout(waitFor);
      }

      // Extract HTML content
      const html = await page.content();
      // Take screenshot
      const screenshot = await page.screenshot({
        type: 'png',
        fullPage: options.screenshot?.fullPage ?? true,
        // quality: options.screenshot?.quality ?? 80,
      });

      // Extract metadata
      const title = await page.title();
      const description = await page.$eval('meta[name="description"]', el => el.getAttribute('content')).catch(() => null);

      return {
        url,
        html,
        screenshot: screenshot.toString('base64'),
        title,
        description: description || undefined,
      };
    } catch (error) {
      console.error(error);
      return {
        url,
        html: '',
        screenshot: '',
        error: error instanceof Error ? error.message : 'Unknown error occurred',
      };
    } finally {
      await page.close();
    }
  }

  async crawlMultiplePages(urls: string[], options: CrawlOptions = {}): Promise<CrawlResult[]> {
    // Initialize browser once for all pages
    await this.initialize();

    if (!this.browser) {
      throw new Error('Browser not initialized');
    }

    const results: CrawlResult[] = [];

    for (const url of urls) {
      // Check if browser is still connected before creating new page
      if (!this.browser || !this.browser.isConnected()) {
        console.warn(`[CRAWLER] Browser disconnected, reinitializing for ${url}`);
        await this.initialize();
        if (!this.browser) {
          throw new Error('Failed to reinitialize browser');
        }
      }

      let page;
      let retries = 0;
      const maxRetries = 2;
      
      while (retries <= maxRetries) {
        try {
          page = await this.browser.newPage();
          break; // Success, exit retry loop
        } catch (error) {
          retries++;
          console.warn(`[CRAWLER] Failed to create page for ${url} (attempt ${retries}/${maxRetries + 1}):`, error);
          
          if (retries > maxRetries) {
            console.error(`[CRAWLER] Max retries exceeded for ${url}`);
            results.push({
              url,
              html: '',
              screenshot: '',
              error: `Failed to create page after ${maxRetries + 1} attempts: ${error instanceof Error ? error.message : 'Unknown error'}`,
            });
            break; // Exit retry loop and continue to next URL
          }
          
          // Wait a bit before retrying
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          // Try to reinitialize browser
          try {
            await this.initialize();
          } catch (initError) {
            console.error(`[CRAWLER] Failed to reinitialize browser:`, initError);
          }
        }
      }
      
      if (!page) {
        continue; // Skip this URL if we couldn't create a page
      }

      try {
        // Set viewport
        const viewport = options.viewport || this.config.defaultViewport!;
        await page.setViewportSize(viewport);

        // Set user agent if provided
        if (options.userAgent) {
          await page.setExtraHTTPHeaders({
            'User-Agent': options.userAgent
          });
        }

        // Set timeout
        const timeout = options.timeout || this.config.defaultTimeout!;
        page.setDefaultTimeout(timeout);

        // Navigate to page
        await page.goto(url, { waitUntil: 'domcontentloaded' });
        await page.waitForLoadState('load', { timeout: 5000 }).catch(() => { });
        await page.waitForLoadState('networkidle', { timeout: 3000 }).catch(() => { });

        // Handle Shopify password authentication if needed
        if (options.authentication?.type === 'shopify_password') {
          await this.handleShopifyPasswordAuth(page, options.authentication);
        }

        const lazyImagesLocator = page.locator('img[loading="lazy"]:visible');
        const lazyImages = await lazyImagesLocator.all();
        for (const lazyImage of lazyImages) {
          await lazyImage.scrollIntoViewIfNeeded();
        }

        await page.evaluate(() => window.scrollTo(0, 0));
        await page.evaluate(() => {
          const selectors = ['.needsClick', '.needsclick'];
          for (const sel of selectors) {
            document.querySelectorAll(sel).forEach(el => (el as HTMLElement).remove());
          }
        });

        // Handle cookie consent banners and popups
        await this.dismissCookieBanners(page);

        // Wait additional time if specified
        const waitFor = options.waitFor || this.config.defaultWaitFor!;
        if (waitFor > 0) {
          await page.waitForTimeout(waitFor);
        }

        // Extract HTML content
        const html = await page.content();
        // Take screenshot
        const screenshot = await page.screenshot({
          type: 'png',
          fullPage: options.screenshot?.fullPage ?? true,
          // quality: options.screenshot?.quality ?? 80,
        });

        // Extract metadata
        const title = await page.title();
        const description = await page.$eval('meta[name="description"]', el => el.getAttribute('content')).catch(() => null);

        results.push({
          url,
          html,
          screenshot: screenshot.toString('base64'),
          title,
          description: description || undefined,
        });
      } catch (error) {
        console.error(`[CRAWLER] Error crawling ${url}:`, error);
        results.push({
          url,
          html: '',
          screenshot: '',
          error: error instanceof Error ? error.message : 'Unknown error occurred',
        });
      } finally {
        await page.close();
      }
    }

    return results;
  }

  /**
   * Dismiss common cookie consent banners and popups
   */
  private async dismissCookieBanners(page: Page): Promise<void> {
    try {
      console.log('[CRAWLER] Looking for cookie consent banners...');
      
      // Common cookie banner selectors and their corresponding accept/close buttons
      const cookieBannerSelectors = [
        // Generic cookie banners
        '[id*="cookie"]',
        '[class*="cookie"]',
        '[id*="consent"]',
        '[class*="consent"]',
        '[id*="gdpr"]',
        '[class*="gdpr"]',
        '[id*="privacy"]',
        '[class*="privacy"]',
        '[id*="banner"]',
        '[class*="banner"]',
        // Specific common selectors
        '.cookie-banner',
        '.cookie-notice',
        '.cookie-consent',
        '.gdpr-banner',
        '.privacy-banner',
        '.consent-banner',
        '#cookie-banner',
        '#cookie-notice',
        '#cookie-consent',
        '#gdpr-banner',
        '#privacy-banner',
        '#consent-banner',
        // Cookiebot
        '#CybotCookiebotDialog',
        // OneTrust
        '#onetrust-consent-sdk',
        // CookieYes
        '.cky-consent-container',
        // Cookiebot alternatives
        '.cc-window',
        '.cc-banner',
        // Generic popup/overlay selectors
        '[role="dialog"][aria-label*="cookie" i]',
        '[role="dialog"][aria-label*="consent" i]',
        '[role="dialog"][aria-label*="privacy" i]',
        '[role="dialog"][aria-label*="gdpr" i]',
      ];

      const acceptButtonSelectors = [
        // Generic accept buttons
        'button[class*="accept"]',
        'button[class*="agree"]',
        'button[class*="allow"]',
        'button[class*="consent"]',
        'button[id*="accept"]',
        'button[id*="agree"]',
        'button[id*="allow"]',
        'button[id*="consent"]',
        // Specific common selectors
        'button.accept-cookies',
        'button.accept-all',
        'button.agree-cookies',
        'button.allow-cookies',
        'button.consent-accept',
        'button.cookie-accept',
        'button.gdpr-accept',
        'button.privacy-accept',
        '#accept-cookies',
        '#accept-all',
        '#agree-cookies',
        '#allow-cookies',
        '#consent-accept',
        '#cookie-accept',
        '#gdpr-accept',
        '#privacy-accept',
        // Cookiebot
        '#CybotCookiebotDialogBodyLevelButtonLevelOptinAllowAll',
        '#CybotCookiebotDialogBodyButtonAccept',
        // OneTrust
        '#onetrust-accept-btn-handler',
        // CookieYes
        '.cky-btn-accept',
        // Generic close/accept buttons
        'button[aria-label*="accept" i]',
        'button[aria-label*="agree" i]',
        'button[aria-label*="allow" i]',
        'button[aria-label*="consent" i]',
        'button[aria-label*="close" i]',
        // Text-based selectors
        'button:has-text("Accept")',
        'button:has-text("Accept All")',
        'button:has-text("Agree")',
        'button:has-text("Allow")',
        'button:has-text("Allow All")',
        'button:has-text("Consent")',
        'button:has-text("I Accept")',
        'button:has-text("I Agree")',
        'button:has-text("OK")',
        'button:has-text("Got it")',
        'button:has-text("Continue")',
        'button:has-text("Close")',
        'button:has-text("Dismiss")',
        // Links that might be accept buttons
        'a[class*="accept"]',
        'a[class*="agree"]',
        'a[class*="allow"]',
        'a[class*="consent"]',
        'a:has-text("Accept")',
        'a:has-text("Accept All")',
        'a:has-text("Agree")',
        'a:has-text("Allow")',
        'a:has-text("Allow All")',
        'a:has-text("I Accept")',
        'a:has-text("I Agree")',
        'a:has-text("OK")',
        'a:has-text("Got it")',
        'a:has-text("Continue")',
      ];

      // Wait a bit for cookie banners to load
      await page.waitForTimeout(1000);

      // Look for cookie banners
      let bannerFound = false;
      for (const bannerSelector of cookieBannerSelectors) {
        try {
          const banner = page.locator(bannerSelector).first();
          const isVisible = await banner.isVisible().catch(() => false);
          
          if (isVisible) {
            console.log(`[CRAWLER] Found cookie banner with selector: ${bannerSelector}`);
            bannerFound = true;
            
            // Try to find and click accept button within this banner
            let buttonClicked = false;
            for (const buttonSelector of acceptButtonSelectors) {
              try {
                const button = banner.locator(buttonSelector).first();
                const buttonVisible = await button.isVisible().catch(() => false);
                
                if (buttonVisible) {
                  console.log(`[CRAWLER] Clicking accept button: ${buttonSelector}`);
                  await button.click();
                  buttonClicked = true;
                  break;
                }
              } catch (_buttonError) {
                // Continue to next button selector
                continue;
              }
            }
            
            // If no button found within the banner, try clicking the banner itself
            if (!buttonClicked) {
              try {
                console.log(`[CRAWLER] No accept button found, trying to click banner itself`);
                await banner.click();
                buttonClicked = true;
              } catch (clickError) {
                console.log(`[CRAWLER] Could not click banner: ${clickError}`);
              }
            }
            
            if (buttonClicked) {
              // Wait for banner to disappear
              await page.waitForTimeout(500);
              console.log(`[CRAWLER] Cookie banner dismissed`);
              break;
            }
          }
        } catch (_error) {
          // Continue to next banner selector
          continue;
        }
      }

      if (!bannerFound) {
        console.log('[CRAWLER] No cookie banners found');
      }

      // Additional cleanup: remove any remaining cookie-related elements
      /* eslint-disable no-undef */
      await page.evaluate(() => {
        const cookieSelectors = [
          '[id*="cookie"]',
          '[class*="cookie"]',
          '[id*="consent"]',
          '[class*="consent"]',
          '[id*="gdpr"]',
          '[class*="gdpr"]',
          '[id*="privacy"]',
          '[class*="privacy"]',
          '[id*="banner"]',
          '[class*="banner"]',
        ];

        cookieSelectors.forEach(selector => {
          try {
            document.querySelectorAll(selector).forEach(el => {
              const element = el as HTMLElement;
              if (element.style.position === 'fixed' ||
                  element.style.position === 'absolute' ||
                  element.classList.contains('fixed') ||
                  element.classList.contains('absolute')) {
                element.remove();
              }
            });
          } catch (_e) {
            // Ignore errors
          }
        });
      });
      /* eslint-enable no-undef */

    } catch (error) {
      console.warn('[CRAWLER] Error dismissing cookie banners:', error);
      // Don't throw - we still want to continue with the screenshot
    }
  }
}

// Factory function for easy instantiation
export function createPlaywrightCrawler(config?: CrawlerConfig): PlaywrightCrawlerService {
  return new PlaywrightCrawlerService(config);
}
</file>

<file path="src/features/hypotheses_generation/hypotheses-generation.ts">
// Hypotheses Generation Service
//
// DEMO MODE:
// To enable/disable demo mode, change the DEMO_CONDITION flag in src/shared/demo-config.ts
// When enabled, hypotheses will focus specifically on the demo target element
//
import { generateObject } from 'ai';
import { google } from '@ai-sdk/google';
import { CrawlerService } from '@features/crawler';
import { z } from 'zod'
import { ProjectDAL, ExperimentDAL } from '@infra/dal'
import { getAIConfig } from '@shared/ai-config'
import type { PrismaClient } from '@prisma/client';
import { createScreenshotStorageService, ScreenshotStorageService } from '@services/screenshot-storage';
import { simplifyHTML, getHtmlInfo } from '@shared/utils/html-simplifier';
import { toReservedPayload } from '@features/conflict_guard';
import { HIGH_QUALITY_SCREENSHOT_OPTIONS } from '@shared/screenshot-config';
import { DEMO_CONDITION, DEMO_TARGET_ELEMENT, getDemoSelector, getDemoHtml } from '@shared/demo-config';

export interface HypothesesGenerationService {
    generateHypotheses(url: string, projectId: string, userInput?: string): Promise<HypothesesGenerationResult>;
}

export interface HypothesesGenerationResult {
    hypothesesSchema: string;
}

// Factory function
export function createHypothesesGenerationService(
    crawler: CrawlerService,
    prisma: PrismaClient
): HypothesesGenerationService {
    return new HypothesesGenerationServiceImpl(crawler, prisma);
}

const hypothesisSchema = z.object({
    title: z.string(),
    description: z.string(), // 1 Sentence clear breakdown of the hypothesis
    primary_outcome: z.string().max(20, "Primary outcome must be concise"), // This is the OEC, keep it concise
    current_problem: z.string(), // 1 Sentence clear breakdown of the current problem
    why_it_works: z.array(z.object({
        reason: z.string() // Sentence of 5/7 words why this reason works
    })),
    baseline_performance: z.number(), // Baseline performance in percentage (realistic approximation)
    predicted_lift_range: z.object({
        min: z.number(), // Decimal
        max: z.number() // Decimal
    })
})

const hypothesesResponseSchema = z.object({
    hypotheses: z.array(hypothesisSchema)
});


export class HypothesesGenerationServiceImpl implements HypothesesGenerationService {
    private crawlerService: CrawlerService;
    private screenshotStorage: ScreenshotStorageService;

    constructor(crawler: CrawlerService, _prisma: PrismaClient) {
        this.crawlerService = crawler;
        this.screenshotStorage = createScreenshotStorageService();
    }

    async generateHypotheses(url: string, projectId: string, userInput?: string): Promise<HypothesesGenerationResult> {
        console.log(`[HYPOTHESES] Starting generation for URL: ${url}, Project: ${projectId}`);

        if (userInput) {
            console.log(`[HYPOTHESES] User provided input: "${userInput}"`);
        }

        if (DEMO_CONDITION) {
            console.log(`[HYPOTHESES] DEMO MODE ENABLED - Targeting: ${DEMO_TARGET_ELEMENT.description}`);
            console.log(`[HYPOTHESES] Target selector: ${getDemoSelector('hypotheses')}`);
        }

        const toDataUrl = (b64: string): string => {
            if (!b64) return '';
            if (b64.startsWith('data:')) return b64;
            return `data:image/png;base64,${b64}`;
        };

        // Check storage first
        const pageType = this.getPageType(url);
        const cachedScreenshot = await this.screenshotStorage.getScreenshot(
            projectId,
            pageType,
            HIGH_QUALITY_SCREENSHOT_OPTIONS
        );

        let screenshot: string;
        if (cachedScreenshot) {
            console.log(`[HYPOTHESES] Using stored screenshot for ${pageType} page`);
            screenshot = cachedScreenshot;
        } else {
            console.log(`[HYPOTHESES] Taking new screenshot and HTML for ${url}`);
            const crawlResult = await this.crawlerService.crawlPage(url, {
                viewport: { width: 1920, height: 1080 },
                waitFor: 3000,
                screenshot: { fullPage: true, quality: 80 },
                authentication: { type: 'shopify_password', password: 'reitri', shopDomain: 'shop.omen.so' }
            });

            screenshot = crawlResult.screenshot || '';

            // Store the new screenshot and HTML
            if (crawlResult.html) {
                const simplifiedHtml = simplifyHTML(crawlResult.html);
                const screenshotId = await this.screenshotStorage.saveScreenshot(
                    projectId,
                    pageType,
                    url,
                    HIGH_QUALITY_SCREENSHOT_OPTIONS,
                    screenshot,
                    simplifiedHtml
                );
                console.log(`[HYPOTHESES] Screenshot and HTML saved with ID: ${screenshotId} (${getHtmlInfo(simplifiedHtml)})`);
            } else {
                const screenshotId = await this.screenshotStorage.saveScreenshot(
                    projectId,
                    pageType,
                    url,
                    HIGH_QUALITY_SCREENSHOT_OPTIONS,
                    screenshot
                );
                console.log(`[HYPOTHESES] Screenshot saved with ID: ${screenshotId}`);
            }
        }

        console.log(`[HYPOTHESES] Screenshot ready, length: ${screenshot.length}`);

        console.log(`[HYPOTHESES] Fetching brand analysis for project: ${projectId}`);
        const brandAnalysis = await ProjectDAL.getProjectBrandAnalysis(projectId);
        console.log(`[HYPOTHESES] Brand analysis result:`, brandAnalysis ? `length: ${brandAnalysis.length}` : 'null');

        if (!brandAnalysis) {
            console.warn(`[HYPOTHESES] No brand analysis found for project: ${projectId}`);
            throw new Error(`No brand analysis available for project ${projectId}. Please run brand analysis first.`);
        }

        // Get active experiment targets for conflict avoidance
        console.log(`[HYPOTHESES] Fetching active experiment targets for conflict checking`);
        const activeTargets = await ExperimentDAL.getActiveTargets(projectId);
        const reservedPayload = toReservedPayload(url, activeTargets);
        console.log(`[HYPOTHESES] Found ${activeTargets.length} active targets to avoid`);

        console.log(`[HYPOTHESES] Generating AI response with Google Gemini`);
        const aiConfig = getAIConfig();
        const result = await generateObject({
            model: google(aiConfig.model),
            schema: hypothesesResponseSchema,
            messages: [
                {
                    role: 'user',
                    content: [
                        { type: "text", text: this.buildHypothesesGenerationPrompt(reservedPayload, userInput) },
                        { type: "text", text: brandAnalysis },
                        { type: "image", image: toDataUrl(screenshot) }
                    ]
                }
            ]
        });
        const response = result.object;
        console.log(`[HYPOTHESES] AI response generated: ${response.hypotheses.length} hypotheses`);
        return {
            hypothesesSchema: JSON.stringify(response)
        };

    }

    private buildHypothesesGenerationPrompt(reservedPayload?: any, userInput?: string): string {
        const hasReservedTargets = reservedPayload?.reserved_targets?.length > 0;

        const conflictSection = hasReservedTargets ? `

**IMPORTANT - ACTIVE EXPERIMENTS TO AVOID:**
The following elements are currently being tested in active experiments. DO NOT propose changes to these elements:
${JSON.stringify(reservedPayload.reserved_targets, null, 2)}

When generating hypotheses:
- Avoid any changes to the reserved targets listed above
- Focus on different page elements or sections
- If a primary CTA is reserved, suggest testing secondary elements
` : '';

        const hardcodedElementSection = DEMO_CONDITION ? `

**SPECIFIC ELEMENT FOCUS (DEMO MODE):**
You MUST focus your hypothesis on this specific element:
- Element: ${DEMO_TARGET_ELEMENT.description}
- CSS Selector: ${getDemoSelector('hypotheses')}
- HTML: ${getDemoHtml('hypotheses')}

Your hypothesis should specifically address this element and suggest improvements to it. Look for this element in the screenshot and base your hypothesis on what you observe about its current state, visibility, styling, or positioning.
` : '';

        const userInputSection = userInput ? `

**USER PROVIDED HYPOTHESIS DIRECTION (MANDATORY - HIGHEST PRIORITY):**
The user has specifically requested to test the following:
"${userInput}"

CRITICAL REQUIREMENTS - YOU MUST FOLLOW THESE:
1. Your hypothesis MUST directly address the user's specific request
2. If they mention "footer" - the hypothesis MUST focus on the footer
3. If they mention "CTA" or "call to action" - the hypothesis MUST include adding or improving CTAs
4. If they mention a specific element or area - that MUST be the focus of your hypothesis
5. DO NOT generate a generic hypothesis that ignores their input
6. Refine and structure their idea professionally while keeping their core intent
7. Make it specific, measurable, and aligned with CRO best practices
8. Incorporate brand analysis to strengthen the hypothesis
9. If conflicts exist with reserved targets, adapt while maintaining the user's core idea

The user's input is the HIGHEST PRIORITY - your hypothesis must clearly reflect what they asked for.
` : '';

        return `
You are an expert Conversion Rate Optimization (CRO) and UX/UI analyst. Your task is to analyze one or two screenshots of an e-commerce homepage or product detail page (PDP) from a Shopify store. Based on what you see, generate **one UI-focused hypothesis** that a merchant could test to improve conversions.

Your analysis must prioritize **clarity, testability, and accessibility**. You are not writing vague advice—you are producing **hypotheses that can be tested in A/B experiments** without requiring advanced CRO expertise.
${conflictSection}${hardcodedElementSection}${userInputSection}

\n**Temporary Focus Exclusions (for now):**
Do NOT focus the hypothesis on the homepage hero section or any primary/above-the-fold CTA (e.g., main "Shop now" or the dominant hero button). Prioritize other UI opportunities.

---

**Detailed Requirements:**

1. **Input:**

    * The brand summary of this specific brand
    * 1-2 screenshots (desktop or mobile).
        * Assume screenshots may be imperfect (poor resolution, overlay banners, missing or duplicated CTAs, etc.).
   
2. **Output:**
   For each hypothesis, return a structured object with:

   * **title:** A concise, descriptive title for the hypothesis (e.g., "Improve CTA Button Visibility")
   * **description:** One clear sentence explaining the hypothesis and what change to test
   * **primary_outcome:** The main metric that determines success - keep it concise (e.g., "Click-through rate", "Conversion rate", "Add-to-cart rate")
   * **current_problem:** One sentence describing the current UI issue or opportunity
   * **why_it_works:** Array of 2-3 reasons (5-7 words each) explaining why this change should work
   * **baseline_performance:** Current performance as a percentage - use realistic e-commerce benchmarks based on the specific metric (e.g., 2-5% for conversion rate, 15-25% for click-through rate, 8-15% for add-to-cart rate)
   * **predicted_lift_range:** Expected improvement range with min and max values as decimals (e.g., 0.05 to 0.15 for 5-15% lift)

3. **Constraints:**

   * Produce **exactly 1 hypothesis** per set of screenshots, but return it as an array with one element.
   * Ensure recommendations are **UI-first** (not backend, pricing, or content strategy).
   * Handle edge cases gracefully:

     * If no CTA is visible, suggest adding one.
     * If multiple CTAs compete, suggest hierarchy improvements.
     * If screenshot quality is too poor to assess, return a fallback message: *"Unable to reliably analyze this screenshot."*

4. **Style Guidelines:**

   * Use plain, non-jargon language understandable to merchants.
   * Be concise but specific—merchants should see exactly what they could test.
   * Avoid over-promising; these are hypotheses, not guarantees.
   * For baseline_performance, use realistic e-commerce benchmarks based on the specific metric:
     - Conversion rate: 2-5% (typical e-commerce range)
     - Click-through rate: 15-25% (for buttons/links)
     - Add-to-cart rate: 8-15% (for product pages)
     - Email signup rate: 1-3% (for newsletter forms)
     - Bounce rate: 40-60% (higher is worse)
   * For predicted_lift_range, be conservative but optimistic (typically 5-25% improvement)
   * Primary outcome should be concise - use clear metric names like "Click-through rate", "Conversion rate", "Add-to-cart rate"

5. **Guardrails (critical):**
   * Do NOT propose adding new images, videos, or external assets; leverage existing assets and DOM structure.
   * Do NOT propose changing where links point (hrefs) or inventing new URLs; keep navigation targets unchanged.
   * If an idea would require new media or URL changes, explicitly call out that those parts should be skipped and focus the hypothesis on text, layout, style, hierarchy, visibility, or state changes.

**IMPORTANT JSON FORMAT:**
Return your response as a JSON object with a "hypotheses" array containing exactly 1 hypothesis object. The structure should be:
{
  "hypotheses": [
    {
      "title": "Your hypothesis title",
      "description": "Your hypothesis description",
      "primary_outcome": "Click-through rate",
      "current_problem": "Current problem description",
      "why_it_works": [
        {"reason": "First reason why it works"},
        {"reason": "Second reason why it works"}
      ],
      "baseline_performance": 15.5,
      "predicted_lift_range": {
        "min": 0.05,
        "max": 0.15
      }
    }
  ]
}`;
    }

    private getPageType(url: string): 'home' | 'pdp' | 'about' | 'other' {
        const urlLower = url.toLowerCase();

        // Check for product pages first
        if (urlLower.includes('/products/') || urlLower.includes('/collections/')) {
            return 'pdp';
        }

        // Check for about pages
        if (urlLower.includes('/about')) {
            return 'about';
        }

        // Check for home page - this should be the most common case
        // Home page is typically just the domain or domain with trailing slash
        const urlObj = new URL(url);
        const pathname = urlObj.pathname;

        // If no path or just a trailing slash, it's the home page
        if (!pathname || pathname === '/' || pathname === '') {
            return 'home';
        }

        // If path is just common home page indicators
        if (pathname === '/home' || pathname === '/index' || pathname === '/index.html') {
            return 'home';
        }

        return 'other';
    }
}
</file>

<file path="src/features/variant_generation/variant-generation.ts">
// @ts-nocheck
// Variant Generation Service
import { generateObject } from 'ai';
import { google } from '@ai-sdk/google';
import { CrawlerService } from '@features/crawler';
import { ProjectDAL } from '@infra/dal';
import { buildVariantGenerationPrompt, buildButtonVariantGenerationPrompt } from './prompts';
import { Hypothesis } from '@features/hypotheses_generation/types';
import { basicVariantsResponseSchema } from './types';
import { createVariantCodeGenerator, VariantCodeGenerator } from './code-generator';
import { DOMAnalyzerService, createDOMAnalyzer } from './dom-analyzer';
import { getAIConfig, getVariantGenerationAIConfig } from '@shared/ai-config';
import type { PrismaClient } from '@prisma/client';
import { ScreenshotStorageService } from '@services/screenshot-storage';
import { HIGH_QUALITY_SCREENSHOT_OPTIONS } from '@shared/screenshot-config';
import { DEMO_CONDITION, getDemoSelector } from '@shared/demo-config';
import { DesignSystemExtractor } from './design-system-extractor';
import { VisualRefinementService } from './visual-refinement';

export interface VariantGenerationService {
    generateVariants(hypothesis: Hypothesis, projectId: string): Promise<VariantGenerationResult>;
    generateSingleVariant(variant: any, hypothesis: Hypothesis, projectId: string, screenshot: string, injectionPoints: any[], brandAnalysis: string): Promise<any>;
    getCachedProject(projectId: string): Promise<any>;
    getCachedBrandAnalysis(projectId: string): Promise<string | null>;
    getAIConfig(): any;
    buildVariantGenerationPrompt(hypothesis: Hypothesis): string;
    basicVariantsResponseSchema: any;
    crawlerService: any;
    domAnalyzer: any;
}

export interface VariantGenerationResult {
    variantsSchema: string;
}

// Factory function
export function createVariantGenerationService(
    crawler: CrawlerService,
    screenshotStorage: ScreenshotStorageService,
    prisma: PrismaClient
): VariantGenerationService {
    return new VariantGenerationServiceImpl(crawler, screenshotStorage, prisma);
}

export class VariantGenerationServiceImpl implements VariantGenerationService {
    private crawlerService: CrawlerService;
    private codeGenerator: VariantCodeGenerator;
    private screenshotStorage: ScreenshotStorageService;
    private domAnalyzer: DOMAnalyzerService;
    private designSystemExtractor: DesignSystemExtractor;
    private visualRefinement: VisualRefinementService;
    private brandAnalysisCache: Map<string, { data: string; timestamp: number }> = new Map();
    private projectCache: Map<string, { data: any; timestamp: number }> = new Map();
    private designSystemCache: Map<string, { data: any; timestamp: number }> = new Map();
    private readonly CACHE_TTL = 5 * 60 * 1000; // 5 minutes


    constructor(crawler: CrawlerService, screenshotStorage: ScreenshotStorageService) {
        this.crawlerService = crawler;
        this.screenshotStorage = screenshotStorage;
        this.domAnalyzer = createDOMAnalyzer(crawler);
        this.codeGenerator = createVariantCodeGenerator();
        this.designSystemExtractor = new DesignSystemExtractor();
        this.visualRefinement = new VisualRefinementService();
    }

    private async _getCachedProject(projectId: string): Promise<any> {
        const cached = this.projectCache.get(projectId);
        if (cached && Date.now() - cached.timestamp < this.CACHE_TTL) {
            console.log(`[VARIANTS] Using cached project data for ${projectId}`);
            return cached.data;
        }

        console.log(`[VARIANTS] Fetching fresh project data for ${projectId}`);
        const project = await ProjectDAL.getProjectById(projectId);
        if (project) {
            this.projectCache.set(projectId, { data: project, timestamp: Date.now() });
        }
        return project;
    }

    private async _getCachedBrandAnalysis(projectId: string): Promise<string> {
        const cached = this.brandAnalysisCache.get(projectId);
        if (cached && Date.now() - cached.timestamp < this.CACHE_TTL) {
            console.log(`[VARIANTS] Using cached brand analysis for ${projectId}`);
            return cached.data;
        }

        console.log(`[VARIANTS] Fetching fresh brand analysis for ${projectId}`);
        const brandAnalysis = await ProjectDAL.getProjectBrandAnalysis(projectId);
        if (brandAnalysis) {
            this.brandAnalysisCache.set(projectId, { data: brandAnalysis, timestamp: Date.now() });
        }
        return brandAnalysis;
    }

    // Public methods for external access
    async getCachedProject(projectId: string): Promise<any> {
        return this._getCachedProject(projectId);
    }

    async getCachedBrandAnalysis(projectId: string): Promise<string | null> {
        return this._getCachedBrandAnalysis(projectId);
    }

    getAIConfig(): any {
        return getAIConfig();
    }

    buildVariantGenerationPrompt(hypothesis: Hypothesis, variantIndex?: number): string {
        return DEMO_CONDITION
            ? buildButtonVariantGenerationPrompt(hypothesis, variantIndex)
            : buildVariantGenerationPrompt(hypothesis);
    }

    get basicVariantsResponseSchema() {
        return basicVariantsResponseSchema;
    }

    get crawlerService() {
        return this.crawlerService;
    }

    get domAnalyzer() {
        return this.domAnalyzer;
    }

    async cleanup(): Promise<void> {
        // Close the browser to free up resources
        if (this.crawlerService && typeof this.crawlerService.close === 'function') {
            await this.crawlerService.close();
        }
    }

    async generateSingleVariant(variant: any, hypothesis: Hypothesis, projectId: string, screenshot: string, injectionPoints: any[], brandAnalysis: string): Promise<any> {
        console.log(`[VARIANTS] Starting single variant generation: ${variant.variant_label}`);

        const toDataUrl = (b64: string): string => {
            if (!b64) return '';
            if (b64.startsWith('data:')) return b64;
            return `data:image/png;base64,${b64}`;
        };

        // Compress screenshot to reduce token usage
        const compressScreenshot = (b64: string): string => {
            if (!b64) return '';
            // For now, just return the original - compression would require image processing
            // TODO: Implement actual image compression (resize to smaller dimensions, reduce quality)
            return b64;
        };

        // Get project data for shop domain
        const project = await this._getCachedProject(projectId);
        if (!project) {
            throw new Error(`Project not found: ${projectId}`);
        }

        // Handle both Shopify domains and full URLs
        const url = project.shopDomain.startsWith('http://') || project.shopDomain.startsWith('https://')
            ? project.shopDomain
            : `https://${project.shopDomain}`;

        // Initialize crawler for this variant
        const { createPlaywrightCrawler } = await import('@features/crawler');
        const { getServiceConfig } = await import('@infra/config/services');
        const config = getServiceConfig();
        const crawler = createPlaywrightCrawler(config.crawler);

        try {
            // Generate code for this variant
            let codeResult;
            try {
                console.log(`[VARIANTS] Generating code for variant: ${variant.variant_label}`);
                // We need to get HTML content for this variant - for now pass null
                codeResult = await this.codeGenerator.generateCode(variant, hypothesis, brandAnalysis, toDataUrl(screenshot), injectionPoints, null);
            } catch (error) {
                console.error(`[VARIANTS] Failed to generate code for variant ${variant.variant_label}:`, error);
                codeResult = null;
            }

            // Skip screenshot for variants - takeVariantScreenshot method was removed
            // Variants now use JavaScript code instead of CSS/HTML injection
            let variantScreenshotUrl = '';

            // Create the final variant object with JavaScript code
            const finalVariant = {
                ...variant,
                javascript_code: codeResult?.javascript_code || '',
                target_selector: codeResult?.target_selector || '',
                execution_timing: codeResult?.execution_timing || 'dom_ready' as const,
                implementation_instructions: codeResult?.implementation_instructions || `Code generation failed for this variant. Please implement manually based on the description: ${variant.description}`,
                screenshot: variantScreenshotUrl
            };

            console.log(`[VARIANTS] Completed single variant: ${variant.variant_label}`);
            return finalVariant;

        } finally {
            // Clean up the crawler
            await crawler.close();
        }
    }

    async generateVariants(hypothesis: Hypothesis, projectId: string): Promise<VariantGenerationResult> {
        console.log(`[VARIANTS] Starting generation for hypothesis: ${hypothesis.title}`);
        console.log(`[VARIANTS] Using project ID: ${projectId}`);

        // Get project data to fetch shop domain (with caching)
        console.log(`[VARIANTS] Fetching project data for project: ${projectId}`);
        const project = await this._getCachedProject(projectId);
        if (!project) {
            throw new Error(`Project not found: ${projectId}`);
        }

        // Handle both Shopify domains and full URLs
        const url = project.shopDomain.startsWith('http://') || project.shopDomain.startsWith('https://')
            ? project.shopDomain
            : `https://${project.shopDomain}`;
        console.log(`[VARIANTS] Using shop domain: ${project.shopDomain}, URL: ${url}`);

        const toDataUrl = (b64: string): string => {
            if (!b64) return '';
            if (b64.startsWith('data:')) return b64;
            return `data:image/png;base64,${b64}`;
        };

        // Check storage first for base screenshot and HTML (reuse from brand analysis or DOM analysis)
        const pageType = this.getPageType(url);
        const cachedData = await this.screenshotStorage.getScreenshotWithHtml(
            projectId,
            pageType,
            HIGH_QUALITY_SCREENSHOT_OPTIONS
        );

        let screenshot: string;
        let htmlContent: string | null = null;

        if (cachedData.screenshot) {
            console.log(`[VARIANTS] Using stored screenshot and HTML for ${pageType} page`);
            screenshot = cachedData.screenshot;
            htmlContent = cachedData.html;
        } else {
            console.log(`[VARIANTS] Taking new screenshot and HTML for ${url}`);
            const crawlResult = await this.crawlerService.crawlPage(url, {
                viewport: { width: 1920, height: 1080 },
                waitFor: 3000,
                screenshot: { fullPage: true, quality: 80 },
                authentication: { type: 'shopify_password', password: 'reitri', shopDomain: project.shopDomain }
            });

            screenshot = crawlResult.screenshot || '';
            htmlContent = crawlResult.html || null;

            // Store the new screenshot and HTML
            if (screenshot) {
                const screenshotId = await this.screenshotStorage.saveScreenshot(
                    projectId,
                    pageType,
                    url,
                    HIGH_QUALITY_SCREENSHOT_OPTIONS,
                    screenshot,
                    htmlContent ? htmlContent.substring(0, 50000) : undefined // Limit HTML size for storage
                );
                console.log(`[VARIANTS] Screenshot and HTML saved with ID: ${screenshotId}`);
            }
        }

        // PARALLEL OPTIMIZATION: Extract design system along with DOM analysis and brand analysis
        console.log(`[VARIANTS] Starting parallel operations: DOM analysis, brand analysis, and design system extraction`);

        if (DEMO_CONDITION) {
            console.log(`[VARIANTS] DEMO MODE ENABLED - Using demo selector: ${getDemoSelector('variants')}`);
        }

        // Try to get cached design system first
        let designSystem = null;
        const cachedDesignSystem = this.designSystemCache.get(projectId);
        if (cachedDesignSystem && Date.now() - cachedDesignSystem.timestamp < this.CACHE_TTL) {
            console.log(`[VARIANTS] Using cached design system for ${projectId}`);
            designSystem = cachedDesignSystem.data;
        }

        const [injectionPoints, brandAnalysis, extractedDesignSystem] = await Promise.all([
            // Use demo selector if enabled, otherwise use normal analysis
            DEMO_CONDITION
                ? this.domAnalyzer.analyzeWithHardcodedSelector(
                    url,
                    hypothesis.description,
                    projectId,
                    getDemoSelector('variants'),
                    htmlContent,
                    { type: 'shopify_password', password: 'reitri', shopDomain: project.shopDomain }
                )
                : this.domAnalyzer.analyzeForHypothesisWithHtml(
                    url,
                    hypothesis.description,
                    projectId,
                    htmlContent, // Pass the HTML we already have
                    { type: 'shopify_password', password: 'reitri', shopDomain: project.shopDomain }
                ),
            this._getCachedBrandAnalysis(projectId),
            // Extract design system if not cached
            designSystem ? Promise.resolve(null) : this.designSystemExtractor.extractDesignSystem(screenshot, htmlContent)
        ]);

        // Use extracted design system or cached one
        if (extractedDesignSystem) {
            designSystem = extractedDesignSystem;
            // Cache it for future use
            this.designSystemCache.set(projectId, { data: designSystem, timestamp: Date.now() });
            console.log(`[VARIANTS] Design system extracted and cached`);
        }

        // Set design system in code generator
        this.codeGenerator.setDesignSystem(designSystem);

        console.log(`[VARIANTS] Parallel operations completed:`);
        console.log(`[VARIANTS] - Screenshot length: ${screenshot.length}`);
        console.log(`[VARIANTS] - Injection points found: ${injectionPoints.length}`);
        console.log(`[VARIANTS] - Brand analysis: ${brandAnalysis ? `length: ${brandAnalysis.length} chars` : 'null'}`);
        console.log(`[VARIANTS] - Design system: ${designSystem ? 'extracted' : 'not available'}`);

        // Log the injection points for debugging
        if (injectionPoints.length > 0) {
            console.log(`[VARIANTS] Injection points:`);
            injectionPoints.slice(0, 3).forEach((point, i) => {
                console.log(`  ${i + 1}. Selector: ${point.selector || 'N/A'}`);
                console.log(`     Confidence: ${point.confidence || 0}`);
                console.log(`     Type: ${point.elementType || point.type || 'unknown'}`);
            });
        }

        if (!brandAnalysis) {
            console.warn(`[VARIANTS] No brand analysis found for project: ${projectId}`);
            throw new Error(`No brand analysis available for project ${projectId}. Please run brand analysis first.`);
        }

        console.log(`[VARIANTS] Generating variant ideas with Google Gemini 2.5 Pro`);
        const aiConfig = getVariantGenerationAIConfig();

        // Use button-specific prompt when in demo mode (targeting button/link)
        const prompt = DEMO_CONDITION
            ? buildButtonVariantGenerationPrompt(hypothesis)
            : buildVariantGenerationPrompt(hypothesis, designSystem);

        console.log(`[VARIANTS] Using ${DEMO_CONDITION ? 'button-specific (demo mode)' : 'general'} prompt`);

        const object = await generateObject({
            model: google(aiConfig.model, {
                apiKey: aiConfig.apiKey,
            }),
            schema: basicVariantsResponseSchema,
            messages: [
                {
                    role: 'user',
                    content: [
                        { type: "text", text: prompt },
                        { type: "text", text: brandAnalysis },
                        { type: "image", image: toDataUrl(screenshot) }
                    ]
                }
            ]
        });
        const response = object.object;
        console.log(`[VARIANTS] AI response generated: ${response.variants.length} variant ideas`);

        // For testing, only use the first variant
        const variantsToProcess = process.env.TEST_MODE === 'true' ? response.variants.slice(0, 1) : response.variants;

        // PARALLEL PROCESSING: Generate JavaScript code for each variant
        console.log(`[VARIANTS] Generating JavaScript code for ${variantsToProcess.length} variants${process.env.TEST_MODE === 'true' ? ' (TEST MODE - limited to 1)' : ''}`);

        const variantsWithCode = await Promise.all(
            variantsToProcess.map(async (variant, index) => {
                console.log(`[VARIANTS] Processing variant ${index + 1}/${variantsToProcess.length}: ${variant.variant_label}`);

                // Generate JavaScript code for this variant
                let codeResult;
                try {
                    console.log(`[VARIANTS] Generating JavaScript for: ${variant.variant_label}`);
                    codeResult = await this.codeGenerator.generateCode(variant, hypothesis, brandAnalysis, toDataUrl(screenshot), injectionPoints, htmlContent);

                    // STAGE 2: Visual refinement if design system is available
                    if (designSystem && codeResult?.javascript_code) {
                        console.log(`[VARIANTS] Applying visual refinement for: ${variant.variant_label}`);
                        try {
                            const refinedResult = await this.visualRefinement.refineVariantCode(
                                codeResult.javascript_code,
                                variant.description,
                                designSystem,
                                toDataUrl(screenshot)
                            );

                            if (refinedResult.javascript_code && refinedResult.javascript_code !== codeResult.javascript_code) {
                                console.log(`[VARIANTS] Visual refinement applied successfully`);
                                console.log(`[VARIANTS] Improvements: ${refinedResult.improvements.slice(0, 3).join(', ')}`);
                                codeResult.javascript_code = refinedResult.javascript_code;
                            }
                        } catch (refineError) {
                            console.warn(`[VARIANTS] Visual refinement failed, using original code:`, refineError);
                        }
                    }

                    // Validate that the selector exists in the cleaned HTML (same as used for detection)
                    if (htmlContent && codeResult?.target_selector) {
                        try {
                            // Clean the HTML the same way the DOM analyzer does
                            const cheerio = require('cheerio');
                            const $ = cheerio.load(htmlContent);

                            // Remove script tags, style tags, and comments (same as DOM analyzer)
                            $('script').remove();
                            $('style').remove();
                            $('noscript').remove();
                            $('link[rel="stylesheet"]').remove();

                            // Now check if selector exists in cleaned HTML
                            const elements = $(codeResult.target_selector);

                            if (elements.length === 0) {
                                console.warn(`[VARIANTS] Selector not found in cleaned HTML: ${codeResult.target_selector}`);
                            } else {
                                console.log(`[VARIANTS] Selector validated in cleaned HTML: ${codeResult.target_selector} (${elements.length} matches)`);
                            }
                        } catch (selectorError) {
                            console.warn(`[VARIANTS] Invalid selector: ${codeResult.target_selector}`, selectorError);
                        }
                    }
                } catch (error) {
                    console.error(`[VARIANTS] Failed to generate code for variant ${variant.variant_label}:`, error);
                    codeResult = null;
                }

                // Create the final variant object with JavaScript code
                const finalVariant = {
                    ...variant,
                    javascript_code: codeResult?.javascript_code || '',
                    execution_timing: codeResult?.execution_timing || 'dom_ready',
                    target_selector: codeResult?.target_selector || '',
                    implementation_instructions: codeResult?.implementation_instructions || variant.description
                };

                return finalVariant;
            })
        );

        console.log(`[VARIANTS] All variants with JavaScript code generated successfully`);
        const result = {
            variantsSchema: JSON.stringify({ variants: variantsWithCode })
        };
        console.log(`[VARIANTS] Final result: ${variantsWithCode.length} variants, schema length: ${result.variantsSchema.length} chars`);
        return result;
    }

    private getPageType(url: string): 'home' | 'pdp' | 'about' | 'other' {
        const urlLower = url.toLowerCase();

        // Check for product pages first
        if (urlLower.includes('/products/') || urlLower.includes('/collections/')) {
            return 'pdp';
        }

        // Check for about pages
        if (urlLower.includes('/about')) {
            return 'about';
        }

        // Check for home page - this should be the most common case
        // Home page is typically just the domain or domain with trailing slash
        const urlObj = new URL(url);
        const pathname = urlObj.pathname;

        // If no path or just a trailing slash, it's the home page
        if (!pathname || pathname === '/' || pathname === '') {
            return 'home';
        }

        // If path is just common home page indicators
        if (pathname === '/home' || pathname === '/index' || pathname === '/index.html') {
            return 'home';
        }

        return 'other';
    }
}
</file>

<file path="package.json">
{
  "name": "backend",
  "version": "1.0.0",
  "main": "dist/index.js",
  "scripts": {
    "dev": "tsx watch -r tsconfig-paths/register src/index.ts",
    "dev:watch": "tsx watch -r tsconfig-paths/register src/index.ts",
    "build": "tsc",
    "start": "tsx -r tsconfig-paths/register dist/index.js",
    "lint": "eslint src/",
    "lint:fix": "eslint src/ --fix",
    "check:unused": "ts-unused-exports tsconfig.json",
    "check:types": "tsc --noEmit",
    "check:all": "npm run check:types && npm run check:unused && npm run lint",
    "db:generate": "prisma generate",
    "db:migrate": "prisma migrate dev",
    "db:deploy": "prisma migrate deploy",
    "db:studio": "prisma studio",
    "seed": "tsx -r tsconfig-paths/register scripts/seed.ts",
    "seed:reset": "tsx -r tsconfig-paths/register scripts/seed.ts --reset",
    "test": "echo \"Error: no test specified\" && exit 1",
    "test:variants": "tsx -r tsconfig-paths/register tests/integration/variant-pipeline.test.ts",
    "test:variants:simple": "tsx -r tsconfig-paths/register tests/integration/variant-simple.test.ts"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "engines": {
    "node": "20.x",
    "npm": "10.x"
  },
  "dependencies": {
    "@ai-sdk/google": "^2.0.16",
    "@ai-sdk/langchain": "^1.0.52",
    "@ai-sdk/openai": "^2.0.30",
    "@assistant-ui/react": "^0.11.18",
    "@assistant-ui/react-data-stream": "^0.11.0",
    "@aws-sdk/client-sqs": "^3.693.0",
    "@better-auth/cli": "^1.3.26",
    "@fastify/cors": "^11.1.0",
    "@mendable/firecrawl-js": "^4.3.6",
    "@prisma/client": "^6.16.1",
    "@shopify/admin-api-client": "^1.0.0",
    "@shopify/shopify-api": "^11.14.1",
    "@types/cheerio": "^0.22.35",
    "@types/jsonwebtoken": "^9.0.10",
    "ai": "^5.0.44",
    "assistant-stream": "^0.2.29",
    "auth0": "^4.30.0",
    "better-auth": "^1.3.26",
    "cheerio": "^1.1.2",
    "dompurify": "^3.2.6",
    "dotenv": "^16.4.5",
    "fastify": "^5.6.0",
    "fastify-plugin": "^5.1.0",
    "jsdom": "^26.1.0",
    "jsonwebtoken": "^9.0.2",
    "jwks-rsa": "^3.2.0",
    "langsmith": "^0.3.71",
    "node-fetch": "^3.3.2",
    "openai": "^5.20.1",
    "playwright": "^1.55.1",
    "posthog-node": "^5.8.4",
    "prisma": "^6.16.1",
    "tsconfig-paths": "^4.2.0",
    "tsx": "^4.20.5",
    "zod": "^3.25.76"
  },
  "devDependencies": {
    "@types/dompurify": "^3.0.5",
    "@types/jsdom": "^21.1.7",
    "@types/node": "^24.3.1",
    "@types/node-fetch": "^2.6.11",
    "@typescript-eslint/eslint-plugin": "^8.44.1",
    "@typescript-eslint/parser": "^8.44.1",
    "eslint": "^9.35.0",
    "pino-pretty": "^13.1.1",
    "ts-unused-exports": "^11.0.1",
    "typescript": "^5.9.2"
  }
}
</file>

</files>
