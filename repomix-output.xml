This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
prisma/
  migrations/
    20250929070921_init/
      migration.sql
    migration_lock.toml
  schema.prisma
src/
  app/
    container.ts
    server.ts
  domain/
    agent/
      tools/
        check-variants.ts
        create-experiment.ts
        generate-hypotheses.ts
        generate-variants.ts
        get-brand-analysis.ts
        get-project-info.ts
        index.ts
        schemas.ts
      agent.ts
      hypothesis-state-manager.ts
      index.ts
      prompts.ts
      types.ts
      variant-state-manager.ts
    analytics/
      index.ts
  features/
    brand_analysis/
      brand-analysis.ts
      code-analyzer.ts
      index.ts
      language-analyzer.ts
      screenshot-analyzer.ts
      types.ts
      url-selector.ts
    crawler/
      index.ts
      playwright.ts
      types.ts
    hypotheses_generation/
      hypotheses-generation.ts
      types.ts
    variant_generation/
      code-generator.ts
      dom-analyzer.ts
      prompts.ts
      types.ts
      variant-generation.ts
  infra/
    config/
      auth0.ts
      services.ts
    dal/
      chat-message.ts
      experiment.ts
      index.ts
      project.ts
      types.ts
      user.ts
      variant-job.ts
    external/
      auth0/
        auth0.ts
        index.ts
      cloudflare/
        cloudflare-publisher.ts
        index.ts
        types.ts
      posthog/
        config.ts
        index.ts
        service.ts
        types.ts
      shopify/
        config.ts
        graphql.ts
        index.ts
        oauth.ts
        README.md
        service.ts
    encryption.ts
    errors.ts
    prisma.ts
  interfaces/
    http/
      middleware/
        auth.ts
        authorization.ts
        validation.ts
      project/
        brandSummary.ts
        jobs.ts
      schemas/
        chat.schema.ts
      user/
        index.ts
        register.ts
        schemas.ts
      utils/
        chat-utils.ts
      chat.ts
      health.ts
      index.ts
      screenshots.ts
      shopify.ts
  services/
    experiment-publisher.ts
    index.ts
    job-cleanup.ts
    project-info.ts
    screenshot-analytics.ts
    screenshot-storage.ts
    variant-job-processor.ts
  shared/
    utils/
      html-simplifier.ts
    validation/
      sanitizers/
        css.sanitizer.ts
        html.sanitizer.ts
      schemas/
        experiment.schema.ts
      index.ts
      validator.ts
    ai-config.ts
    fastify.d.ts
    types.ts
  index.ts
.dockerignore
.env.prod
.gitignore
app.json
docker-compose.prod.yml
docker-compose.yml
Dockerfile
Dockerfile.prod
env.template
eslint.config.js
package.json
Procfile
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="prisma/migrations/20250929070921_init/migration.sql">
-- CreateEnum
CREATE TYPE "public"."JobStatus" AS ENUM ('DRAFT', 'PENDING', 'RUNNING', 'PAUSED', 'COMPLETED', 'FAILED');

-- CreateEnum
CREATE TYPE "public"."MessageRole" AS ENUM ('USER', 'AGENT', 'TOOL', 'SYSTEM');

-- CreateEnum
CREATE TYPE "public"."InjectPosition" AS ENUM ('INNER', 'OUTER', 'BEFORE', 'AFTER');

-- CreateTable
CREATE TABLE "public"."users" (
    "id" TEXT NOT NULL,
    "auth0Id" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "firstName" TEXT NOT NULL,
    "lastName" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "users_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."projects" (
    "id" TEXT NOT NULL,
    "shopDomain" TEXT NOT NULL,
    "brandAnalysis" JSONB,
    "accessTokenEnc" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "projects_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."experiments" (
    "id" TEXT NOT NULL,
    "projectId" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "status" "public"."JobStatus" NOT NULL DEFAULT 'DRAFT',
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "publishedAt" TIMESTAMP(3),
    "finishedAt" TIMESTAMP(3),
    "oec" TEXT NOT NULL,
    "minDays" INTEGER NOT NULL,
    "minSessionsPerVariant" INTEGER NOT NULL,

    CONSTRAINT "experiments_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."chat_messages" (
    "id" TEXT NOT NULL,
    "projectId" TEXT NOT NULL,
    "role" "public"."MessageRole" NOT NULL,
    "content" JSONB NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "chat_messages_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."brand_summary_jobs" (
    "id" TEXT NOT NULL,
    "projectId" TEXT NOT NULL,
    "status" "public"."JobStatus" NOT NULL DEFAULT 'PENDING',
    "progress" INTEGER DEFAULT 0,
    "result" JSONB,
    "error" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "startedAt" TIMESTAMP(3),
    "completedAt" TIMESTAMP(3),

    CONSTRAINT "brand_summary_jobs_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."variant_jobs" (
    "id" TEXT NOT NULL,
    "projectId" TEXT NOT NULL,
    "status" "public"."JobStatus" NOT NULL DEFAULT 'PENDING',
    "progress" INTEGER DEFAULT 0,
    "result" JSONB,
    "error" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "startedAt" TIMESTAMP(3),
    "completedAt" TIMESTAMP(3),

    CONSTRAINT "variant_jobs_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."experiment_hypotheses" (
    "id" TEXT NOT NULL,
    "experimentId" TEXT NOT NULL,
    "hypothesis" TEXT NOT NULL,
    "rationale" TEXT NOT NULL,
    "primaryKpi" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "experiment_hypotheses_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."experiment_traffic" (
    "id" TEXT NOT NULL,
    "experimentId" TEXT NOT NULL,
    "variantId" TEXT NOT NULL,
    "percentage" DECIMAL(5,4) NOT NULL,

    CONSTRAINT "experiment_traffic_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."experiment_variants" (
    "id" TEXT NOT NULL,
    "experimentId" TEXT NOT NULL,
    "variantId" TEXT NOT NULL,
    "selector" TEXT,
    "html" TEXT NOT NULL,
    "css" TEXT,
    "position" "public"."InjectPosition" NOT NULL,

    CONSTRAINT "experiment_variants_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "public"."screenshots" (
    "id" TEXT NOT NULL,
    "projectId" TEXT NOT NULL,
    "url" TEXT NOT NULL,
    "pageType" TEXT NOT NULL,
    "variantId" TEXT,
    "viewportWidth" INTEGER NOT NULL,
    "viewportHeight" INTEGER NOT NULL,
    "fullPage" BOOLEAN NOT NULL,
    "quality" INTEGER NOT NULL,
    "data" BYTEA NOT NULL,
    "htmlContent" TEXT,
    "fileSize" INTEGER NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "expiresAt" TIMESTAMP(3) NOT NULL,
    "accessedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "accessCount" INTEGER NOT NULL DEFAULT 0,

    CONSTRAINT "screenshots_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "users_auth0Id_key" ON "public"."users"("auth0Id");

-- CreateIndex
CREATE UNIQUE INDEX "users_email_key" ON "public"."users"("email");

-- CreateIndex
CREATE UNIQUE INDEX "projects_shopDomain_key" ON "public"."projects"("shopDomain");

-- CreateIndex
CREATE UNIQUE INDEX "projects_userId_key" ON "public"."projects"("userId");

-- CreateIndex
CREATE INDEX "experiments_projectId_status_idx" ON "public"."experiments"("projectId", "status");

-- CreateIndex
CREATE INDEX "chat_messages_projectId_createdAt_idx" ON "public"."chat_messages"("projectId", "createdAt");

-- CreateIndex
CREATE INDEX "brand_summary_jobs_projectId_status_createdAt_idx" ON "public"."brand_summary_jobs"("projectId", "status", "createdAt");

-- CreateIndex
CREATE INDEX "brand_summary_jobs_status_createdAt_idx" ON "public"."brand_summary_jobs"("status", "createdAt");

-- CreateIndex
CREATE INDEX "variant_jobs_projectId_status_createdAt_idx" ON "public"."variant_jobs"("projectId", "status", "createdAt");

-- CreateIndex
CREATE INDEX "variant_jobs_status_createdAt_idx" ON "public"."variant_jobs"("status", "createdAt");

-- CreateIndex
CREATE UNIQUE INDEX "experiment_hypotheses_experimentId_key" ON "public"."experiment_hypotheses"("experimentId");

-- CreateIndex
CREATE INDEX "experiment_traffic_experimentId_idx" ON "public"."experiment_traffic"("experimentId");

-- CreateIndex
CREATE UNIQUE INDEX "experiment_traffic_experimentId_variantId_key" ON "public"."experiment_traffic"("experimentId", "variantId");

-- CreateIndex
CREATE INDEX "experiment_variants_experimentId_idx" ON "public"."experiment_variants"("experimentId");

-- CreateIndex
CREATE UNIQUE INDEX "experiment_variants_experimentId_variantId_key" ON "public"."experiment_variants"("experimentId", "variantId");

-- CreateIndex
CREATE INDEX "screenshots_projectId_idx" ON "public"."screenshots"("projectId");

-- CreateIndex
CREATE INDEX "screenshots_expiresAt_idx" ON "public"."screenshots"("expiresAt");

-- CreateIndex
CREATE INDEX "screenshots_pageType_idx" ON "public"."screenshots"("pageType");

-- CreateIndex
CREATE INDEX "screenshots_variantId_idx" ON "public"."screenshots"("variantId");

-- CreateIndex
CREATE UNIQUE INDEX "screenshots_projectId_pageType_variantId_viewportWidth_view_key" ON "public"."screenshots"("projectId", "pageType", "variantId", "viewportWidth", "viewportHeight", "fullPage", "quality");

-- AddForeignKey
ALTER TABLE "public"."projects" ADD CONSTRAINT "projects_userId_fkey" FOREIGN KEY ("userId") REFERENCES "public"."users"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."experiments" ADD CONSTRAINT "experiments_projectId_fkey" FOREIGN KEY ("projectId") REFERENCES "public"."projects"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."chat_messages" ADD CONSTRAINT "chat_messages_projectId_fkey" FOREIGN KEY ("projectId") REFERENCES "public"."projects"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."brand_summary_jobs" ADD CONSTRAINT "brand_summary_jobs_projectId_fkey" FOREIGN KEY ("projectId") REFERENCES "public"."projects"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."variant_jobs" ADD CONSTRAINT "variant_jobs_projectId_fkey" FOREIGN KEY ("projectId") REFERENCES "public"."projects"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."experiment_hypotheses" ADD CONSTRAINT "experiment_hypotheses_experimentId_fkey" FOREIGN KEY ("experimentId") REFERENCES "public"."experiments"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."experiment_traffic" ADD CONSTRAINT "experiment_traffic_experimentId_fkey" FOREIGN KEY ("experimentId") REFERENCES "public"."experiments"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."experiment_variants" ADD CONSTRAINT "experiment_variants_experimentId_fkey" FOREIGN KEY ("experimentId") REFERENCES "public"."experiments"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "public"."screenshots" ADD CONSTRAINT "screenshots_projectId_fkey" FOREIGN KEY ("projectId") REFERENCES "public"."projects"("id") ON DELETE CASCADE ON UPDATE CASCADE;
</file>

<file path="src/domain/agent/tools/check-variants.ts">
// @ts-nocheck 
import { tool } from 'ai';
import { z } from 'zod';
import { variantStateManager } from '../variant-state-manager';
import { VariantJobDAL } from '@infra/dal';

const checkVariantsSchema = z.object({
  projectId: z.string().optional().describe('The project ID to check variants for - if not provided, will use the current project')
});

class CheckVariantsExecutor {
  private projectId: string;

  constructor(projectId: string) {
    this.projectId = projectId;
  }

  async execute(input: { projectId?: string }): Promise<{ 
    status: string; 
    message: string; 
    variantsFound: number;
    jobsStatus: any;
  }> {
    const projectId = input.projectId || this.projectId;
    
    console.log(`[CHECK_VARIANTS] ===== CHECKING VARIANTS STATUS =====`);
    console.log(`[CHECK_VARIANTS] Project ID: ${projectId}`);
    
    try {
      // Check current state manager status
      const currentVariants = variantStateManager.getCurrentVariants();
      const hasCurrentVariants = variantStateManager.hasCurrentVariants();
      const variantCount = variantStateManager.getCurrentVariantCount();
      
      console.log(`[CHECK_VARIANTS] State manager status:`);
      console.log(`[CHECK_VARIANTS] - Has current variants: ${hasCurrentVariants}`);
      console.log(`[CHECK_VARIANTS] - Current variant count: ${variantCount}`);
      console.log(`[CHECK_VARIANTS] - Current variants: ${currentVariants ? currentVariants.length : 'null'}`);
      
      // Check jobs status
      const jobs = await VariantJobDAL.getJobsByProject(projectId);
      const jobsByStatus = jobs.reduce((acc, job) => {
        acc[job.status] = (acc[job.status] || 0) + 1;
        return acc;
      }, {} as Record<string, number>);
      
      const completedJobs = jobs.filter(job => job.status === 'COMPLETED' && job.result);
      const runningJobs = jobs.filter(job => job.status === 'RUNNING');
      const pendingJobs = jobs.filter(job => job.status === 'PENDING');
      const failedJobs = jobs.filter(job => job.status === 'FAILED');
      
      console.log(`[CHECK_VARIANTS] Jobs status:`);
      console.log(`[CHECK_VARIANTS] - Total jobs: ${jobs.length}`);
      console.log(`[CHECK_VARIANTS] - Completed: ${completedJobs.length}`);
      console.log(`[CHECK_VARIANTS] - Running: ${runningJobs.length}`);
      console.log(`[CHECK_VARIANTS] - Pending: ${pendingJobs.length}`);
      console.log(`[CHECK_VARIANTS] - Failed: ${failedJobs.length}`);
      
      // Try to load variants from completed jobs
      let variantsFound = 0;
      let message = '';
      
      if (completedJobs.length > 0) {
        console.log(`[CHECK_VARIANTS] Attempting to load variants from ${completedJobs.length} completed jobs...`);
        const loadedVariants = await variantStateManager.loadVariantsFromJobs(projectId);
        variantsFound = loadedVariants.length;
        
        if (variantsFound > 0) {
          message = `Successfully loaded ${variantsFound} variants from completed jobs. Variants are now available in the state manager.`;
          console.log(`[CHECK_VARIANTS] ${message}`);
        } else {
          message = `Found ${completedJobs.length} completed jobs but no variants could be extracted. This might indicate an issue with the job results.`;
          console.log(`[CHECK_VARIANTS] ${message}`);
        }
      } else if (runningJobs.length > 0 || pendingJobs.length > 0) {
        message = `Found ${runningJobs.length} running and ${pendingJobs.length} pending jobs. Variants are still being processed. Please wait for completion.`;
        console.log(`[CHECK_VARIANTS] ${message}`);
      } else if (failedJobs.length > 0) {
        message = `Found ${failedJobs.length} failed jobs. No variants were generated successfully.`;
        console.log(`[CHECK_VARIANTS] ${message}`);
      } else {
        message = `No variant jobs found for this project. Please generate variants first using the generate_variants tool.`;
        console.log(`[CHECK_VARIANTS] ${message}`);
      }
      
      console.log(`[CHECK_VARIANTS] ======================================`);
      
      return {
        status: variantsFound > 0 ? 'SUCCESS' : 'NO_VARIANTS',
        message,
        variantsFound,
        jobsStatus: {
          total: jobs.length,
          completed: completedJobs.length,
          running: runningJobs.length,
          pending: pendingJobs.length,
          failed: failedJobs.length,
          byStatus: jobsByStatus
        }
      };
    } catch (error) {
      console.error(`[CHECK_VARIANTS] Failed to check variants:`, error);
      return {
        status: 'ERROR',
        message: `Failed to check variants: ${error instanceof Error ? error.message : 'Unknown error'}`,
        variantsFound: 0,
        jobsStatus: {}
      };
    }
  }
}

export function checkVariants(projectId: string) {
  const executor = new CheckVariantsExecutor(projectId);

  return tool({
    description: 'Check the current status of variant generation jobs and load completed variants into the state manager',
    inputSchema: checkVariantsSchema,
    execute: async (input) => {
      try {
        const result = await executor.execute(input);
        return result;
      } catch (error) {
        console.error(`[CHECK_VARIANTS] Tool execute failed:`, error);
        throw new Error(error instanceof Error ? error.message : 'Failed to check variants');
      }
    },
  });
}
</file>

<file path="src/features/crawler/index.ts">
// Web Crawler External Service
export { PlaywrightCrawlerService, createPlaywrightCrawler } from './playwright';
export type { CrawlerService, CrawlResult, CrawlOptions, CrawlerConfig } from './types';
</file>

<file path="src/features/hypotheses_generation/types.ts">
// Types for hypotheses generation
export interface Hypothesis {
  hypothesis: string;
  rationale: string;
  measurable_tests: string;
  success_metrics: string;
  oec: string;
  accessibility_check: string;
}
</file>

<file path="src/features/variant_generation/prompts.ts">
// Prompts for variant generation service
import { Hypothesis } from '@features/hypotheses_generation/types';

export function buildVariantGenerationPrompt(hypothesis: Hypothesis): string {
    return `
You are a CRO-focused UX/UI design assistant. Your task is to take a structured hypothesis and generate 3 practical, testable variants for A/B testing.

HYPOTHESIS TO TEST:
- Hypothesis: ${hypothesis.hypothesis}
- Rationale: ${hypothesis.rationale}
- Measurable Tests: ${hypothesis.measurable_tests}
- Success Metrics: ${hypothesis.success_metrics}
- OEC (Overall Evaluation Criterion): ${hypothesis.oec}
- Accessibility Check: ${hypothesis.accessibility_check}

YOUR TASK:
Based on the hypothesis above, identify the most likely DOM element(s) or site objects that this hypothesis refers to and generate 3 practical, testable variants.

Step 1 - Translate Hypothesis to DOM Target:
- Infer the relevant DOM element(s) (class names, IDs, attributes, role, or common HTML tags)
- If multiple candidates exist (e.g., several CTAs), identify the primary one based on hierarchy or context
- Output both a human-readable description (e.g., "Main Add to Cart button below price") and a technical guess (e.g., .product-form button[type=submit])
- If no reliable target can be inferred, output a fallback: "Unable to map hypothesis to a specific DOM object"

Step 2 - Generate Variants:
For the identified element(s), create 3 variant ideas with:
- Variant Label - short name
- Description - what visually or structurally changes
- Rationale - why this might improve performance (CRO/UX principle)
- Accessibility Consideration - check for WCAG compliance (contrast, tap size, ARIA roles, etc.)
- Implementation Notes - specific technical details for implementation

CONSTRAINTS:
- Keep all suggestions UI-focused (no backend, pricing, or copywriting strategy beyond short CTA tweaks)
- Ensure changes are measurable in an experiment
- Stay general enough to apply to ~80% of Shopify stores
- Build upon the existing hypothesis rationale and success metrics
- Consider the accessibility issues already identified in the hypothesis

IMPORTANT: Return your response as a JSON object with a "variants" array containing exactly 3 variant objects. Each variant must have the fields: variant_label, description, rationale, accessibility_consideration, and implementation_notes. 

Note: After generating these variants, the system will automatically generate the actual CSS and HTML code for each variant, so focus on clear, specific descriptions that can be easily translated into code. Do NOT return a schema definition - return actual data.`;
}
</file>

<file path="src/infra/config/auth0.ts">
/**
 * Auth0 Configuration
 * 
 * Environment variables required:
 * - AUTH0_DOMAIN: Your Auth0 tenant domain (e.g., "your-tenant.auth0.com")
 * - AUTH0_AUDIENCE: Your API identifier from Auth0 dashboard
 * - AUTH0_ISSUER: Usually "https://{AUTH0_DOMAIN}/"
 */

export const auth0Config = {
  domain: process.env.AUTH0_DOMAIN!,
  audience: process.env.AUTH0_AUDIENCE!,
  issuer: process.env.AUTH0_ISSUER!,
  jwksUri: `https://${process.env.AUTH0_DOMAIN}/.well-known/jwks.json`,
};

// Validate required environment variables
const requiredEnvVars = ['AUTH0_DOMAIN', 'AUTH0_AUDIENCE', 'AUTH0_ISSUER'];
const missingVars = requiredEnvVars.filter(varName => !process.env[varName]);

if (missingVars.length > 0) {
  throw new Error(`Missing required environment variables: ${missingVars.join(', ')}`);
}
</file>

<file path="src/infra/dal/variant-job.ts">
import { prisma } from '@infra/prisma';
import { JobStatus } from '@prisma/client';

export interface CreateVariantJobData {
    projectId: string;
}

export interface UpdateVariantJobData {
    status?: JobStatus;
    progress?: number;
    result?: any;
    error?: string;
    startedAt?: Date;
    completedAt?: Date;
}

export interface VariantJob {
    id: string;
    projectId: string;
    status: JobStatus;
    progress: number | null;
    result: any;
    error: string | null;
    createdAt: Date;
    startedAt: Date | null;
    completedAt: Date | null;
}

export class VariantJobDAL {
    static async createJob(data: CreateVariantJobData): Promise<VariantJob> {
        return await prisma.variantJob.create({
            data: {
                projectId: data.projectId,
                status: 'PENDING',
                progress: 0,
            },
        });
    }

    static async getJobById(jobId: string): Promise<VariantJob | null> {
        return await prisma.variantJob.findUnique({
            where: { id: jobId },
        });
    }

    static async getJobsByProject(
        projectId: string,
        limit?: number,
        offset?: number
    ): Promise<VariantJob[]> {
        return await prisma.variantJob.findMany({
            where: { projectId },
            orderBy: { createdAt: 'desc' },
            ...(limit && { take: limit }),
            ...(offset && { skip: offset }),
        });
    }

    static async updateJob(jobId: string, data: UpdateVariantJobData): Promise<VariantJob> {
        return await prisma.variantJob.update({
            where: { id: jobId },
            data: {
                ...data,
                ...(data.status === 'RUNNING' && !data.startedAt && { startedAt: new Date() }),
                ...(data.status === 'COMPLETED' && !data.completedAt && { completedAt: new Date() }),
                ...(data.status === 'FAILED' && !data.completedAt && { completedAt: new Date() }),
            },
        });
    }

    static async deleteJob(jobId: string): Promise<void> {
        await prisma.variantJob.delete({
            where: { id: jobId },
        });
    }

    static async getJobsByStatus(status: JobStatus, limit?: number): Promise<VariantJob[]> {
        return await prisma.variantJob.findMany({
            where: { status },
            orderBy: { createdAt: 'asc' },
            ...(limit && { take: limit }),
        });
    }

    static async cleanupOldJobs(olderThanDays: number = 7): Promise<number> {
        const cutoffDate = new Date();
        cutoffDate.setDate(cutoffDate.getDate() - olderThanDays);

        const result = await prisma.variantJob.deleteMany({
            where: {
                status: {
                    in: ['COMPLETED', 'FAILED'],
                },
                completedAt: {
                    lt: cutoffDate,
                },
            },
        });

        return result.count;
    }
}
</file>

<file path="src/infra/external/auth0/index.ts">
export * from './auth0';
</file>

<file path="src/infra/external/cloudflare/types.ts">
// Cloudflare Publisher Types
import type { InjectPosition } from '@prisma/client';

export interface CloudflareConfig {
  accountId: string;
  apiToken: string;
  namespaceId: string;
}

export interface PublishedExperiment {
  id: string;
  projectId: string;
  name: string;
  status: string;
  oec: string;
  traffic: Record<string, number>;
  variants: Record<string, PublishedVariant>;
}

export interface PublishedVariant {
  selector: string;
  html: string;
  css: string;
  position: InjectPosition;
}

export interface CloudflarePublishResult {
  success: boolean;
  experimentId: string;
  key?: string;
  error?: string;
}
</file>

<file path="src/infra/external/posthog/config.ts">
/**
 * PostHog Configuration
 * 
 * Configuration for PostHog analytics integration with EU host support
 */

export interface PostHogConfig {
  apiKey: string;
  host: string;
  projectId: string;
  timeout?: number;
  retryAttempts?: number;
}

export function getPostHogConfig(): PostHogConfig {
  const apiKey = process.env.POSTHOG_API_KEY;
  if (!apiKey) {
    throw new Error('POSTHOG_API_KEY environment variable is required');
  }

  const projectId = process.env.POSTHOG_PROJECT_ID;
  if (!projectId) {
    throw new Error('POSTHOG_PROJECT_ID environment variable is required');
  }

  // Default to EU host for GDPR compliance
  const host = process.env.POSTHOG_HOST || 'https://eu.posthog.com';
  
  return {
    apiKey,
    host,
    projectId,
    timeout: parseInt(process.env.POSTHOG_TIMEOUT || '10000'),
    retryAttempts: parseInt(process.env.POSTHOG_RETRY_ATTEMPTS || '3'),
  };
}
</file>

<file path="src/infra/external/posthog/service.ts">
/**
 * PostHog Service
 * 
 * Service for querying PostHog analytics data for experiment status
 */

import { PostHog } from 'posthog-node';
import fetch from 'node-fetch';
import { getPostHogConfig } from './config';
import type {
  PostHogQueryParams,
  PostHogQueryResponse,
  PostHogEvent,
} from './types';
import type { ExperimentStatus, VariantMetrics } from '../../../shared/types';
import {
  PostHogConnectionError,
  PostHogQueryError,
  PostHogRateLimitError,
} from '../../errors';

export class PostHogService {
  private client: PostHog;
  private config: ReturnType<typeof getPostHogConfig>;

  constructor() {
    this.config = getPostHogConfig();
    this.client = new PostHog(this.config.apiKey, {
      host: this.config.host,
    });
  }

  /**
   * Query PostHog for experiment analytics data
   */
  async queryExperimentMetrics(params: PostHogQueryParams): Promise<ExperimentStatus> {
    try {
      const { projectId, experimentId, startDate, endDate, primaryKPI, guardrails = [] } = params;
      const configProjectId = this.config.projectId;

      // Query pageviews for denominator
      const pageviewEvents = await this.queryEvents({
        projectId: configProjectId,
        experimentId,
        startDate,
        endDate,
        eventName: '$pageview',
        properties: {
          experimentId,
          projectId,
        },
      });

      // Query primary KPI events
      const primaryKPIEvents = await this.queryEvents({
        projectId: configProjectId,
        experimentId,
        startDate,
        endDate,
        eventName: primaryKPI,
        properties: {
          experimentId,
          projectId,
        },
      });

      // Query guardrail events if specified
      const guardrailEvents = guardrails.length > 0 
        ? await this.queryGuardrailEvents({
            projectId: configProjectId,
            experimentId,
            startDate,
            endDate,
            guardrails,
          })
        : {};

      // Aggregate metrics by variant
      const variantMetrics = this.aggregateVariantMetrics(
        pageviewEvents,
        primaryKPIEvents,
        guardrailEvents,
        primaryKPI
      );

      // Calculate traffic distribution (this would come from experiment DSL)
      const traffic = this.calculateTrafficDistribution(variantMetrics);

      // Find leader and calculate lift vs A
      const leader = this.findLeader(variantMetrics);
      const liftVsA = this.calculateLiftVsA(variantMetrics);

      return {
        state: 'running', // This would come from experiment status
        traffic,
        variants: variantMetrics,
        leader,
        liftVsA,
        meta: {
          timeframe: {
            start: startDate,
            end: endDate,
          },
          denominator: 'pageviews',
          totalSessions: pageviewEvents.length,
        },
      };
    } catch (error) {
      if (error instanceof PostHogConnectionError || error instanceof PostHogQueryError || error instanceof PostHogRateLimitError) {
        throw error;
      }
      
      if (error && typeof error === 'object' && 'message' in error) {
        const message = typeof error.message === 'string' ? error.message : 'Unknown PostHog error';
        throw new PostHogConnectionError({ originalError: message });
      }
      
      throw new PostHogConnectionError();
    }
  }

  /**
   * Query PostHog events using the Query API
   */
  private async queryEvents(params: {
    projectId: string;
    experimentId: string;
    startDate: string;
    endDate: string;
    eventName: string;
    properties: Record<string, unknown>;
  }): Promise<PostHogEvent[]> {
    const { projectId, experimentId, startDate, endDate, eventName, properties } = params;
    
    let lastError: Error | null = null;
    
    for (let attempt = 1; attempt <= (this.config.retryAttempts || 3); attempt++) {
      try {
        // Build HogQL query for events
        const whereConditions = [
          `event = '${eventName}'`,
          `properties.experimentId = '${experimentId}'`,
          `properties.projectId = '${projectId}'`,
          `timestamp >= '${startDate}'`,
          `timestamp <= '${endDate}'`
        ];

        // Add additional property filters
        for (const [key, value] of Object.entries(properties)) {
          if (key !== 'experimentId' && key !== 'projectId') {
            whereConditions.push(`properties.${key} = '${value}'`);
          }
        }

        const hogqlQuery = `
          SELECT 
            event,
            properties,
            timestamp,
            distinct_id
          FROM events 
          WHERE ${whereConditions.join(' AND ')}
          ORDER BY timestamp DESC
          LIMIT 10000
        `;

        const response = await this.executeQuery(projectId, {
          kind: 'HogQLQuery',
          query: hogqlQuery
        });

        // Transform PostHog response to our event format
        const events: PostHogEvent[] = response.results?.map((row: Record<string, unknown>) => ({
          event: row.event as string,
          properties: (row.properties as Record<string, unknown>) || {},
          timestamp: row.timestamp as string,
          distinct_id: row.distinct_id as string
        })) || [];

        return events;
      } catch (error) {
        lastError = error as Error;
        
        if (attempt < (this.config.retryAttempts || 3)) {
          // Wait before retry (exponential backoff)
          await new Promise(resolve => global.setTimeout(resolve, Math.pow(2, attempt) * 1000));
          continue;
        }
        
        // Handle specific error types
        if (error && typeof error === 'object' && 'status' in error) {
          const status = (error as Record<string, unknown>).status;
          if (status === 429) {
            const headers = (error as Record<string, unknown>).headers as Record<string, unknown> | undefined;
            const retryAfter = headers?.['retry-after'];
            throw new PostHogRateLimitError(parseInt(String(retryAfter)), error);
          }
          if (typeof status === 'number' && status >= 400 && status < 500) {
            throw new PostHogQueryError(`PostHog query failed: ${lastError.message}`, error);
          }
        }
        
        throw new PostHogConnectionError({ originalError: lastError.message });
      }
    }
    
    throw new PostHogConnectionError({ originalError: lastError?.message });
  }

  /**
   * Execute a PostHog Query API request
   */
  private async executeQuery(projectId: string, query: { kind: string; query: string }): Promise<PostHogQueryResponse> {
    const url = `${this.config.host}/api/projects/${projectId}/query/`;
    
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.config.apiKey}`,
      },
      body: JSON.stringify({ query }),
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      const error = new Error(`PostHog API error: ${response.status} ${response.statusText}`);
      (error as Error & { status: number; headers: Record<string, string>; data: unknown }).status = response.status;
      (error as Error & { status: number; headers: Record<string, string>; data: unknown }).headers = Object.fromEntries(response.headers.entries());
      (error as Error & { status: number; headers: Record<string, string>; data: unknown }).data = errorData;
      throw error;
    }

    const data = await response.json() as Record<string, unknown>;
    
    // Handle query status
    if (data.query_status === 'error') {
      throw new PostHogQueryError(`PostHog query error: ${data.error || 'Unknown error'}`, data);
    }

    return {
      results: (data.results as Record<string, unknown>[]) || [],
      hasMore: (data.hasMore as boolean) || false,
      next: data.next as string | undefined
    };
  }

  /**
   * Query guardrail events
   */
  private async queryGuardrailEvents(params: {
    projectId: string;
    experimentId: string;
    startDate: string;
    endDate: string;
    guardrails: string[];
  }): Promise<Record<string, PostHogEvent[]>> {
    const { experimentId, startDate, endDate, guardrails } = params;
    const configProjectId = this.config.projectId;
    const results: Record<string, PostHogEvent[]> = {};

    for (const guardrail of guardrails) {
      try {
        const events = await this.queryEvents({
          projectId: configProjectId,
          experimentId,
          startDate,
          endDate,
          eventName: guardrail,
          properties: {
            experimentId,
            projectId: params.projectId, // Keep the original projectId for filtering
          },
        });
        results[guardrail] = events;
      } catch (error) {
        // Log error but continue with other guardrails
        console.warn(`Failed to query guardrail ${guardrail}:`, error);
        results[guardrail] = [];
      }
    }

    return results;
  }

  /**
   * Aggregate metrics by variant
   */
  private aggregateVariantMetrics(
    pageviewEvents: PostHogEvent[],
    primaryKPIEvents: PostHogEvent[],
    guardrailEvents: Record<string, PostHogEvent[]>,
    primaryKPI: string
  ): VariantMetrics[] {
    const variantMap = new Map<string, {
      sessions: Set<string>;
      primaryKPICount: number;
      guardrails: Record<string, number>;
    }>();

    // Process pageview events for sessions
    for (const event of pageviewEvents) {
      const variantId = event.properties.variantId as string;
      const distinctId = event.distinct_id;
      
        if (variantId && distinctId) {
          if (!variantMap.has(variantId)) {
            variantMap.set(variantId, {
              sessions: new Set(),
              primaryKPICount: 0,
              guardrails: {},
            });
          }
          
          const variantData = variantMap.get(variantId);
          if (variantData) {
            variantData.sessions.add(distinctId);
          }
        }
    }

    // Process primary KPI events
    for (const event of primaryKPIEvents) {
      const variantId = event.properties.variantId as string;
      
      if (variantId && variantMap.has(variantId)) {
        const variantData = variantMap.get(variantId);
        if (variantData) {
          variantData.primaryKPICount++;
        }
      }
    }

    // Process guardrail events
    for (const [guardrail, events] of Object.entries(guardrailEvents)) {
      for (const event of events) {
        const variantId = event.properties.variantId as string;
        
        if (variantId && variantMap.has(variantId)) {
          const variant = variantMap.get(variantId);
          if (variant) {
            variant.guardrails[guardrail] = (variant.guardrails[guardrail] || 0) + 1;
          }
        }
      }
    }

    // Convert to VariantMetrics array
    const metrics: VariantMetrics[] = [];
    
    for (const [variantId, data] of variantMap.entries()) {
      const sessions = data.sessions.size;
      const primaryKPICount = data.primaryKPICount;
      const rate = sessions > 0 ? primaryKPICount / sessions : 0;

      const guardrails = this.calculateGuardrailLabels(data.guardrails, sessions);

      metrics.push({
        variantId,
        sessions,
        primaryKPI: {
          name: primaryKPI,
          count: primaryKPICount,
          rate,
        },
        guardrails: Object.keys(guardrails).length > 0 ? guardrails : undefined,
      });
    }

    return metrics.sort((a, b) => a.variantId.localeCompare(b.variantId));
  }

  /**
   * Calculate guardrail labels based on thresholds
   */
  private calculateGuardrailLabels(
    guardrailCounts: Record<string, number>,
    sessions: number
  ): Record<string, 'normal' | 'elevated'> {
    const labels: Record<string, 'normal' | 'elevated'> = {};
    
    for (const [guardrail, count] of Object.entries(guardrailCounts)) {
      // Simple threshold logic - in production, you'd want more sophisticated analysis
      const rate = sessions > 0 ? count / sessions : 0;
      
      switch (guardrail) {
        case 'lcp':
          // LCP > 2.5s is considered elevated
          labels.lcp = rate > 0.1 ? 'elevated' : 'normal';
          break;
        case 'js_errors':
          // JS error rate > 1% is considered elevated
          labels.jsErrors = rate > 0.01 ? 'elevated' : 'normal';
          break;
        case 'cls':
          // CLS > 0.1 is considered elevated
          labels.cls = rate > 0.1 ? 'elevated' : 'normal';
          break;
      }
    }
    
    return labels;
  }

  /**
   * Calculate traffic distribution from variant metrics
   */
  private calculateTrafficDistribution(metrics: VariantMetrics[]): Record<string, number> {
    const totalSessions = metrics.reduce((sum, m) => sum + m.sessions, 0);
    
    if (totalSessions === 0) {
      return {};
    }

    const distribution: Record<string, number> = {};
    for (const metric of metrics) {
      distribution[metric.variantId] = metric.sessions / totalSessions;
    }

    return distribution;
  }

  /**
   * Find the leading variant
   */
  private findLeader(metrics: VariantMetrics[]): string | undefined {
    if (metrics.length === 0) return undefined;

    return metrics.reduce((leader, current) => 
      current.primaryKPI.rate > leader.primaryKPI.rate ? current : leader
    ).variantId;
  }

  /**
   * Calculate lift vs variant A
   */
  private calculateLiftVsA(metrics: VariantMetrics[]): number | undefined {
    const variantA = metrics.find(m => m.variantId === 'A');
    if (!variantA || variantA.primaryKPI.rate === 0) return undefined;

    const otherVariants = metrics.filter(m => m.variantId !== 'A');
    if (otherVariants.length === 0) return undefined;

    // Calculate average lift of other variants vs A
    const totalLift = otherVariants.reduce((sum, variant) => {
      const lift = ((variant.primaryKPI.rate - variantA.primaryKPI.rate) / variantA.primaryKPI.rate) * 100;
      return sum + lift;
    }, 0);

    return totalLift / otherVariants.length;
  }

  /**
   * Close the PostHog client
   */
  async close(): Promise<void> {
    await this.client.shutdown();
  }
}
</file>

<file path="src/infra/external/shopify/README.md">
# Shopify External Service

This module handles all Shopify-related functionality including OAuth flow, API calls, and shop profile management.

## Files

- **`config.ts`**: Shopify API configuration and environment variable validation
- **`service.ts`**: Main Shopify service with API methods and utilities
- **`index.ts`**: Clean exports for the service and types

## Features

### OAuth Flow
- Generate OAuth URLs for store authorization
- Handle OAuth callbacks with HMAC validation
- Exchange authorization codes for access tokens

### Shop Management
- Fetch shop profile information
- Validate and normalize shop domains
- Store encrypted access tokens

### API Integration
- Shopify Admin API integration
- Error handling for API failures
- Type-safe API responses

## Usage

```typescript
import { shopify, shopifyConfig } from '@infra/external/shopify';

// Generate OAuth URL
const oauthUrl = shopify.generateOAuthUrl('shop-name.myshopify.com', state);

// Exchange code for token
const tokenResponse = await shopify.exchangeCodeForToken(shop, code);

// Fetch shop profile
const shopProfile = await shopify.getShopProfile(shop, accessToken);
```

## Configuration

Required environment variables:
- `SHOPIFY_API_KEY`: Shopify app API key
- `SHOPIFY_API_SECRET`: Shopify app secret
- `SHOPIFY_SCOPES`: Required permissions (comma-separated)
- `SHOPIFY_REDIRECT_URI`: OAuth callback URL
- `ENCRYPTION_KEY`: 32-character encryption key for token storage
</file>

<file path="src/infra/encryption.ts">
import crypto from 'crypto';
import { shopifyConfig } from './external/shopify/config';

/**
 * Encryption utilities for sensitive data like Shopify access tokens
 */

const ALGORITHM = 'aes-256-gcm';
const IV_LENGTH = 16; // For GCM, this is always 16
const SALT_LENGTH = 64;
const TAG_LENGTH = 16;

/**
 * Encrypt a string using AES-256-GCM
 */
export function encrypt(text: string): string {
  const iv = crypto.randomBytes(IV_LENGTH);
  const salt = crypto.randomBytes(SALT_LENGTH);
  
  // Derive key from password and salt
  const key = crypto.pbkdf2Sync(shopifyConfig.encryptionKey, salt, 100000, 32, 'sha512');
  
  const cipher = crypto.createCipheriv(ALGORITHM, key, iv);
  cipher.setAAD(salt);
  
  let encrypted = cipher.update(text, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  
  const tag = cipher.getAuthTag();
  
  // Combine salt + iv + tag + encrypted data
  const combined = Buffer.concat([salt, iv, tag, Buffer.from(encrypted, 'hex')]);
  
  return combined.toString('base64');
}

/**
 * Decrypt a string using AES-256-GCM
 */
export function decrypt(encryptedData: string): string {
  const combined = Buffer.from(encryptedData, 'base64');
  
  // Extract components
  const salt = combined.subarray(0, SALT_LENGTH);
  const iv = combined.subarray(SALT_LENGTH, SALT_LENGTH + IV_LENGTH);
  const tag = combined.subarray(SALT_LENGTH + IV_LENGTH, SALT_LENGTH + IV_LENGTH + TAG_LENGTH);
  const encrypted = combined.subarray(SALT_LENGTH + IV_LENGTH + TAG_LENGTH);
  
  // Derive key from password and salt
  const key = crypto.pbkdf2Sync(shopifyConfig.encryptionKey, salt, 100000, 32, 'sha512');
  
  const decipher = crypto.createDecipheriv(ALGORITHM, key, iv);
  decipher.setAAD(salt);
  decipher.setAuthTag(tag);
  
  let decrypted = decipher.update(encrypted, undefined, 'utf8');
  decrypted += decipher.final('utf8');
  
  return decrypted;
}

/**
 * Generate HMAC for Shopify OAuth verification
 */
export function generateHmac(queryString: string, secret: string): string {
  return crypto
    .createHmac('sha256', secret)
    .update(queryString)
    .digest('hex');
}

/**
 * Verify HMAC for Shopify OAuth
 */
export function verifyHmac(queryString: string, secret: string, hmac: string): boolean {
  const expectedHmac = generateHmac(queryString, secret);
  return crypto.timingSafeEqual(Buffer.from(hmac, 'hex'), Buffer.from(expectedHmac, 'hex'));
}
</file>

<file path="src/infra/prisma.ts">
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma = globalForPrisma.prisma ?? new PrismaClient();

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;
</file>

<file path="src/interfaces/http/middleware/validation.ts">
import type { FastifyRequest, FastifyReply } from 'fastify';
import { ZodSchema } from 'zod';

/**
 * Generic validation middleware using Zod schemas
 */
export function validateBody<T>(schema: ZodSchema<T>) {
    return async (request: FastifyRequest, reply: FastifyReply) => {
        try {
            const validatedData = schema.parse(request.body);
            request.body = validatedData;
        } catch (error) {
            if (error instanceof Error) {
                return reply.status(400).send({
                    error: 'VALIDATION_ERROR',
                    message: error.message,
                });
            }
            return reply.status(400).send({
                error: 'VALIDATION_ERROR',
                message: 'Invalid request data',
            });
        }
    };
}
</file>

<file path="src/interfaces/http/project/jobs.ts">
import { FastifyInstance } from 'fastify';
import { VariantJobDAL } from '@infra/dal';
import { authMiddleware } from '../middleware/auth';
import { requireAuth, requireProjectOwnership } from '../middleware/authorization';

export async function jobRoutes(fastify: FastifyInstance) {
    // Get job status by ID
    fastify.get('/project/:projectId/jobs/:jobId', { 
        preHandler: [authMiddleware, requireAuth, requireProjectOwnership] 
    }, async (request, reply) => {
        try {
            const { projectId, jobId } = request.params as { projectId: string; jobId: string };

            // Get the job
            const job = await VariantJobDAL.getJobById(jobId);
            if (!job) {
                return reply.status(404).send({ 
                    error: 'Job not found',
                    message: `Job with ID ${jobId} not found`
                });
            }

            // Verify the job belongs to the project
            if (job.projectId !== projectId) {
                return reply.status(403).send({ 
                    error: 'Forbidden',
                    message: 'Job does not belong to this project'
                });
            }

            // Return job status
            return {
                jobId: job.id,
                status: job.status.toLowerCase(),
                result: job.result,
                error: job.error,
                progress: job.progress,
                createdAt: job.createdAt,
                startedAt: job.startedAt,
                completedAt: job.completedAt,
            };

        } catch (error) {
            fastify.log.error({ err: error, jobId: (request.params as any).jobId }, 'Get job status error:');
            return reply.status(500).send({ 
                error: 'Internal server error',
                message: 'Failed to get job status'
            });
        }
    });

    // Get all jobs for a project
    fastify.get('/project/:projectId/jobs', { 
        preHandler: [authMiddleware, requireAuth, requireProjectOwnership] 
    }, async (request, reply) => {
        try {
            const { projectId } = request.params as { projectId: string };
            const { limit = 50, offset = 0 } = request.query as { limit?: number; offset?: number };

            const jobs = await VariantJobDAL.getJobsByProject(projectId, limit, offset);

            return {
                jobs: jobs.map(job => ({
                    jobId: job.id,
                    status: job.status.toLowerCase(),
                    progress: job.progress,
                    createdAt: job.createdAt,
                    startedAt: job.startedAt,
                    completedAt: job.completedAt,
                })),
                total: jobs.length,
            };

        } catch (error) {
            fastify.log.error({ err: error, projectId: (request.params as any).projectId }, 'Get project jobs error:');
            return reply.status(500).send({ 
                error: 'Internal server error',
                message: 'Failed to get project jobs'
            });
        }
    });
}
</file>

<file path="src/interfaces/http/schemas/chat.schema.ts">
import { z } from 'zod';

/**
 * Schema for UIMessage parts
 */
const UIMessagePartSchema = z.object({
    type: z.literal('text'),
    text: z.string(),
});

/**
 * Schema for UIMessage
 */
const UIMessageSchema = z.object({
    id: z.string().optional(),
    role: z.enum(['user', 'assistant', 'system']),
    parts: z.array(UIMessagePartSchema).min(1, 'Message must have at least one part'),
});

/**
 * Schema for chat request body
 */
export const ChatRequestSchema = z.object({
    messages: z.array(UIMessageSchema).min(1, 'At least one message is required'),
});

export type ChatRequest = z.infer<typeof ChatRequestSchema>;
</file>

<file path="src/interfaces/http/user/schemas.ts">
import { z } from 'zod';

/**
 * Base user schema derived from Prisma User model
 * This ensures consistency between database and validation
 */
const BaseUserSchema = z.object({
  id: z.string().cuid(),
  auth0Id: z.string(),
  email: z.string().email(),
  firstName: z.string(),
  lastName: z.string(),
  createdAt: z.date(),
  updatedAt: z.date(),
});

/**
 * Schema for user registration request body
 * Only includes fields that can be provided during registration
 */
export const UserRegistrationSchema = z.object({
  email: z.string()
    .email('Invalid email format')
    .min(1, 'Email is required'),
  shop: z.string()
    .min(1, 'Shop domain is required')
    .regex(/^[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]*\.myshopify\.com$/, 'Invalid Shopify domain format'),
  password: z.string()
    .min(8, 'Password must be at least 8 characters')
    .optional(),
  firstName: z.string()
    .min(1, 'First name is required')
    .max(50, 'First name must be less than 50 characters')
    .optional()
    .default(''),
  lastName: z.string()
    .min(1, 'Last name is required')
    .max(50, 'Last name must be less than 50 characters')
    .optional()
    .default(''),
});

/**
 * Schema for user creation (internal use)
 * Used when creating users in the database
 */
export const UserCreateSchema = z.object({
  auth0Id: z.string(),
  email: z.string().email(),
  firstName: z.string(),
  lastName: z.string(),
});

// Export types
export type UserRegistrationRequest = z.infer<typeof UserRegistrationSchema>;
export type UserCreateRequest = z.infer<typeof UserCreateSchema>;
export type User = z.infer<typeof BaseUserSchema>;
</file>

<file path="src/interfaces/http/health.ts">
import type { FastifyInstance } from 'fastify/types/instance.js';
import type { FastifyRequest, FastifyReply } from 'fastify';
import { prisma } from '@infra/prisma';

export async function healthRoutes(fastify: FastifyInstance) {
    // Health check route (public)
    fastify.get('/healthz', async (_request: FastifyRequest, _reply: FastifyReply) => {
        return { ok: true };
    });

    // Database health check route (public)
    fastify.get('/healthz/db', async (_request: FastifyRequest, _reply: FastifyReply) => {
        try {
            await prisma.$queryRaw`SELECT 1`;
            return { ok: true, database: 'connected' };
        } catch (error) {
            fastify.log.error(error);
            return { ok: false, database: 'disconnected' };
        }
    });
}
</file>

<file path="src/services/screenshot-analytics.ts">
// Screenshot Analytics Service
import { PrismaClient } from '@prisma/client';

export interface ScreenshotAnalyticsService {
  getProjectScreenshotStats(projectId: string): Promise<{
    totalScreenshots: number;
    totalSize: number;
    cacheHitRate: number;
    screenshotsByType: Record<string, number>;
    averageSize: number;
    lastAccessed: Date | null;
  }>;
  
  getGlobalScreenshotStats(): Promise<{
    totalScreenshots: number;
    totalSize: number;
    totalProjects: number;
    averageScreenshotsPerProject: number;
    cacheHitRate: number;
  }>;
  
  getScreenshotUsageTrends(projectId: string, days: number): Promise<{
    date: string;
    screenshots: number;
    cacheHits: number;
    cacheMisses: number;
  }[]>;
  
  getTopCachedUrls(projectId: string, limit: number): Promise<{
    url: string;
    pageType: string;
    accessCount: number;
    lastAccessed: Date;
    fileSize: number;
  }[]>;
}

export class ScreenshotAnalyticsServiceImpl implements ScreenshotAnalyticsService {
  constructor(private prisma: PrismaClient) {}

  async getProjectScreenshotStats(projectId: string): Promise<{
    totalScreenshots: number;
    totalSize: number;
    cacheHitRate: number;
    screenshotsByType: Record<string, number>;
    averageSize: number;
    lastAccessed: Date | null;
  }> {
    try {
      const stats = await this.prisma.screenshot.aggregate({
        where: { projectId },
        _count: { id: true },
        _sum: { fileSize: true, accessCount: true },
        _max: { accessedAt: true }
      });

      const screenshotsByType = await this.prisma.screenshot.groupBy({
        by: ['pageType'],
        where: { projectId },
        _count: { id: true }
      });

      const totalScreenshots = stats._count.id || 0;
      const totalSize = stats._sum.fileSize || 0;
      const totalAccesses = stats._sum.accessCount || 0;

      return {
        totalScreenshots,
        totalSize,
        cacheHitRate: totalAccesses,
        screenshotsByType: screenshotsByType.reduce((acc, item) => {
          acc[item.pageType] = item._count.id;
          return acc;
        }, {} as Record<string, number>),
        averageSize: totalScreenshots > 0 ? totalSize / totalScreenshots : 0,
        lastAccessed: stats._max.accessedAt
      };
    } catch (error) {
      console.error('[SCREENSHOT_ANALYTICS] Error getting project stats:', error);
      return {
        totalScreenshots: 0,
        totalSize: 0,
        cacheHitRate: 0,
        screenshotsByType: {},
        averageSize: 0,
        lastAccessed: null
      };
    }
  }

  async getGlobalScreenshotStats(): Promise<{
    totalScreenshots: number;
    totalSize: number;
    totalProjects: number;
    averageScreenshotsPerProject: number;
    cacheHitRate: number;
  }> {
    try {
      const stats = await this.prisma.screenshot.aggregate({
        _count: { id: true },
        _sum: { fileSize: true, accessCount: true }
      });

      const projectCount = await this.prisma.screenshot.groupBy({
        by: ['projectId'],
        _count: { id: true }
      });

      const totalScreenshots = stats._count.id || 0;
      const totalSize = stats._sum.fileSize || 0;
      const totalProjects = projectCount.length;
      const totalAccesses = stats._sum.accessCount || 0;

      return {
        totalScreenshots,
        totalSize,
        totalProjects,
        averageScreenshotsPerProject: totalProjects > 0 ? totalScreenshots / totalProjects : 0,
        cacheHitRate: totalAccesses
      };
    } catch (error) {
      console.error('[SCREENSHOT_ANALYTICS] Error getting global stats:', error);
      return {
        totalScreenshots: 0,
        totalSize: 0,
        totalProjects: 0,
        averageScreenshotsPerProject: 0,
        cacheHitRate: 0
      };
    }
  }

  async getScreenshotUsageTrends(projectId: string, days: number): Promise<{
    date: string;
    screenshots: number;
    cacheHits: number;
    cacheMisses: number;
  }[]> {
    try {
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - days);

      const trends = await this.prisma.screenshot.groupBy({
        by: ['createdAt'],
        where: {
          projectId,
          createdAt: { gte: startDate }
        },
        _count: { id: true },
        _sum: { accessCount: true }
      });

      // Group by date and calculate trends
      const trendsByDate = new Map<string, { screenshots: number; cacheHits: number }>();
      
      for (const trend of trends) {
        const date = trend.createdAt.toISOString().split('T')[0];
        const existing = trendsByDate.get(date) || { screenshots: 0, cacheHits: 0 };
        trendsByDate.set(date, {
          screenshots: existing.screenshots + trend._count.id,
          cacheHits: existing.cacheHits + (trend._sum.accessCount || 0)
        });
      }

      // Fill in missing dates with zeros
      const result = [];
      for (let i = days - 1; i >= 0; i--) {
        const date = new Date();
        date.setDate(date.getDate() - i);
        const dateStr = date.toISOString().split('T')[0];
        const trend = trendsByDate.get(dateStr) || { screenshots: 0, cacheHits: 0 };
        
        result.push({
          date: dateStr,
          screenshots: trend.screenshots,
          cacheHits: trend.cacheHits,
          cacheMisses: Math.max(0, trend.screenshots - trend.cacheHits)
        });
      }

      return result;
    } catch (error) {
      console.error('[SCREENSHOT_ANALYTICS] Error getting usage trends:', error);
      return [];
    }
  }

  async getTopCachedUrls(projectId: string, limit: number): Promise<{
    url: string;
    pageType: string;
    accessCount: number;
    lastAccessed: Date;
    fileSize: number;
  }[]> {
    try {
      const topUrls = await this.prisma.screenshot.findMany({
        where: { projectId },
        orderBy: { accessCount: 'desc' },
        take: limit,
        select: {
          url: true,
          pageType: true,
          accessCount: true,
          accessedAt: true,
          fileSize: true
        }
      });

      return topUrls.map(item => ({
        url: item.url,
        pageType: item.pageType,
        accessCount: item.accessCount,
        lastAccessed: item.accessedAt,
        fileSize: item.fileSize
      }));
    } catch (error) {
      console.error('[SCREENSHOT_ANALYTICS] Error getting top cached URLs:', error);
      return [];
    }
  }
}

// Factory function
export function createScreenshotAnalyticsService(prisma: PrismaClient): ScreenshotAnalyticsService {
  return new ScreenshotAnalyticsServiceImpl(prisma);
}
</file>

<file path="src/shared/utils/html-simplifier.ts">
/**
 * HTML Simplification Utility
 * Reduces HTML size by removing unnecessary elements and normalizing content
 */

export function simplifyHTML(html: string): string {
  if (!html || html.length === 0) {
    return '';
  }

  // Process with single-pass operations to minimize memory usage
  return html
    // Remove comments (single pass)
    .replace(/<!--[\s\S]*?-->/g, '')
    // Remove script tags (single pass)
    .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '')
    // Remove style tags (single pass)
    .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '')
    // Remove tracking scripts (single pass)
    .replace(/<script[^>]*src="[^"]*(?:google-analytics|gtag|facebook|twitter|linkedin|pinterest)[^"]*"[^>]*>[\s\S]*?<\/script>/gi, '')
    // Remove meta tags (single pass)
    .replace(/<meta[^>]*(?:property|name)="(?:og:|twitter:|article:|product:)[^"]*"[^>]*>/gi, '')
    // Remove non-essential data attributes but keep important ones for element selection
    .replace(/\sdata-(?!(?:testid|omen-id|id|role|label|name|value|type|state|selected|checked|disabled|hidden|aria-))[^=]*="[^"]*"/gi, '')
    // Remove common non-essential attributes that don't help with element selection
    .replace(/\s(?:class|style|onclick|onload|onmouseover|onmouseout|onfocus|onblur|onchange|onsubmit)="[^"]*"/gi, '')
    // Normalize whitespace (single pass)
    .replace(/\s+/g, ' ')
    // Remove empty lines (single pass)
    .replace(/\n\s*\n/g, '\n')
    // Trim final result
    .trim();
}

export function splitIntoChunks(str: string, chunkSize: number): string[] {
  const chunks: string[] = [];
  for (let i = 0; i < str.length; i += chunkSize) {
    chunks.push(str.slice(i, i + chunkSize));
  }
  return chunks;
}

/**
 * HTML Simplification for DOM Forensics
 * Preserves all attributes needed for element selection while removing unnecessary content
 */
export function simplifyHTMLForForensics(html: string): string {
  if (!html || html.length === 0) {
    return '';
  }

  // Process with single-pass operations to minimize memory usage
  return html
    // Remove comments (single pass)
    .replace(/<!--[\s\S]*?-->/g, '')
    // Remove script tags (single pass)
    .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '')
    // Remove style tags (single pass)
    .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '')
    // Remove tracking scripts (single pass)
    .replace(/<script[^>]*src="[^"]*(?:google-analytics|gtag|facebook|twitter|linkedin|pinterest)[^"]*"[^>]*>[\s\S]*?<\/script>/gi, '')
    // Remove meta tags (single pass)
    .replace(/<meta[^>]*(?:property|name)="(?:og:|twitter:|article:|product:)[^"]*"[^>]*>/gi, '')
    // Remove only non-essential data attributes, keep all important ones for element selection
    .replace(/\sdata-(?!(?:testid|omen-id|id|role|label|name|value|type|state|selected|checked|disabled|hidden|aria-|cypress|qa|qa-id|test|automation|e2e))[^=]*="[^"]*"/gi, '')
    // Remove only style attributes (keep all other attributes for element selection)
    .replace(/\sstyle="[^"]*"/gi, '')
    // Remove event handlers (keep all other attributes)
    .replace(/\s(?:onclick|onload|onmouseover|onmouseout|onfocus|onblur|onchange|onsubmit|onkeydown|onkeyup|onkeypress)="[^"]*"/gi, '')
    // Normalize whitespace (single pass)
    .replace(/\s+/g, ' ')
    // Remove empty lines (single pass)
    .replace(/\n\s*\n/g, '\n')
    // Trim final result
    .trim();
}

export function getHtmlInfo(html: string | null | undefined): string {
  if (!html) return 'no HTML';
  const size = html.length;
  const preview = html.substring(0, 50).replace(/\s+/g, ' ').trim();
  return `${size} chars (${preview}${size > 50 ? '...' : ''})`;
}
</file>

<file path="src/shared/validation/sanitizers/css.sanitizer.ts">
/**
 * CSS Sanitizer
 * 
 * CSS validation and sanitization with regex-based approach
 * Lightweight and secure validation for experiment variants
 */

export interface CSSSanitizationResult {
  isValid: boolean;
  sanitizedCSS: string;
  errors: string[];
}

// Allowed CSS properties (subset for safety)
const ALLOWED_CSS_PROPERTIES = new Set([
  // Layout
  'display', 'position', 'top', 'right', 'bottom', 'left', 'z-index',
  'float', 'clear', 'overflow', 'overflow-x', 'overflow-y',
  'width', 'height', 'max-width', 'max-height', 'min-width', 'min-height',
  'margin', 'margin-top', 'margin-right', 'margin-bottom', 'margin-left',
  'padding', 'padding-top', 'padding-right', 'padding-bottom', 'padding-left',
  'border', 'border-width', 'border-style', 'border-color',
  'border-top', 'border-right', 'border-bottom', 'border-left',
  'border-radius', 'box-shadow', 'box-sizing',
  
  // Typography
  'font-family', 'font-size', 'font-weight', 'font-style', 'font-variant',
  'line-height', 'text-align', 'text-decoration', 'text-transform',
  'text-shadow', 'letter-spacing', 'word-spacing', 'white-space',
  'text-overflow', 'word-wrap', 'word-break',
  
  // Colors and backgrounds
  'color', 'background-color', 'background-image', 'background-position',
  'background-repeat', 'background-size', 'background-attachment',
  'opacity', 'visibility',
  
  // Flexbox
  'flex', 'flex-direction', 'flex-wrap', 'flex-flow', 'justify-content',
  'align-items', 'align-content', 'align-self', 'flex-grow', 'flex-shrink',
  'flex-basis', 'order',
  
  // Grid (basic)
  'grid', 'grid-template-columns', 'grid-template-rows', 'grid-template-areas',
  'grid-gap', 'grid-column-gap', 'grid-row-gap', 'justify-items', 'align-items',
  'grid-column', 'grid-row', 'grid-area',
  
  // Transitions and animations (basic)
  'transition', 'transition-property', 'transition-duration', 'transition-timing-function',
  'animation', 'animation-name', 'animation-duration', 'animation-timing-function',
  'animation-delay', 'animation-iteration-count', 'animation-direction',
  
  // Transform (basic)
  'transform', 'transform-origin',
  
  // Other safe properties
  'cursor', 'user-select', 'pointer-events', 'resize', 'outline', 'outline-width',
  'outline-style', 'outline-color', 'outline-offset'
]);

// Forbidden CSS properties
const FORBIDDEN_CSS_PROPERTIES = new Set([
  'behavior', 'expression', 'javascript:', 'vbscript:', 'mso-', '-moz-binding',
  'content', 'counter-reset', 'counter-increment', 'quotes'
]);

/**
 * Sanitizes CSS content for experiment variants
 */
export async function sanitizeCSS(css: string): Promise<CSSSanitizationResult> {
  const errors: string[] = [];

  try {
    // Check size limit first
    const sizeKB = Buffer.byteLength(css, 'utf8') / 1024;
    if (sizeKB > 10) {
      errors.push(`CSS content exceeds 10KB limit. Current size: ${sizeKB.toFixed(2)}KB`);
      return { isValid: false, sanitizedCSS: '', errors };
    }

    // Check for @import statements
    if (css.includes('@import')) {
      errors.push('@import statements are not allowed');
      return { isValid: false, sanitizedCSS: '', errors };
    }

    // Check for @font-face
    if (css.includes('@font-face')) {
      errors.push('@font-face is not allowed in MVP');
      return { isValid: false, sanitizedCSS: '', errors };
    }

    // Check for dangerous functions
    const dangerousFunctions = ['javascript:', 'vbscript:', 'expression(', 'url(javascript:', 'url(vbscript:'];
    for (const func of dangerousFunctions) {
      if (css.toLowerCase().includes(func.toLowerCase())) {
        errors.push(`Dangerous CSS function found: ${func}`);
        return { isValid: false, sanitizedCSS: '', errors };
      }
    }

    // Check for forbidden properties
    for (const prop of FORBIDDEN_CSS_PROPERTIES) {
      const regex = new RegExp(`\\b${prop.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\s*:`, 'gi');
      if (regex.test(css)) {
        errors.push(`Forbidden CSS property found: ${prop}`);
        return { isValid: false, sanitizedCSS: '', errors };
      }
    }

    // Validate that all selectors start with .omen-
    const selectorRegex = /([^{}]+)\s*{/g;
    let match;
    while ((match = selectorRegex.exec(css)) !== null) {
      const selector = match[1].trim();
      if (selector && !selector.includes('.omen-')) {
        errors.push(`CSS selector must include .omen- prefix: ${selector}`);
        return { isValid: false, sanitizedCSS: '', errors };
      }
    }

    // Basic property validation
    const propertyRegex = /([a-zA-Z-]+)\s*:/g;
    while ((match = propertyRegex.exec(css)) !== null) {
      const property = match[1].toLowerCase();
      if (!ALLOWED_CSS_PROPERTIES.has(property) && !property.startsWith('--')) {
        errors.push(`Unallowed CSS property: ${property}`);
        return { isValid: false, sanitizedCSS: '', errors };
      }
    }

    return {
      isValid: errors.length === 0,
      sanitizedCSS: css,
      errors: []
    };

  } catch (error) {
    errors.push(`CSS sanitization error: ${error instanceof Error ? error.message : 'Unknown error'}`);
    return { isValid: false, sanitizedCSS: '', errors };
  }
}

/**
 * Validates CSS content size
 */
export function validateCSSSize(css: string, maxSizeKB: number = 10): boolean {
  const sizeKB = Buffer.byteLength(css, 'utf8') / 1024;
  return sizeKB <= maxSizeKB;
}

/**
 * Gets CSS content size in KB
 */
export function getCSSSizeKB(css: string): number {
  return Buffer.byteLength(css, 'utf8') / 1024;
}

/**
 * Validates that all CSS selectors are properly namespaced with .omen-
 */
export async function validateCSSNamespace(css: string): Promise<boolean> {
  try {
    const selectorRegex = /([^{}]+)\s*{/g;
    let match;
    while ((match = selectorRegex.exec(css)) !== null) {
      const selector = match[1].trim();
      if (selector && !selector.includes('.omen-')) {
        return false; // Found non-namespaced selector
      }
    }
    return true;
  } catch {
    return false;
  }
}
</file>

<file path="src/shared/validation/sanitizers/html.sanitizer.ts">
/**
 * HTML Sanitizer using DOMPurify
 * 
 * Professional HTML sanitization with configurable rules
 */

import DOMPurify from 'dompurify';
import { JSDOM } from 'jsdom';

// Create a JSDOM instance for server-side DOMPurify
const window = new JSDOM('').window;
const purify = DOMPurify(window as any);

export interface HTMLSanitizationResult {
  isValid: boolean;
  sanitizedHTML: string;
  errors: string[];
}

// DOMPurify configuration for experiment variants
const SANITIZE_CONFIG = {
  ALLOWED_TAGS: [
    'div', 'span', 'p', 'strong', 'em', 'b', 'i', 'u', 'small',
    'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
    'ul', 'ol', 'li',
    'a', 'button', 'img',
    'br', 'hr',
    'section', 'article', 'header', 'footer', 'main', 'aside',
    'nav', 'figure', 'figcaption',
    'blockquote', 'cite', 'q',
    'code', 'pre', 'kbd', 'samp',
    'mark', 'del', 'ins', 'sub', 'sup',
    'time', 'address'
  ],
  ALLOWED_ATTR: [
    'class', 'id', 'style', 'title', 'lang', 'dir',
    'href', 'target', 'rel', 'type', 'role', 'aria-label', 'aria-labelledby',
    'src', 'alt', 'width', 'height', 'loading',
    'data-*' // Allow data attributes
  ],
  FORBID_ATTR: [
    'onload', 'onunload', 'onclick', 'ondblclick', 'onmousedown', 'onmouseup',
    'onmouseover', 'onmousemove', 'onmouseout', 'onfocus', 'onblur', 'onkeypress',
    'onkeydown', 'onkeyup', 'onsubmit', 'onreset', 'onselect', 'onchange',
    'onabort', 'onerror', 'onresize', 'onscroll', 'onbeforeunload', 'onunload',
    'srcdoc'
  ],
  FORBID_TAGS: [
    'script', 'iframe', 'object', 'embed', 'style', 'link', 'meta',
    'form', 'input', 'textarea', 'select', 'option',
    'canvas', 'svg', 'video', 'audio', 'source', 'track',
    'applet', 'base', 'frame', 'frameset', 'noframes'
  ],
  ALLOWED_URI_REGEXP: /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i,
  ALLOW_DATA_ATTR: true,
  SANITIZE_DOM: true,
  KEEP_CONTENT: true,
  RETURN_DOM: false,
  RETURN_DOM_FRAGMENT: false,
  RETURN_DOM_IMPORT: false
};

/**
 * Sanitizes HTML content for experiment variants
 */
export function sanitizeHTML(html: string): HTMLSanitizationResult {
  const errors: string[] = [];

  try {
    // Check size limit first
    const sizeKB = Buffer.byteLength(html, 'utf8') / 1024;
    if (sizeKB > 5) {
      errors.push(`HTML content exceeds 5KB limit. Current size: ${sizeKB.toFixed(2)}KB`);
      return { isValid: false, sanitizedHTML: '', errors };
    }

    // Sanitize with DOMPurify
    const sanitized = purify.sanitize(html, SANITIZE_CONFIG);

    // Check if anything was removed (indicates unsafe content)
    if (sanitized !== html) {
      // This is actually fine - DOMPurify removed unsafe content
      // We'll log it but not treat it as an error
      console.log('DOMPurify sanitized HTML content');
    }

    // Additional checks for specific dangerous patterns
    if (html.includes('javascript:') || html.includes('vbscript:') || html.includes('data:')) {
      errors.push('Dangerous protocols found in HTML content');
      return { isValid: false, sanitizedHTML: '', errors };
    }

    return {
      isValid: errors.length === 0,
      sanitizedHTML: sanitized,
      errors
    };

  } catch (error) {
    errors.push(`HTML sanitization error: ${error instanceof Error ? error.message : 'Unknown error'}`);
    return { isValid: false, sanitizedHTML: '', errors };
  }
}

/**
 * Validates HTML content size
 */
export function validateHTMLSize(html: string, maxSizeKB: number = 5): boolean {
  const sizeKB = Buffer.byteLength(html, 'utf8') / 1024;
  return sizeKB <= maxSizeKB;
}

/**
 * Gets HTML content size in KB
 */
export function getHTMLSizeKB(html: string): number {
  return Buffer.byteLength(html, 'utf8') / 1024;
}
</file>

<file path="src/shared/validation/schemas/experiment.schema.ts">
/**
 * Zod Schemas for Experiment DSL Validation
 * 
 * Type-safe schema validation using Zod
 */

import { z } from 'zod';

// Base types
export const ExperimentStatusSchema = z.enum(['draft', 'running', 'paused', 'finished']);
export const VariantIdSchema = z.enum(['A', 'B', 'C']);
export const RenderPositionSchema = z.enum(['inner', 'outer', 'before', 'after']);
export const ApplyModeSchema = z.enum(['first', 'all']);

// Match configuration
export const ExperimentMatchSchema = z.object({
  host: z.string().optional(),
  path: z.string().min(1, 'Path is required')
});

// Traffic distribution with tolerance validation
export const ExperimentTrafficSchema = z.object({
  A: z.number().min(0).max(1),
  B: z.number().min(0).max(1),
  C: z.number().min(0).max(1)
}).refine(
  (traffic) => {
    const sum = traffic.A + traffic.B + traffic.C;
    return Math.abs(sum - 1.0) <= 0.005; // 0.5% tolerance
  },
  {
    message: 'Traffic distribution must sum to 1.0 (0.5%)',
    path: ['traffic']
  }
);

// Assignment configuration
export const ExperimentAssignmentSchema = z.object({
  cookieName: z.string()
    .min(1, 'Cookie name is required')
    .max(50, 'Cookie name must be 50 characters or less')
    .regex(/^[a-zA-Z0-9_-]+$/, 'Cookie name must contain only alphanumeric characters, hyphens, and underscores'),
  ttlDays: z.number().positive('TTL must be positive')
});

// Runtime configuration
export const ExperimentRuntimeSchema = z.object({
  minDays: z.number().positive('Minimum days must be positive'),
  minSessionsPerVariant: z.number().positive('Minimum sessions per variant must be positive'),
  endAt: z.string().datetime().optional()
});

// Analytics configuration
export const ExperimentAnalyticsSchema = z.object({
  posthog: z.object({
    enabled: z.boolean(),
    host: z.enum(['app.posthog.com', 'eu.posthog.com', 'us.posthog.com'], {
      message: 'Invalid PostHog host'
    })
  }),
  eventProps: z.array(z.string()).min(1, 'At least one event property is required')
});

// KPI configuration
export const ExperimentKPISchema = z.object({
  primary: z.string().min(1, 'Primary KPI is required'),
  secondary: z.array(z.string()).optional()
});

// Guardrails configuration
export const ExperimentGuardrailsSchema = z.object({
  watch: z.array(z.enum(['lcp', 'js_errors', 'cls'])).optional()
});

// Variant render configuration
export const VariantRenderSchema = z.object({
  position: RenderPositionSchema,
  html: z.string()
    .min(1, 'HTML content is required')
    .max(5 * 1024, 'HTML content exceeds 5KB limit'), // 5KB limit
  css: z.string()
    .max(10 * 1024, 'CSS content exceeds 10KB limit') // 10KB limit
    .optional(),
  oncePerResponse: z.boolean().optional().default(true)
});

// Variant configuration
export const VariantSchema = z.object({
  mode: z.literal('render'),
  render: VariantRenderSchema
});

// Target configuration
export const ExperimentTargetSchema = z.object({
  selector: z.string()
    .min(1, 'Selector is required')
    .refine(
      (selector) => !selector.includes('{') && !selector.includes('}') && !selector.includes(';'),
      'Invalid CSS selector syntax'
    ),
  apply: ApplyModeSchema.default('first'),
  variants: z.record(VariantIdSchema, VariantSchema)
    .refine(
      (variants) => Object.keys(variants).length >= 1,
      'At least one variant is required'
    )
    .refine(
      (variants) => Object.keys(variants).length <= 3,
      'Maximum 3 variants allowed'
    )
});

// Main experiment schema
export const ExperimentDSLSchema = z.object({
  experimentId: z.string().min(1, 'Experiment ID is required'),
  projectId: z.string().min(1, 'Project ID is required'),
  name: z.string().min(1, 'Name is required'),
  status: ExperimentStatusSchema,
  match: ExperimentMatchSchema,
  traffic: ExperimentTrafficSchema,
  assignment: ExperimentAssignmentSchema,
  targets: z.array(ExperimentTargetSchema)
    .min(1, 'At least one target is required')
    .max(3, 'Maximum 3 targets allowed'),
  kpi: ExperimentKPISchema,
  runtime: ExperimentRuntimeSchema,
  analytics: ExperimentAnalyticsSchema,
  guardrails: ExperimentGuardrailsSchema.optional()
}).refine(
  (experiment) => {
    // Check total DSL size (100KB limit)
    const dslString = JSON.stringify(experiment);
    const sizeKB = Buffer.byteLength(dslString, 'utf8') / 1024;
    return sizeKB <= 100;
  },
  {
    message: 'DSL exceeds 100KB limit',
    path: ['dsl']
  }
).refine(
  (experiment) => {
    // Check total CSS size across all variants (10KB limit)
    let totalCSSSize = 0;
    for (const target of experiment.targets) {
      for (const variant of Object.values(target.variants)) {
        if (variant.render.css) {
          totalCSSSize += Buffer.byteLength(variant.render.css, 'utf8');
        }
      }
    }
    return totalCSSSize <= 10 * 1024; // 10KB
  },
  {
    message: 'Total CSS size exceeds 10KB limit',
    path: ['css']
  }
);

// Type inference
export type ExperimentDSL = z.infer<typeof ExperimentDSLSchema>;
export type ExperimentMatch = z.infer<typeof ExperimentMatchSchema>;
export type ExperimentTraffic = z.infer<typeof ExperimentTrafficSchema>;
export type ExperimentAssignment = z.infer<typeof ExperimentAssignmentSchema>;
export type ExperimentRuntime = z.infer<typeof ExperimentRuntimeSchema>;
export type ExperimentAnalytics = z.infer<typeof ExperimentAnalyticsSchema>;
export type ExperimentKPI = z.infer<typeof ExperimentKPISchema>;
export type ExperimentGuardrails = z.infer<typeof ExperimentGuardrailsSchema>;
export type VariantRender = z.infer<typeof VariantRenderSchema>;
export type Variant = z.infer<typeof VariantSchema>;
export type ExperimentTarget = z.infer<typeof ExperimentTargetSchema>;
</file>

<file path="src/shared/validation/index.ts">
/**
 * Validation Module Exports
 * 
 * Centralized exports for all validation utilities
 */

export * from './validator.js';
export * from './schemas/experiment.schema.js';
export * from './sanitizers/html.sanitizer.js';
export * from './sanitizers/css.sanitizer.js';
</file>

<file path="src/shared/validation/validator.ts">
/**
 * Main DSL Validator
 * 
 * Orchestrates validation using Zod schemas and sanitizers
 */

import { ExperimentDSLSchema, type ExperimentDSL } from './schemas/experiment.schema.js';
import { sanitizeHTML } from './sanitizers/html.sanitizer.js';
import { sanitizeCSS } from './sanitizers/css.sanitizer.js';

export interface ValidationResult {
  isValid: boolean;
  errors: ValidationError[];
}

export interface ValidationError {
  code: string;
  message: string;
  field?: string;
  details?: unknown;
}

// Unsafe selectors for outer position
const UNSAFE_OUTER_SELECTORS = [
  'form', 'input', 'textarea', 'select', 'button[type="submit"]',
  '[id*="checkout"]', '[id*="payment"]', '[id*="billing"]',
  '[id*="shipping"]', '[id*="address"]', '[id*="credit"]',
  '[id*="card"]', '[id*="cvv"]', '[id*="cvc"]'
];

/**
 * Validates an experiment DSL
 */
export async function validateExperimentDSL(dsl: unknown): Promise<ValidationResult> {
  const errors: ValidationError[] = [];

  try {
    // 1. Schema validation with Zod
    const schemaResult = ExperimentDSLSchema.safeParse(dsl);
    if (!schemaResult.success) {
      const zodErrors = schemaResult.error.issues.map((err) => ({
        code: 'INVALID_DSL_STRUCTURE',
        message: err.message,
        field: err.path.join('.'),
        details: err
      }));
      return { isValid: false, errors: zodErrors };
    }

    const experiment = schemaResult.data;

    // 2. Additional safety checks
    await validateSafetyRules(experiment, errors);
    if (errors.length > 0) return { isValid: false, errors };

    // 3. HTML sanitization
    await validateHTMLContent(experiment, errors);
    if (errors.length > 0) return { isValid: false, errors };

    // 4. CSS sanitization
    await validateCSSContent(experiment, errors);
    if (errors.length > 0) return { isValid: false, errors };

  } catch (error) {
    errors.push({
      code: 'VALIDATION_ERROR',
      message: `Validation error: ${error instanceof Error ? error.message : 'Unknown error'}`,
      details: error
    });
  }

  return {
    isValid: errors.length === 0,
    errors
  };
}

/**
 * Validates safety rules
 */
async function validateSafetyRules(experiment: ExperimentDSL, errors: ValidationError[]): Promise<void> {
  for (const target of experiment.targets) {
    for (const [variantId, variant] of Object.entries(target.variants)) {
      // Check for unsafe outer targets
      if (variant.render.position === 'outer' && isUnsafeOuterTarget(target.selector)) {
        errors.push({
          code: 'UNSAFE_OUTER_TARGET',
          message: `Outer position not allowed for critical elements: ${target.selector}`,
          field: `targets.${experiment.targets.indexOf(target)}.variants.${variantId}.render.position`
        });
      }
    }
  }
}

/**
 * Validates HTML content
 */
async function validateHTMLContent(experiment: ExperimentDSL, errors: ValidationError[]): Promise<void> {
  for (const target of experiment.targets) {
    for (const [variantId, variant] of Object.entries(target.variants)) {
      const htmlResult = sanitizeHTML(variant.render.html);
      if (!htmlResult.isValid) {
        errors.push({
          code: 'UNSAFE_HTML',
          message: `Unsafe HTML content: ${htmlResult.errors.join(', ')}`,
          field: `targets.${experiment.targets.indexOf(target)}.variants.${variantId}.render.html`,
          details: htmlResult.errors
        });
      }
    }
  }
}

/**
 * Validates CSS content
 */
async function validateCSSContent(experiment: ExperimentDSL, errors: ValidationError[]): Promise<void> {
  for (const target of experiment.targets) {
    for (const [variantId, variant] of Object.entries(target.variants)) {
      if (variant.render.css) {
        const cssResult = await sanitizeCSS(variant.render.css);
        if (!cssResult.isValid) {
          errors.push({
            code: 'UNSCOPED_CSS',
            message: `Unsafe CSS content: ${cssResult.errors.join(', ')}`,
            field: `targets.${experiment.targets.indexOf(target)}.variants.${variantId}.render.css`,
            details: cssResult.errors
          });
        }
      }
    }
  }
}

/**
 * Checks if a selector targets unsafe elements for outer position
 */
function isUnsafeOuterTarget(selector: string): boolean {
  const lowerSelector = selector.toLowerCase();
  return UNSAFE_OUTER_SELECTORS.some(unsafe => 
    lowerSelector.includes(unsafe) || 
    lowerSelector.match(new RegExp(unsafe.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')))
  );
}
</file>

<file path=".dockerignore">
node_modules
npm-debug.log
.git
.gitignore
README.md
.env
.nyc_output
coverage
.nyc_output
.coverage
dist
.eslintrc.*
eslint.config.js
</file>

<file path=".env.prod">
# Database Configuration
POSTGRES_DB=omen_db
POSTGRES_USER=omen_user
POSTGRES_PASSWORD=omen_password

# Database URL for the application
DATABASE_URL=postgresql://omen_user:omen_password@postgres:5432/omen_db

# Application Configuration
NODE_ENV=development
PORT=3000
</file>

<file path=".gitignore">
node_modules/
dist/
*.log
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

/src/generated/prisma
</file>

<file path="docker-compose.prod.yml">
services:
  api:
    build:
      context: .
      dockerfile: Dockerfile.prod
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=${DATABASE_URL}
    depends_on:
      postgres:
        condition: service_healthy
    restart: unless-stopped
    command: sh -c "npx prisma migrate deploy && npm start"

  postgres:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

volumes:
  postgres_data:
</file>

<file path="Dockerfile.prod">
# Production Dockerfile
FROM node:20-alpine

# Set working directory
WORKDIR /app

# Copy package files
COPY package*.json ./

# Install all dependencies (including dev dependencies for build)
RUN npm ci

# Copy source code
COPY src/ ./src/
COPY tsconfig.json ./
COPY prisma/ ./prisma/

# Generate Prisma client and build TypeScript
RUN npm run db:generate
RUN npm run build

# Remove dev dependencies after build
RUN npm prune --production

# Expose port
EXPOSE 3000

# Start the application
CMD ["npm", "start"]
</file>

<file path="src/domain/agent/tools/get-brand-analysis.ts">
// @ts-nocheck 
// Brand Analysis Tool
import { tool } from 'ai';
import { ProjectDAL } from '@infra/dal/project';
import type { BrandAnalysisResponse } from '@features/brand_analysis/types';
import { getBrandAnalysisSchema } from './schemas';

class GetBrandAnalysisExecutor {
  private projectId: string;

  constructor(projectId: string) {
    this.projectId = projectId;
  }

  async execute(input: { projectId?: string }) {
    try {
      console.log(`[BRAND_ANALYSIS] Using project ID: ${this.projectId}`);
      
      // Get brand analysis from database
      const brandAnalysisJson = await ProjectDAL.getProjectBrandAnalysis(this.projectId);

      console.log(`[BRAND_ANALYSIS] Brand analysis JSON: ${brandAnalysisJson}`);
      
      if (!brandAnalysisJson) {
        return {
          success: false,
          error: 'No brand analysis found for this project. Please run a brand analysis first.',
          data: null
        };
      }

      // Parse the JSON data and return it directly for the LLM to interpret
      const brandAnalysis: BrandAnalysisResponse = JSON.parse(brandAnalysisJson);
      
      return {
        success: true,
        data: brandAnalysis,
        summary: `Brand analysis retrieved successfully. Contains detailed visual style analysis, brand elements, personality insights, and language/messaging analysis.`
      };
    } catch (error) {
      console.error('Error getting brand analysis:', error);
      return {
        success: false,
        error: `Failed to retrieve brand analysis: ${error instanceof Error ? error.message : 'Unknown error'}`,
        data: null
      };
    }
  }
}

export function createGetBrandAnalysisTool(projectId: string) {
  const executor = new GetBrandAnalysisExecutor(projectId);

  return tool({
    description: 'Get the brand analysis data for a project. This includes visual style, brand elements, language analysis, and messaging insights.',
    inputSchema: getBrandAnalysisSchema,
    execute: async (input) => {
      try {
        return await executor.execute(input);
      } catch (error) {
        throw new Error(error instanceof Error ? error.message : 'Failed to fetch brand analysis');
      }
    },
  });
}
</file>

<file path="src/domain/agent/hypothesis-state-manager.ts">
// Hypothesis State Manager - manages hypothesis state across tool calls
import { Hypothesis } from '@features/hypotheses_generation/types';

class HypothesisStateManager {
  private currentHypothesis: Hypothesis | null = null;
  private hypothesisHistory: Hypothesis[] = [];

  /**
   * Set the current hypothesis (from generate_hypotheses tool)
   */
  setCurrentHypothesis(hypothesis: Hypothesis): void {
    console.log(`[STATE_MANAGER] Setting hypothesis: "${hypothesis.hypothesis.substring(0, 50)}..."`);
    this.currentHypothesis = hypothesis;
    this.hypothesisHistory.push(hypothesis);
    console.log(`[STATE_MANAGER] Hypothesis set: "${hypothesis.hypothesis.substring(0, 50)}..."`);
    console.log(`[STATE_MANAGER] Current hypothesis count: ${this.hypothesisHistory.length}`);
  }

  /**
   * Get the current hypothesis (for generate_variants and create_experiment tools)
   */
  getCurrentHypothesis(): Hypothesis | null {
    console.log(`[STATE_MANAGER] Getting current hypothesis: ${this.currentHypothesis ? 'FOUND' : 'NOT FOUND'}`);
    return this.currentHypothesis;
  }

  /**
   * Get the most recent hypothesis from history
   */
  getLatestHypothesis(): Hypothesis | null {
    return this.hypothesisHistory.length > 0 
      ? this.hypothesisHistory[this.hypothesisHistory.length - 1] 
      : null;
  }

  /**
   * Clear the current hypothesis
   */
  clearCurrentHypothesis(): void {
    console.log(`[STATE_MANAGER] Clearing current hypothesis`);
    this.currentHypothesis = null;
  }

  /**
   * Clear all hypothesis history
   */
  clearAll(): void {
    console.log(`[STATE_MANAGER] Clearing all hypothesis data`);
    this.currentHypothesis = null;
    this.hypothesisHistory = [];
  }

  /**
   * Get hypothesis history
   */
  getHistory(): Hypothesis[] {
    return [...this.hypothesisHistory];
  }

  /**
   * Check if there's a current hypothesis
   */
  hasCurrentHypothesis(): boolean {
    return this.currentHypothesis !== null;
  }
}

// Singleton instance
export const hypothesisStateManager = new HypothesisStateManager();

// Export the class for testing
export { HypothesisStateManager };
</file>

<file path="src/domain/agent/variant-state-manager.ts">
// Variant State Manager - manages variant state across tool calls
import { Variant } from '@features/variant_generation/types';
import { VariantJobDAL } from '@infra/dal';

class VariantStateManager {
  private currentVariants: Variant[] | null = null;
  private variantHistory: Variant[][] = [];
  private currentJobIds: string[] | null = null;

  /**
   * Set the current variants (from generate_variants tool)
   */
  setCurrentVariants(variants: Variant[]): void {
    console.log(`[STATE_MANAGER] ===== SETTING VARIANTS =====`);
    console.log(`[STATE_MANAGER] Input variants type:`, typeof variants);
    console.log(`[STATE_MANAGER] Input variants length:`, variants ? variants.length : 'null/undefined');
    console.log(`[STATE_MANAGER] Input variants:`, JSON.stringify(variants.map(v => ({ 
      label: v.variant_label, 
      description: v.description.substring(0, 50) + '...' 
    })), null, 2));
    this.currentVariants = variants;
    this.variantHistory.push(variants);
    console.log(`[STATE_MANAGER] Variants set: ${variants.length} variants`);
    console.log(`[STATE_MANAGER] Current variant set count: ${this.variantHistory.length}`);
    console.log(`[STATE_MANAGER] ================================`);
  }

  /**
   * Set the current job IDs (from generate_variants tool)
   */
  setCurrentJobIds(jobIds: string[]): void {
    console.log(`[STATE_MANAGER] ===== SETTING JOB IDS =====`);
    console.log(`[STATE_MANAGER] Job IDs:`, jobIds);
    this.currentJobIds = jobIds;
    console.log(`[STATE_MANAGER] ==========================`);
  }

  /**
   * Get the current job IDs
   */
  getCurrentJobIds(): string[] | null {
    console.log(`[STATE_MANAGER] ===== GETTING JOB IDS =====`);
    console.log(`[STATE_MANAGER] Current job IDs:`, this.currentJobIds);
    console.log(`[STATE_MANAGER] ===========================`);
    return this.currentJobIds;
  }

  /**
   * Get the current variants (for create_experiment tool)
   */
  getCurrentVariants(): Variant[] | null {
    console.log(`[STATE_MANAGER] ===== GETTING VARIANTS =====`);
    console.log(`[STATE_MANAGER] Current variants: ${this.currentVariants ? `${this.currentVariants.length} variants FOUND` : 'NOT FOUND'}`);
    if (this.currentVariants) {
      console.log(`[STATE_MANAGER] Variant labels:`, this.currentVariants.map(v => v.variant_label));
    }
    console.log(`[STATE_MANAGER] ==============================`);
    return this.currentVariants;
  }

  /**
   * Get the most recent variants from history
   */
  getLatestVariants(): Variant[] | null {
    return this.variantHistory.length > 0 
      ? this.variantHistory[this.variantHistory.length - 1] 
      : null;
  }

  /**
   * Clear the current variants
   */
  clearCurrentVariants(): void {
    console.log(`[STATE_MANAGER] Clearing current variants`);
    this.currentVariants = null;
  }

  /**
   * Clear the current job IDs
   */
  clearCurrentJobIds(): void {
    console.log(`[STATE_MANAGER] Clearing current job IDs`);
    this.currentJobIds = null;
  }

  /**
   * Clear all variant history
   */
  clearAll(): void {
    console.log(`[STATE_MANAGER] Clearing all variant data`);
    this.currentVariants = null;
    this.variantHistory = [];
    this.currentJobIds = null;
  }

  /**
   * Get variant history
   */
  getHistory(): Variant[][] {
    return [...this.variantHistory];
  }

  /**
   * Check if there are current variants
   */
  hasCurrentVariants(): boolean {
    return this.currentVariants !== null && this.currentVariants.length > 0;
  }

  /**
   * Get the number of current variants
   */
  getCurrentVariantCount(): number {
    return this.currentVariants ? this.currentVariants.length : 0;
  }

  /**
   * Retrieve completed variants from specific job IDs and populate state manager
   */
  async loadVariantsFromJobIds(jobIds: string[]): Promise<Variant[]> {
    console.log(`[STATE_MANAGER] ===== LOADING VARIANTS FROM SPECIFIC JOBS =====`);
    console.log(`[STATE_MANAGER] Job IDs:`, jobIds);
    
    try {
      const variants: Variant[] = [];
      const completedJobIds: string[] = [];
      
      for (const jobId of jobIds) {
        try {
          const job = await VariantJobDAL.getJobById(jobId);
          if (!job) {
            console.log(`[STATE_MANAGER] Job ${jobId} not found`);
            continue;
          }
          
          if (job.status === 'COMPLETED' && job.result) {
            if (job.result.variantsSchema && job.result.variantsSchema.variants) {
              const jobVariants = job.result.variantsSchema.variants;
              console.log(`[STATE_MANAGER] Job ${jobId} has ${jobVariants.length} variants`);
              variants.push(...jobVariants);
              completedJobIds.push(jobId);
            } else {
              console.log(`[STATE_MANAGER] Job ${jobId} completed but has no variants in result`);
            }
          } else {
            console.log(`[STATE_MANAGER] Job ${jobId} status: ${job.status}, has result: ${!!job.result}`);
          }
        } catch (error) {
          console.error(`[STATE_MANAGER] Error loading job ${jobId}:`, error);
        }
      }

      console.log(`[STATE_MANAGER] Extracted ${variants.length} variants from ${completedJobIds.length}/${jobIds.length} completed jobs`);
      
      if (variants.length > 0) {
        // Set the variants in the state manager
        this.setCurrentVariants(variants);
        console.log(`[STATE_MANAGER] Successfully loaded ${variants.length} variants into state manager`);
      }

      console.log(`[STATE_MANAGER] ================================================`);
      return variants;
    } catch (error) {
      console.error(`[STATE_MANAGER] Failed to load variants from job IDs:`, error);
      return [];
    }
  }

  /**
   * Retrieve completed variants from jobs for a project and populate state manager
   * @deprecated Use loadVariantsFromJobIds for more precise control
   */
  async loadVariantsFromJobs(projectId: string): Promise<Variant[]> {
    console.log(`[STATE_MANAGER] ===== LOADING VARIANTS FROM ALL PROJECT JOBS =====`);
    console.log(`[STATE_MANAGER] Project ID: ${projectId}`);
    
    try {
      // Get all completed jobs for this project
      const jobs = await VariantJobDAL.getJobsByProject(projectId);
      const completedJobs = jobs.filter(job => job.status === 'COMPLETED' && job.result);
      
      console.log(`[STATE_MANAGER] Found ${jobs.length} total jobs, ${completedJobs.length} completed`);
      
      if (completedJobs.length === 0) {
        console.log(`[STATE_MANAGER] No completed variant jobs found`);
        return [];
      }

      // Extract variants from completed jobs
      const variants: Variant[] = [];
      for (const job of completedJobs) {
        try {
          if (job.result && job.result.variantsSchema && job.result.variantsSchema.variants) {
            const jobVariants = job.result.variantsSchema.variants;
            console.log(`[STATE_MANAGER] Job ${job.id} has ${jobVariants.length} variants`);
            variants.push(...jobVariants);
          }
        } catch (error) {
          console.error(`[STATE_MANAGER] Error extracting variants from job ${job.id}:`, error);
        }
      }

      console.log(`[STATE_MANAGER] Extracted ${variants.length} total variants from jobs`);
      
      if (variants.length > 0) {
        // Set the variants in the state manager
        this.setCurrentVariants(variants);
        console.log(`[STATE_MANAGER] Successfully loaded ${variants.length} variants into state manager`);
      }

      console.log(`[STATE_MANAGER] ==========================================`);
      return variants;
    } catch (error) {
      console.error(`[STATE_MANAGER] Failed to load variants from jobs:`, error);
      return [];
    }
  }

  /**
   * Check if there are completed variant jobs for a project
   */
  async hasCompletedJobs(projectId: string): Promise<boolean> {
    try {
      const jobs = await VariantJobDAL.getJobsByProject(projectId);
      return jobs.some(job => job.status === 'COMPLETED' && job.result);
    } catch (error) {
      console.error(`[STATE_MANAGER] Error checking completed jobs:`, error);
      return false;
    }
  }
}

// Singleton instance
export const variantStateManager = new VariantStateManager();

// Export the class for testing
export { VariantStateManager };
</file>

<file path="src/domain/analytics/index.ts">
// Brand analysis moved to features/brand_analysis
// Diagnostics service removed
</file>

<file path="src/features/brand_analysis/types.ts">
// Brand Analysis Types
export interface BrandAnalysisRequest {
  pages: {
    html: string[];
    screenshot: string[];
    urls: string[];
  };
  shopDomain: string;
}
export interface BrandAnalysisResponse {
  screenshot: {
    visualStyle: {
      overallAesthetic: string;
      colorPalette: string[];
      typography: string;
      imagery: string;
    };
    brandElements: {
      logo: string;
      keyComponents: string[];
      layout: string;
    };
    brandPersonality: {
      adjectives: string[];
      targetAudience: string;
    };
  };
  language: {
    voice: {
      tones: string[];
      keyPhrases: string[];
    };
    brandPersonality: {
      adjectives: string[];
      values: string[];
      targetAudience: string;
    };
    valueProposition: {
      primaryMessage: string;
      supportingBenefits: string[];
      differentiators: string[];
      proofElements: string[];
    };
    messaging: {
      headlines: string[];
      ctas: string[];
      contentThemes: string[];
      trustSignals: string[];
    };
  };
  // code: {
  //   websiteStructure: {
  //     informationArchitecture: string;
  //     contentDepth: string;
  //     navigationPattern: string;
  //   };
  //   designTokens: {
  //     colors: string[];
  //     fonts: string[];
  //     margins: string[];
  //   };
  // };
}

export interface BrandAnalysisResult {
  success: boolean;
  brandSummary?: BrandAnalysisResponse;
  pages?: Array<{
    url: string;
    screenshotUrl: string;
    title?: string;
    description?: string;
  }>;
  error?: string;
}
</file>

<file path="src/features/variant_generation/types.ts">
// Types for variant generation
import { z } from 'zod';

// Basic variant schema for initial generation (without code)
export const basicVariantSchema = z.object({
    variant_label: z.string(),
    description: z.string(),
    rationale: z.string(),
    accessibility_consideration: z.string(),
    implementation_notes: z.string()
});

// Full variant schema with code generation
export const variantSchema = z.object({
    variant_label: z.string(),
    description: z.string(),
    rationale: z.string(),
    accessibility_consideration: z.string(),
    implementation_notes: z.string(),
    css_code: z.string().describe('CSS code to implement this variant'),
    html_code: z.string().describe('HTML code changes for this variant'),
    injection_method: z.enum(['selector', 'new_element', 'modify_existing']).describe('How to inject this code'),
    target_selector: z.string().optional().describe('CSS selector to target existing element'),
    new_element_html: z.string().optional().describe('Complete HTML for new element'),
    implementation_instructions: z.string().describe('Step-by-step implementation instructions'),
    screenshot: z.string().optional().describe('URL to the screenshot of the variant applied to the page')
});

export const basicVariantsResponseSchema = z.object({
    variants: basicVariantSchema.array()
});

export const variantsResponseSchema = z.object({
    variants: variantSchema.array()
});

export type BasicVariant = z.infer<typeof basicVariantSchema>;
export type Variant = z.infer<typeof variantSchema>;
export type VariantsResponse = z.infer<typeof variantsResponseSchema>;
</file>

<file path="src/infra/dal/chat-message.ts">
// Chat Message Data Access Layer
import { ChatMessage, MessageRole, Prisma } from '@prisma/client';
import { prisma } from '../prisma';

export interface CreateChatMessageData {
    projectId: string;
    role: MessageRole;
    content: {
        text?: string;
        metadata?: Record<string, unknown>;
        toolCalls?: Array<{
            id: string;
            type: string;
            function: {
                name: string;
                arguments: string;
            };
        }>;
        toolCallId?: string;
    };
}

export interface UpdateChatMessageData {
    content?: {
        text?: string;
        metadata?: Record<string, unknown>;
        toolCalls?: Array<{
            id: string;
            type: string;
            function: {
                name: string;
                arguments: string;
            };
        }>;
        toolCallId?: string;
    };
}

export class ChatMessageDAL {
    static async createMessage(data: CreateChatMessageData): Promise<ChatMessage> {
        // Clean up content object to remove undefined values
        const cleanContent: Record<string, unknown> = {};
        
        if (data.content.text !== undefined) {
            cleanContent.text = data.content.text;
        }
        
        if (data.content.metadata !== undefined) {
            cleanContent.metadata = data.content.metadata;
        }
        
        if (data.content.toolCalls !== undefined && data.content.toolCalls.length > 0) {
            cleanContent.toolCalls = data.content.toolCalls;
        }
        
        if (data.content.toolCallId !== undefined) {
            cleanContent.toolCallId = data.content.toolCallId;
        }
        
        return await prisma.chatMessage.create({
            data: {
                projectId: data.projectId,
                role: data.role,
                content: cleanContent as Prisma.InputJsonValue,
            },
        });
    }

    static async getMessagesByProject(
        projectId: string,
        limit?: number,
        offset?: number
    ): Promise<ChatMessage[]> {
        return await prisma.chatMessage.findMany({
            where: { projectId },
            orderBy: { createdAt: 'asc' },
            ...(limit && { take: limit }),
            ...(offset && { skip: offset }),
        });
    }

    static async updateMessage(
        messageId: string,
        data: UpdateChatMessageData
    ): Promise<ChatMessage> {
        return await prisma.chatMessage.update({
            where: { id: messageId },
            data: {
                ...(data.content && { content: data.content as Prisma.InputJsonValue }),
            },
        });
    }

    static async deleteMessage(messageId: string): Promise<void> {
        await prisma.chatMessage.delete({
            where: { id: messageId },
        });
    }

    static async getMessageById(messageId: string): Promise<ChatMessage | null> {
        return await prisma.chatMessage.findUnique({
            where: { id: messageId },
        });
    }

    static async getLatestMessagesByProject(
        projectId: string,
        count: number = 10
    ): Promise<ChatMessage[]> {
        return await prisma.chatMessage.findMany({
            where: { projectId },
            orderBy: { createdAt: 'desc' },
            take: count,
        });
    }

    static async countMessagesByProject(projectId: string): Promise<number> {
        return await prisma.chatMessage.count({
            where: { projectId },
        });
    }
}
</file>

<file path="src/infra/dal/experiment.ts">
// Experiment Data Access Layer
import { prisma } from '@infra/prisma';
import type { Experiment, ExperimentWithProject, CreateExperimentData, UpdateExperimentStatusData } from './types';

export class ExperimentDAL {
  /**
   * Create a new experiment
   */
  static async createExperiment(data: CreateExperimentData): Promise<Experiment> {
    return await prisma.experiment.create({
      data,
    });
  }

  /**
   * Get experiment by ID
   */
  static async getExperimentById(experimentId: string): Promise<Experiment | null> {
    return await prisma.experiment.findUnique({
      where: { id: experimentId },
    });
  }

  /**
   * Get experiment with project details
   */
  static async getExperimentWithProject(experimentId: string): Promise<ExperimentWithProject | null> {
    return await prisma.experiment.findUnique({
      where: { id: experimentId },
      include: {
        project: true,
      },
    });
  }

  /**
   * Get all experiments for a project
   */
  static async getExperimentsByProject(projectId: string): Promise<Experiment[]> {
    return await prisma.experiment.findMany({
      where: { projectId },
      orderBy: { createdAt: 'desc' },
    });
  }

  /**
   * Get experiments by project and status
   */
  static async getExperimentsByProjectAndStatus(
    projectId: string,
    status: string
  ): Promise<Experiment[]> {
    return await prisma.experiment.findMany({
      where: {
        projectId,
        status: status as any, // Type assertion for enum
      },
      orderBy: { createdAt: 'desc' },
    });
  }

  /**
   * Update experiment status and related timestamps
   */
  static async updateStatus(data: UpdateExperimentStatusData): Promise<Experiment> {
    const updateData: any = {
      status: data.status,
    };

    // Set publishedAt when transitioning to RUNNING
    if (data.status === 'RUNNING' && data.publishedAt) {
      updateData.publishedAt = data.publishedAt;
    }

    // Set finishedAt when transitioning to COMPLETED
    if (data.status === 'COMPLETED' && data.finishedAt) {
      updateData.finishedAt = data.finishedAt;
    }

    return await prisma.experiment.update({
      where: { id: data.experimentId },
      data: updateData,
    });
  }


  /**
   * Update experiment name
   */
  static async updateExperimentName(
    experimentId: string,
    name: string
  ): Promise<Experiment> {
    return await prisma.experiment.update({
      where: { id: experimentId },
      data: { name },
    });
  }

  /**
   * Delete experiment
   */
  static async deleteExperiment(experimentId: string): Promise<void> {
    await prisma.experiment.delete({
      where: { id: experimentId },
    });
  }

  /**
   * Get experiment count for a project
   */
  static async getExperimentCount(projectId: string): Promise<number> {
    return await prisma.experiment.count({
      where: { projectId },
    });
  }

  /**
   * Get experiments by status across all projects (admin function)
   */
  static async getExperimentsByStatus(status: string): Promise<Experiment[]> {
    return await prisma.experiment.findMany({
      where: {
        status: status as any, // Type assertion for enum
      },
      orderBy: { createdAt: 'desc' },
    });
  }
}
</file>

<file path="src/infra/dal/types.ts">
// DAL Types and Interfaces
import type { Project, Experiment, JobStatus } from '@prisma/client';

// Re-export Prisma types for DAL use
export type { Project, Experiment, JobStatus };

export interface CreateExperimentData {
  projectId: string;
  name: string;
  oec: string;
  minDays: number;
  minSessionsPerVariant: number;
}

export interface UpdateExperimentStatusData {
  experimentId: string;
  status: JobStatus;
  publishedAt?: Date;
  finishedAt?: Date;
}

export interface ProjectWithRelations extends Project {
  experiments: Experiment[];
  chatMessages: any[];
}

export interface ExperimentWithProject extends Experiment {
  project: Project;
}
</file>

<file path="src/infra/external/cloudflare/cloudflare-publisher.ts">
// Cloudflare Publisher Service
import { CloudflareConfig, PublishedExperiment, CloudflarePublishResult } from './types';

export interface CloudflarePublisher {
  publishExperiment(experiment: PublishedExperiment): Promise<CloudflarePublishResult>;
  unpublishExperiment(experimentId: string): Promise<CloudflarePublishResult>;
  getPublishedExperiments(): Promise<PublishedExperiment[]>;
}

export class CloudflarePublisherImpl implements CloudflarePublisher {
  private config: CloudflareConfig;
  private baseUrl: string;

  constructor(config: CloudflareConfig) {
    this.config = config;
    this.baseUrl = `https://api.cloudflare.com/client/v4/accounts/${config.accountId}/storage/kv/namespaces/${config.namespaceId}`;
  }

  async publishExperiment(experiment: PublishedExperiment): Promise<CloudflarePublishResult> {
    const key = `experiment:${experiment.id}`;
    console.log(`[CLOUDFLARE_PUBLISHER] Publishing experiment ${experiment.id} to Cloudflare KV`);
    console.log(`[CLOUDFLARE_PUBLISHER] Key: ${key}`);
    console.log(`[CLOUDFLARE_PUBLISHER] Experiment data:`, {
      id: experiment.id,
      name: experiment.name,
      status: experiment.status,
      variantCount: Object.keys(experiment.variants).length,
      trafficDistribution: experiment.traffic
    });

    try {
      const value = JSON.stringify(experiment);
      console.log(`[CLOUDFLARE_PUBLISHER] Payload size: ${value.length} bytes`);

      const response = await fetch(`${this.baseUrl}/values/${key}`, {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${this.config.apiToken}`,
          'Content-Type': 'application/json',
        },
        body: value,
      });

      console.log(`[CLOUDFLARE_PUBLISHER] Cloudflare API response: ${response.status} ${response.statusText}`);

      if (!response.ok) {
        const errorText = await response.text();
        console.error(`[CLOUDFLARE_PUBLISHER] Cloudflare API error response:`, errorText);
        throw new Error(`Cloudflare API error: ${response.status} - ${errorText}`);
      }

      const result = await response.json();
      console.log(`[CLOUDFLARE_PUBLISHER] Successfully published experiment ${experiment.id} to Cloudflare`);
      console.log(`[CLOUDFLARE_PUBLISHER] Cloudflare response:`, result);

      return {
        success: true,
        experimentId: experiment.id,
        key,
      };
    } catch (error) {
      console.error(`[CLOUDFLARE_PUBLISHER] Failed to publish experiment ${experiment.id}:`, error);
      console.error(`[CLOUDFLARE_PUBLISHER] Error details:`, {
        message: error instanceof Error ? error.message : 'Unknown error',
        stack: error instanceof Error ? error.stack : undefined,
        experimentId: experiment.id,
        key
      });
      return {
        success: false,
        experimentId: experiment.id,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  async unpublishExperiment(experimentId: string): Promise<CloudflarePublishResult> {
    const key = `experiment:${experimentId}`;
    console.log(`[CLOUDFLARE_PUBLISHER] Unpublishing experiment ${experimentId} from Cloudflare KV`);
    console.log(`[CLOUDFLARE_PUBLISHER] Key: ${key}`);

    try {
      const response = await fetch(`${this.baseUrl}/values/${key}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${this.config.apiToken}`,
        },
      });

      console.log(`[CLOUDFLARE_PUBLISHER] Cloudflare API response: ${response.status} ${response.statusText}`);

      if (!response.ok) {
        const errorText = await response.text();
        console.error(`[CLOUDFLARE_PUBLISHER] Cloudflare API error response:`, errorText);
        throw new Error(`Cloudflare API error: ${response.status} - ${errorText}`);
      }

      const result = await response.json();
      console.log(`[CLOUDFLARE_PUBLISHER] Successfully unpublished experiment ${experimentId} from Cloudflare`);
      console.log(`[CLOUDFLARE_PUBLISHER] Cloudflare response:`, result);

      return {
        success: true,
        experimentId,
        key,
      };
    } catch (error) {
      console.error(`[CLOUDFLARE_PUBLISHER] Failed to unpublish experiment ${experimentId}:`, error);
      console.error(`[CLOUDFLARE_PUBLISHER] Error details:`, {
        message: error instanceof Error ? error.message : 'Unknown error',
        stack: error instanceof Error ? error.stack : undefined,
        experimentId,
        key
      });
      return {
        success: false,
        experimentId,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  async getPublishedExperiments(): Promise<PublishedExperiment[]> {
    console.log(`[CLOUDFLARE_PUBLISHER] Fetching all published experiments from Cloudflare KV`);
    
    try {
      const response = await fetch(`${this.baseUrl}/keys?prefix=experiment:`, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${this.config.apiToken}`,
        },
      });

      console.log(`[CLOUDFLARE_PUBLISHER] Keys API response: ${response.status} ${response.statusText}`);

      if (!response.ok) {
        const errorText = await response.text();
        console.error(`[CLOUDFLARE_PUBLISHER] Cloudflare API error response:`, errorText);
        throw new Error(`Cloudflare API error: ${response.status} - ${errorText}`);
      }

      const data = await response.json();
      console.log(`[CLOUDFLARE_PUBLISHER] Found ${data.result.length} experiment keys`);
      
      const experiments: PublishedExperiment[] = [];

      // Fetch each experiment's data
      for (const keyInfo of data.result) {
        console.log(`[CLOUDFLARE_PUBLISHER] Fetching experiment data for key: ${keyInfo.name}`);
        
        const experimentResponse = await fetch(`${this.baseUrl}/values/${keyInfo.name}`, {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${this.config.apiToken}`,
          },
        });

        if (experimentResponse.ok) {
          const experiment = await experimentResponse.json();
          experiments.push(experiment);
          console.log(`[CLOUDFLARE_PUBLISHER] Successfully loaded experiment: ${experiment.id}`);
        } else {
          console.error(`[CLOUDFLARE_PUBLISHER] Failed to fetch experiment data for key ${keyInfo.name}: ${experimentResponse.status}`);
        }
      }

      console.log(`[CLOUDFLARE_PUBLISHER] Successfully loaded ${experiments.length} experiments from Cloudflare`);
      return experiments;
    } catch (error) {
      console.error(`[CLOUDFLARE_PUBLISHER] Failed to get published experiments:`, error);
      console.error(`[CLOUDFLARE_PUBLISHER] Error details:`, {
        message: error instanceof Error ? error.message : 'Unknown error',
        stack: error instanceof Error ? error.stack : undefined
      });
      return [];
    }
  }
}

export function createCloudflarePublisher(config: CloudflareConfig): CloudflarePublisher {
  return new CloudflarePublisherImpl(config);
}
</file>

<file path="src/infra/external/cloudflare/index.ts">
// Cloudflare External Service
export * from './types';
export * from './cloudflare-publisher';
</file>

<file path="src/infra/external/posthog/index.ts">
/**
 * PostHog External Service Module
 * 
 * Exports PostHog service and related utilities
 */

export { PostHogService } from './service';
export { getPostHogConfig } from './config';
export type {
  PostHogQueryParams,
  PostHogQueryResponse,
  PostHogEvent,
  PostHogConfig,
} from './types';
export {
  PostHogError,
  PostHogConnectionError,
  PostHogQueryError,
  PostHogRateLimitError,
} from './types';
</file>

<file path="src/infra/external/posthog/types.ts">
/**
 * PostHog Types
 * 
 * Type definitions for PostHog analytics integration
 */

// PostHog query response types
export interface PostHogEvent {
  event: string;
  properties: Record<string, unknown>;
  timestamp: string;
  distinct_id: string;
}

export interface PostHogQueryResponse {
  results: Record<string, unknown>[];
  hasMore: boolean;
  next?: string;
}

// PostHog configuration
export interface PostHogConfig {
  apiKey: string;
  host: string;
  timeout?: number;
  retries?: number;
}

// Re-export shared types for convenience
export type { VariantMetrics, ExperimentStatus } from '../../../shared/types';

// PostHog query parameters
export interface PostHogQueryParams {
  projectId: string;
  experimentId: string;
  startDate: string;
  endDate: string;
  primaryKPI: string;
  guardrails?: string[];
}

// PostHog error types
export class PostHogError extends Error {
  constructor(
    public statusCode: number,
    public errorCode: string,
    message: string,
    public details?: unknown
  ) {
    super(message);
    this.name = 'PostHogError';
  }
}

export class PostHogConnectionError extends PostHogError {
  constructor(details?: unknown) {
    super(503, 'POSTHOG_CONNECTION_ERROR', 'Failed to connect to PostHog', details);
  }
}

export class PostHogQueryError extends PostHogError {
  constructor(message: string, details?: unknown) {
    super(400, 'POSTHOG_QUERY_ERROR', message, details);
  }
}

export class PostHogRateLimitError extends PostHogError {
  constructor(retryAfter?: number, details?: unknown) {
    const errorDetails = details && typeof details === 'object' ? { retryAfter, ...details } : { retryAfter, details };
    super(429, 'POSTHOG_RATE_LIMIT_ERROR', 'PostHog rate limit exceeded', errorDetails);
  }
}
</file>

<file path="src/interfaces/http/project/brandSummary.ts">
import { FastifyInstance } from 'fastify';
import { serviceContainer } from '@app/container';
import { ProjectDAL } from '@infra/dal';
import { authMiddleware } from '../middleware/auth';
import { requireAuth } from '../middleware/authorization';
import { prisma } from '@infra/prisma';
import { JobStatus } from '@prisma/client';

export async function brandSummaryRoutes(fastify: FastifyInstance) {
    // Start brand summary generation
    fastify.post('/project/:projectId/brand-summary', { preHandler: [authMiddleware, requireAuth] }, async (request, reply) => {
        try {
            const { projectId } = request.params as { projectId: string };

            // Verify project exists and user owns it
            const project = await ProjectDAL.getProjectById(projectId);
            if (!project) {
                return reply.status(404).send({ error: 'Project not found' });
            }

            // Create job
            const job = await ProjectDAL.createBrandSummaryJob(projectId);

            // Start async processing
            processBrandSummary(job.id, projectId, fastify).catch(error => {
                fastify.log.error({ err: error, jobId: job.id }, 'Brand summary failed');
                updateJobStatus(job.id, 'FAILED', undefined, undefined, error.message);
            });

            return reply.status(200).send({
                jobId: job.id,
                status: 'pending',
                message: 'Brand summary generation started'
            });
        } catch (error) {
            fastify.log.error({ err: error }, 'Start brand summary error:');
            return reply.status(500).send({ error: 'Failed to start brand summary' });
        }
    });

    // Get brand summary status
    fastify.get('/project/:projectId/brand-summary/:jobId', { preHandler: [authMiddleware, requireAuth] }, async (request, reply) => {
        try {
            const { projectId, jobId } = request.params as { projectId: string; jobId: string };

            // Verify project exists and user owns it
            const project = await ProjectDAL.getProjectById(projectId);
            if (!project) {
                return reply.status(404).send({ error: 'Project not found' });
            }

            const job = await ProjectDAL.getBrandSummaryJob(jobId);
            if (!job) {
                return reply.status(404).send({ error: 'Job not found' });
            }

            return reply.status(200).send({
                jobId: job.id,
                status: job.status.toLowerCase(),
                progress: job.progress || undefined,
                result: job.result || undefined,
                error: job.error || undefined,
                createdAt: job.createdAt.toISOString(),
                completedAt: job.completedAt?.toISOString(),
            });
        } catch (error) {
            fastify.log.error({ err: error }, 'Get brand summary status error:');
            return reply.status(500).send({ error: 'Failed to get brand summary status' });
        }
    });
}

// Simple async processing function
async function processBrandSummary(jobId: string, projectId: string, fastify: FastifyInstance): Promise<void> {
    try {
        fastify.log.info({ jobId, projectId }, 'Starting brand summary processing');
        
        // Update to running
        await updateJobStatus(jobId, 'RUNNING', 10);

        // Get project
        const project = await ProjectDAL.getProjectById(projectId);
        if (!project) throw new Error('Project not found');

        fastify.log.info({ jobId, shopDomain: project.shopDomain }, 'Running brand analysis');

        // Run brand analysis
        const brandAnalysisService = serviceContainer.getBrandAnalysisService();
        const result = await brandAnalysisService.analyzeProject(projectId, project.shopDomain);

        if (!result.success) {
            throw new Error(result.error || 'Brand analysis failed');
        }

        fastify.log.info({ jobId }, 'Brand analysis completed successfully');

        // Complete job
        await updateJobStatus(jobId, 'COMPLETED', 100, result.brandSummary ? { ...result.brandSummary } : undefined);

    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        fastify.log.error({ err: error, jobId, projectId }, 'Brand summary processing failed');
        await updateJobStatus(jobId, 'FAILED', undefined, undefined, errorMessage);
    }
}

// Simple job status update
async function updateJobStatus(
    jobId: string,
    status: JobStatus,
    progress?: number,
    result?: any, // Prisma's JsonValue type
    error?: string
): Promise<void> {
    const updateData = {
        status,
        ...(progress !== undefined && { progress }),
        ...(result !== undefined && { result }),
        ...(error !== undefined && { error }),
        ...(status === 'RUNNING' && { startedAt: new Date() }),
        ...((status === 'COMPLETED' || status === 'FAILED') && { completedAt: new Date() })
    };

    await prisma.brandSummaryJob.update({
        where: { id: jobId },
        data: updateData,
    });
}
</file>

<file path="src/services/job-cleanup.ts">
import { VariantJobDAL } from '@infra/dal';
import { PrismaClient } from '@prisma/client';
import { createScreenshotStorageService, ScreenshotStorageService } from './screenshot-storage';

export class JobCleanupService {
    private cleanupInterval: NodeJS.Timeout | null = null;
    private readonly CLEANUP_INTERVAL = 24 * 60 * 60 * 1000; // 24 hours
    private readonly JOB_RETENTION_DAYS = 7; // Keep jobs for 7 days
    private screenshotStorage: ScreenshotStorageService;

    constructor(prisma: PrismaClient) {
        this.screenshotStorage = createScreenshotStorageService(prisma);
    }

    startCleanup(): void {
        if (this.cleanupInterval) {
            console.log('[JOB_CLEANUP] Cleanup already running');
            return;
        }

        console.log('[JOB_CLEANUP] Starting job cleanup service');
        
        // Run cleanup immediately
        this.runCleanup();
        
        // Schedule periodic cleanup
        this.cleanupInterval = setInterval(() => {
            this.runCleanup();
        }, this.CLEANUP_INTERVAL);
    }

    stopCleanup(): void {
        if (this.cleanupInterval) {
            clearInterval(this.cleanupInterval);
            this.cleanupInterval = null;
            console.log('[JOB_CLEANUP] Job cleanup service stopped');
        }
    }

    private async runCleanup(): Promise<void> {
        try {
            console.log('[JOB_CLEANUP] Running job cleanup...');
            const deletedCount = await VariantJobDAL.cleanupOldJobs(this.JOB_RETENTION_DAYS);
            console.log(`[JOB_CLEANUP] Cleaned up ${deletedCount} old variant jobs`);
            
            // Clean up expired screenshots
            console.log('[JOB_CLEANUP] Running screenshot cleanup...');
            const screenshotCount = await this.screenshotStorage.cleanupExpiredScreenshots();
            console.log(`[JOB_CLEANUP] Cleaned up ${screenshotCount} expired screenshots`);
        } catch (error) {
            console.error('[JOB_CLEANUP] Error during cleanup:', error);
        }
    }

    async cleanupNow(): Promise<number> {
        console.log('[JOB_CLEANUP] Running immediate cleanup...');
        return await VariantJobDAL.cleanupOldJobs(this.JOB_RETENTION_DAYS);
    }

    async cleanupScreenshots(): Promise<number> {
        console.log('[JOB_CLEANUP] Running screenshot cleanup...');
        return await this.screenshotStorage.cleanupExpiredScreenshots();
    }

    async getScreenshotStats(projectId: string): Promise<{
        totalScreenshots: number;
        totalSize: number;
        accessCount: number;
    }> {
        return await this.screenshotStorage.getScreenshotStats(projectId);
    }
}

export function createJobCleanupService(prisma: PrismaClient): JobCleanupService {
    return new JobCleanupService(prisma);
}
</file>

<file path="src/services/project-info.ts">
// Project Information Service
import { ProjectDAL } from '@infra/dal';
import { shopify } from '@infra/external/shopify';
import type { ProjectInfo } from '@domain/agent';

export interface ProjectInfoService {
  getProjectInfo(projectId: string): Promise<ProjectInfo>;
}

export class ProjectInfoServiceImpl implements ProjectInfoService {
  async getProjectInfo(projectId: string): Promise<ProjectInfo> {
    // Get project with relations
    const project = await ProjectDAL.getProjectWithRelations(projectId);
    if (!project) {
      throw new Error(`Project ${projectId} not found`);
    }

    // Get Shopify store information
    let shopInfo: {
      name?: string;
      email?: string;
      planName?: string;
      currency?: string;
      country?: string;
    } = {};

    try {
      const shopProfile = await shopify.getShopProfileWithEncryptedToken(
        project.shopDomain,
        project.accessTokenEnc
      );
      shopInfo = {
        name: shopProfile.name,
        email: shopProfile.email,
        planName: shopProfile.planName,
        currency: shopProfile.currency,
        country: shopProfile.country,
      };
    } catch (error) {
      console.warn(`[PROJECT_INFO] Failed to fetch Shopify store info for ${project.shopDomain}:`, error);
      // Continue without shop info if API call fails
    }

    // Count experiments by status
    const experimentsCount = project.experiments.length;
    const activeExperimentsCount = project.experiments.filter(
      exp => exp.status === 'RUNNING'
    ).length;

    return {
      id: project.id,
      shopDomain: project.shopDomain,
      shopName: shopInfo.name,
      shopEmail: shopInfo.email,
      shopPlan: shopInfo.planName,
      shopCurrency: shopInfo.currency,
      shopCountry: shopInfo.country,
      experimentsCount,
      activeExperimentsCount,
    };
  }
}

export function createProjectInfoService(): ProjectInfoService {
  return new ProjectInfoServiceImpl();
}
</file>

<file path="src/services/variant-job-processor.ts">
// @ts-nocheck
import { VariantJobDAL } from '@infra/dal';
import { createVariantGenerationService } from '@features/variant_generation/variant-generation';
import { createPlaywrightCrawler } from '@features/crawler';
import { createScreenshotStorageService } from '@services/screenshot-storage';
import { getServiceConfig } from '@infra/config/services';
import { PrismaClient } from '@prisma/client';

export class VariantJobProcessor {
    private variantGenerationService: any;
    private prisma: PrismaClient;
    private screenshotStorage: any;

    constructor() {
        this.prisma = new PrismaClient();
        const config = getServiceConfig();
        const crawler = createPlaywrightCrawler(config.crawler);
        this.screenshotStorage = createScreenshotStorageService(this.prisma);
        this.variantGenerationService = createVariantGenerationService(crawler, this.screenshotStorage, this.prisma);
    }

    async processVariantJob(jobId: string, projectId: string, hypothesis: any): Promise<void> {
        console.log(`[VARIANT_JOB] Starting processing for job ${jobId}`);
        
        try {
            // Update job status to running
            await VariantJobDAL.updateJob(jobId, {
                status: 'RUNNING',
                progress: 10,
                startedAt: new Date(),
            });

            // Get project data
            const project = await this.variantGenerationService.getCachedProject(projectId);
            if (!project) {
                throw new Error(`Project not found: ${projectId}`);
            }
            
            const url = `https://${project.shopDomain}`;
            console.log(`[VARIANT_JOB] Using shop domain: ${project.shopDomain}, URL: ${url}`);

            // Update progress
            await VariantJobDAL.updateJob(jobId, {
                progress: 20,
            });

            // Run the initial analysis in parallel (screenshot, DOM analysis, brand analysis)
            console.log(`[VARIANT_JOB] Starting parallel operations for job ${jobId}`);
            
            // Check for cached screenshot and HTML first
            const pageType = this.getPageType(url);
            const cachedData = await this.screenshotStorage.getScreenshotWithHtml(
                projectId, 
                pageType, 
                { viewport: { width: 1920, height: 1080 }, fullPage: true, quality: 80 }
            );
            
            let screenshot: string;
            let htmlContent: string | null = null;
            
            if (cachedData.screenshot) {
                console.log(`[VARIANT_JOB] Using cached screenshot and HTML for ${pageType} page`);
                screenshot = cachedData.screenshot;
                htmlContent = cachedData.html;
            } else {
                console.log(`[VARIANT_JOB] Taking new screenshot for ${url}`);
                screenshot = await this.variantGenerationService.crawlerService.takePartialScreenshot(url, { width: 1920, height: 1080 }, true, { type: 'shopify_password', password: 'reitri', shopDomain: project.shopDomain });
            }
            
            const [injectionPoints, brandAnalysis] = await Promise.all([
                // Use cached HTML if available, otherwise fall back to regular analysis
                htmlContent 
                    ? this.variantGenerationService.domAnalyzer.analyzeForHypothesisWithHtml(
                        url, 
                        hypothesis.hypothesis,
                        projectId,
                        htmlContent,
                        { type: 'shopify_password', password: 'reitri', shopDomain: project.shopDomain }
                    )
                    : this.variantGenerationService.domAnalyzer.analyzeForHypothesis(
                        url, 
                        hypothesis.hypothesis,
                        projectId,
                        { type: 'shopify_password', password: 'reitri', shopDomain: project.shopDomain }
                    ),
                this.variantGenerationService.getCachedBrandAnalysis(projectId)
            ]);

            console.log(`[VARIANT_JOB] Parallel operations completed for job ${jobId}`);
            
            if (!brandAnalysis) {
                throw new Error(`No brand analysis available for project ${projectId}. Please run brand analysis first.`);
            }

            // Update progress
            await VariantJobDAL.updateJob(jobId, {
                progress: 40,
            });

            // Generate the variant description using AI
            console.log(`[VARIANT_JOB] Generating AI response for job ${jobId}`);
            const aiConfig = this.variantGenerationService.getAIConfig();
            const { generateObject } = await import('ai');
            const { google } = await import('@ai-sdk/google');
            
            const response = await generateObject({
                model: google(aiConfig.model, {
                    apiKey: aiConfig.apiKey,
                }),
                schema: this.variantGenerationService.basicVariantsResponseSchema,
                messages: [
                    {
                        role: 'user',
                        content: [
                            { type: "text", text: this.variantGenerationService.buildVariantGenerationPrompt(hypothesis) },
                            { type: "text", text: brandAnalysis },
                            { type: "image", image: `data:image/png;base64,${screenshot}` }
                        ]
                    }
                ]
            });

            // Pick a random variant from the 3 generated (or use a specific one based on job index)
            const jobIndex = await this.getJobIndex(jobId, projectId);
            const variants = response.object.variants;
            const variant = variants[jobIndex % variants.length];
            
            console.log(`[VARIANT_JOB] Selected variant ${variant.variant_label} for job ${jobId}`);

            // Update progress
            await VariantJobDAL.updateJob(jobId, {
                progress: 60,
            });

            // Generate the single variant with code and screenshots
            console.log(`[VARIANT_JOB] Generating variant ${variant.variant_label} for job ${jobId}`);
            const finalVariant = await this.variantGenerationService.generateSingleVariant(
                variant,
                hypothesis,
                projectId,
                screenshot,
                injectionPoints,
                brandAnalysis
            );

            // Update job with result
            await VariantJobDAL.updateJob(jobId, {
                status: 'COMPLETED',
                progress: 100,
                result: {
                    variantsSchema: {
                        variants: [finalVariant]
                    }
                },
                completedAt: new Date(),
            });

            console.log(`[VARIANT_JOB] Successfully completed job ${jobId} for variant ${variant.variant_label}`);

        } catch (error) {
            console.error(`[VARIANT_JOB] Failed to process job ${jobId}:`, error);
            
            // Update job with error
            await VariantJobDAL.updateJob(jobId, {
                status: 'FAILED',
                error: error instanceof Error ? error.message : 'Unknown error occurred',
                completedAt: new Date(),
            });
        }
    }

    private async getJobIndex(jobId: string, projectId: string): Promise<number> {
        // Get all jobs for this project and find the index of this job
        const jobs = await VariantJobDAL.getJobsByProject(projectId);
        const jobIndex = jobs.findIndex(job => job.id === jobId);
        return jobIndex >= 0 ? jobIndex : 0;
    }

    async processVariantJobs(jobIds: string[], projectId: string, hypothesis: any): Promise<void> {
        console.log(`[VARIANT_JOB] Starting processing for ${jobIds.length} variant jobs`);
        
        // Process all jobs in parallel with proper memory management
        const promises = jobIds.map((jobId, index) => 
            this.processVariantJobWithCleanup(jobId, projectId, hypothesis, index)
        );

        try {
            await Promise.all(promises);
            console.log(`[VARIANT_JOB] Completed processing all ${jobIds.length} variant jobs`);
        } catch (error) {
            console.error(`[VARIANT_JOB] Some variant jobs failed:`, error);
        }
    }

    private async processVariantJobWithCleanup(jobId: string, projectId: string, hypothesis: any, index: number): Promise<void> {
        console.log(`[VARIANT_JOB] Starting job ${index + 1}: ${jobId}`);
        
        // Log memory usage before processing
        this.logMemoryUsage(`Before job ${index + 1}`);
        
        try {
            await this.processVariantJob(jobId, projectId, hypothesis);
            console.log(`[VARIANT_JOB] Successfully completed job ${index + 1}: ${jobId}`);
        } catch (error) {
            console.error(`[VARIANT_JOB] Failed to process job ${index + 1}: ${jobId}`, error);
            throw error; // Re-throw to be caught by Promise.all
        } finally {
            // Force garbage collection after each job to manage memory
            this.forceGarbageCollection();
            this.logMemoryUsage(`After job ${index + 1}`);
        }
    }

    private logMemoryUsage(context: string): void {
        if (process.memoryUsage) {
            const memUsage = process.memoryUsage();
            console.log(`[MEMORY] ${context} - RSS: ${Math.round(memUsage.rss / 1024 / 1024)}MB, Heap: ${Math.round(memUsage.heapUsed / 1024 / 1024)}MB`);
        }
    }

    private forceGarbageCollection(): void {
        if (global.gc) {
            global.gc();
            console.log(`[MEMORY] Forced garbage collection`);
        }
    }

    private getPageType(url: string): 'home' | 'pdp' | 'about' | 'other' {
        const urlLower = url.toLowerCase();
        
        // Check for product pages first
        if (urlLower.includes('/products/') || urlLower.includes('/collections/')) {
            return 'pdp';
        }
        
        // Check for about pages
        if (urlLower.includes('/about')) {
            return 'about';
        }
        
        // Check for home page - this should be the most common case
        // Home page is typically just the domain or domain with trailing slash
        const urlObj = new URL(url);
        const pathname = urlObj.pathname;
        
        // If no path or just a trailing slash, it's the home page
        if (!pathname || pathname === '/' || pathname === '') {
            return 'home';
        }
        
        // If path is just common home page indicators
        if (pathname === '/home' || pathname === '/index' || pathname === '/index.html') {
            return 'home';
        }
        
        return 'other';
    }

    async cleanup(): Promise<void> {
        await this.prisma.$disconnect();
    }
}

export function createVariantJobProcessor(): VariantJobProcessor {
    return new VariantJobProcessor();
}
</file>

<file path="src/shared/ai-config.ts">
// Shared AI Configuration
import { getServiceConfig } from '@infra/config/services';

export interface AIConfig {
  model: string;
  temperature: number;
  maxTokens: number;
  apiKey: string;
}

export function getAIConfig(): AIConfig {
  const config = getServiceConfig();
  return {
    model: config.google?.model || 'gemini-2.5-flash',
    temperature: config.google?.temperature || 0.7,
    maxTokens: config.google?.maxTokens || 1000,
    apiKey: config.google?.apiKey || '',
  };
}

// Common AI SDK configurations
export const AI_CONFIGS = {
  STREAMING: {
    temperature: 0.7,
    maxTokens: 1000,
  },
  STRUCTURED_OUTPUT: {
    temperature: 0.3,
    maxTokens: 2000,
  },
  ANALYSIS: {
    temperature: 0.5,
    maxTokens: 1500,
  },
} as const;
</file>

<file path="app.json">
{
  "name": "omen-backend",
  "description": "Omen Backend API",
  "repository": "https://github.com/your-username/omen",
  "logo": "",
  "keywords": ["node", "fastify", "typescript", "prisma"],
  "image": "heroku/nodejs",
  "stack": "heroku-22",
  "region": "eu",
  "buildpacks": [
    {
      "url": "https://github.com/heroku/heroku-buildpack-chrome-for-testing"
    },
    {
      "url": "heroku/nodejs"
    }
  ],
  "env": {
    "NODE_ENV": {
      "description": "Environment",
      "value": "production"
    },
    "PORT": {
      "description": "Port for the web server",
      "value": "3000"
    },
    "PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD": {
      "description": "Skip Playwright browser download, use system Chrome",
      "value": "true"
    }
  },
  "formation": {
    "web": {
      "quantity": 1,
      "size": "basic"
    }
  },
  "addons": [
    {
      "plan": "heroku-postgresql:essential-0"
    }
  ]
}
</file>

<file path="eslint.config.js">
import js from '@eslint/js';
import tseslint from '@typescript-eslint/eslint-plugin';
import tsparser from '@typescript-eslint/parser';

export default [
  js.configs.recommended,
  {
    files: ['src/**/*.ts'],
    languageOptions: {
      parser: tsparser,
      parserOptions: {
        ecmaVersion: 2020,
        sourceType: 'module',
        project: './tsconfig.json',
      },
      globals: {
        console: 'readonly',
        process: 'readonly',
        Buffer: 'readonly',
        __dirname: 'readonly',
        __filename: 'readonly',
        global: 'readonly',
        module: 'readonly',
        require: 'readonly',
        exports: 'readonly',
      },
    },
    plugins: {
      '@typescript-eslint': tseslint,
    },
    rules: {
      // Basic rules
      'no-console': 'off', // Allow console.log in Node.js
      'no-unused-vars': 'off', // Use TypeScript version instead
      '@typescript-eslint/no-unused-vars': ['error', { 
        argsIgnorePattern: '^_',
        varsIgnorePattern: '^_',
        caughtErrorsIgnorePattern: '^_',
        destructuredArrayIgnorePattern: '^_'
      }],
      '@typescript-eslint/explicit-function-return-type': 'off',
      '@typescript-eslint/explicit-module-boundary-types': 'off',
      '@typescript-eslint/no-explicit-any': 'warn',
      '@typescript-eslint/no-inferrable-types': 'off',
      'prefer-const': 'error',
      'no-var': 'error',
    },
  },
  {
    ignores: ['dist/', 'node_modules/', '*.js'],
  },
];
</file>

<file path="Procfile">
release: npm run db:deploy
web: npm start
</file>

<file path="prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"
</file>

<file path="src/domain/agent/index.ts">
// Agent Domain
export * from './types';
export * from './agent';
export * from './tools';
export * from './prompts';
</file>

<file path="src/features/brand_analysis/code-analyzer.ts">
// Code Analysis Service
import { generateObject } from 'ai';
import { google } from '@ai-sdk/google';
import { z } from 'zod';
import { getAIConfig } from '@shared/ai-config';

export interface CodeAnalysisResult {
  websiteStructure: {
    informationArchitecture: string;
    contentDepth: string;
    navigationPattern: string;
  };
  designTokens: {
    colors: string[];
    fonts: string[];
    margins: string[];
  };
}

const codeAnalysisSchema = z.object({
  informationArchitecture: z.string(),
  contentDepth: z.string(),
  navigationPattern: z.string(),
  colors: z.array(z.string()),
  fonts: z.array(z.string()),
  margins: z.array(z.string()),
});

export class CodeAnalyzer {
  constructor() {}

  async analyzeCode(htmlContent: string[], urls: string[]): Promise<CodeAnalysisResult> {
    const prompt = this.buildCodeAnalysisPrompt(htmlContent, urls);
    
    try {
      const aiConfig = getAIConfig();
      const result = await generateObject({
        model: google(aiConfig.model),
        schema: codeAnalysisSchema,
        messages: [
          {
            role: 'user',
            content: prompt
          }
        ]
      });

      const data = result.object;
      return {
        websiteStructure: {
          informationArchitecture: data.informationArchitecture,
          contentDepth: data.contentDepth,
          navigationPattern: data.navigationPattern,
        },
        designTokens: {
          colors: data.colors,
          fonts: data.fonts,
          margins: data.margins,
        }
      };
    } catch (error) {
      throw new Error(`Failed to analyze code: ${error}`);
    }
  }

  private buildCodeAnalysisPrompt(htmlContent: string[], urls: string[]): string {
    const htmlSamples = htmlContent.map((html, index) => 
      `=== Page ${index + 1} (${urls[index] || 'Unknown URL'}) ===\n${html.substring(0, 2000)}...`
    ).join('\n\n');

    return `
# Website Structure & Design Analysis

Analyze this HTML code to understand the website structure and extract design tokens.

## What to analyze:

**Website Structure:**
- How is the information organized? (header, main content, sidebar, footer)
- What's the content depth? (shallow with few pages, deep with many categories)
- How does navigation work? (horizontal menu, vertical sidebar, breadcrumbs)

**Design Tokens:**
- What colors are used? (background, text, accent colors)
- What fonts are used? (font families, weights)
- What spacing patterns? (margins, padding values)

## HTML Content to Analyze:

${htmlSamples}

Extract both structural insights and design tokens from the code.
    `.trim();
  }
}
</file>

<file path="src/features/brand_analysis/index.ts">
// Brand Analysis Feature Exports
export { BrandAnalysisService, BrandAnalysisServiceImpl, createBrandAnalysisService } from './brand-analysis';
export type {
  BrandAnalysisRequest,
  BrandAnalysisResponse
} from './types';
</file>

<file path="src/features/brand_analysis/language-analyzer.ts">
// Language Analysis Service
import { generateObject } from 'ai';
import { google } from '@ai-sdk/google';
import { z } from 'zod';
import { getAIConfig } from '@shared/ai-config';

export interface LanguageAnalysisResult {
  voice: {
    tones: string[];
    keyPhrases: string[];
  };
  brandPersonality: {
    adjectives: string[];
    values: string[];
    targetAudience: string;
  };
  valueProposition: {
    primaryMessage: string;
    supportingBenefits: string[];
    differentiators: string[];
    proofElements: string[];
  };
  messaging: {
    headlines: string[];
    ctas: string[];
    contentThemes: string[];
    trustSignals: string[];
  };
}

const languageAnalysisSchema = z.object({
  tones: z.array(z.string()),
  keyPhrases: z.array(z.string()),
  adjectives: z.array(z.string()),
  values: z.array(z.string()),
  targetAudience: z.string(),
  primaryMessage: z.string(),
  supportingBenefits: z.array(z.string()),
  differentiators: z.array(z.string()),
  proofElements: z.array(z.string()),
  headlines: z.array(z.string()),
  ctas: z.array(z.string()),
  contentThemes: z.array(z.string()),
  trustSignals: z.array(z.string()),
});

export class LanguageAnalyzer {
  constructor() {}

  async analyzeLanguage(htmlContent: string[]): Promise<LanguageAnalysisResult> {
    // Extract text content from HTML
    const textContent = this.extractTextContent(htmlContent);
    
    const prompt = this.buildLanguageAnalysisPrompt(textContent);
    
    try {
      const aiConfig = getAIConfig();
      const result = await generateObject({
        model: google(aiConfig.model),
        schema: languageAnalysisSchema,
        messages: [
          {
            role: 'user',
            content: prompt
          }
        ]
      });

      const data = result.object;
      return {
        voice: {
          tones: data.tones,
          keyPhrases: data.keyPhrases,
        },
        brandPersonality: {
          adjectives: data.adjectives,
          values: data.values,
          targetAudience: data.targetAudience,
        },
        valueProposition: {
          primaryMessage: data.primaryMessage,
          supportingBenefits: data.supportingBenefits,
          differentiators: data.differentiators,
          proofElements: data.proofElements,
        },
        messaging: {
          headlines: data.headlines,
          ctas: data.ctas,
          contentThemes: data.contentThemes,
          trustSignals: data.trustSignals,
        }
      };
    } catch (error) {
      throw new Error(`Failed to analyze language: ${error}`);
    }
  }

  private extractTextContent(htmlContent: string[]): string {
    const splitHtml = htmlContent.map(html => html.split("</nav>")[1]?.split("footer")[0] || html);

    let regexFinds: string[] = [];
    const regex = /(?:<(?:p|h1|h2|h3|h4|h5|h6|span|div|a|button)[^>]*>(.+)<\/(?:p|h1|h2|h3|h4|h5|h6|span|div|a|button)>.*)+/g;
    let m: RegExpExecArray | null;
    
    splitHtml.forEach((element) => {
      while ((m = regex.exec(element)) !== null) {
        const result = m[1];
        // Clean up HTML entities and extra whitespace
        const cleanText = result
          .replace(/&[a-zA-Z0-9#]+;/g, ' ') // Remove HTML entities
          .replace(/\s+/g, ' ') // Normalize whitespace
          .trim();
        
        if (cleanText.length > 10) {
          regexFinds.push(cleanText);
        }
      }
    });

    // Filter out common e-commerce noise
    return regexFinds
      .filter(item => 
        item.length > 20 && 
        !item.toLowerCase().includes("cart") && 
        !item.toLowerCase().includes("eur") &&
        !item.toLowerCase().includes("cookie") &&
        !item.toLowerCase().includes("newsletter") &&
        !item.toLowerCase().includes("subscribe")
      )
      .join("\n");
  }

  private buildLanguageAnalysisPrompt(textContent: string): string {
    return `
# Brand Language Analysis

Please analyze the provided text content from this e-commerce store and focus on the language, messaging, and brand voice aspects.

## Analysis Focus Areas:

**Voice & Tone:**
- Identify the brand's tone of voice (professional, casual, friendly, authoritative, etc.)
- Extract key phrases and recurring language patterns
- Analyze the overall personality conveyed through language

**Brand Personality:**
- Determine brand adjectives based on language choices
- Identify core values expressed through messaging
- Determine target audience based on language and messaging cues

**Value Proposition Analysis:**
- Identify the primary brand message and value proposition
- Extract supporting benefits mentioned in the content
- Find differentiators and unique selling points
- Identify proof elements and trust signals

**Messaging Patterns:**
- Extract headlines and their patterns
- Analyze call-to-action language and patterns
- Identify recurring content themes
- Find trust signals and credibility indicators

## Text Content to Analyze:

${textContent}

Provide specific, actionable insights based on the language and messaging patterns. Focus on identifying clear voice characteristics and messaging strategies.
    `.trim();
  }
}
</file>

<file path="src/infra/dal/user.ts">
import { prisma } from '@infra/prisma';
import type { User as PrismaUser, Project } from '@prisma/client';

// Use Prisma-generated types as the source of truth
export type User = PrismaUser & {
  project?: Pick<Project, 'id' | 'shopDomain' | 'brandAnalysis'>;
};

/**
 * User service for database operations
 * Handles all user-related database logic
 */
export class UserService {
  /**
   * Get user by Auth0 ID
   */
  async getUserByAuth0Id(auth0Id: string): Promise<User | null> {
    const user = await prisma.user.findUnique({
      where: { auth0Id },
      include: { project: true },
    });

    return user as User | null;
  }

  /**
   * Get or create user from Auth0 payload
   * Creates user on first login
   */
  async getOrCreateUser(auth0Id: string, email: string, firstName: string = '', lastName: string = ''): Promise<User> {
    // Try to find existing user
    let user = await prisma.user.findUnique({
      where: { auth0Id },
      include: { project: true },
    });

    if (!user) {
      // Create new user on first login
      user = await prisma.user.create({
        data: {
          auth0Id,
          email,
          firstName,
          lastName,
        },
        include: { project: true },
      });
    } else {
      // Update email if it has changed
      if (user.email !== email) {
        user = await prisma.user.update({
          where: { id: user.id },
          data: { email },
          include: { project: true },
        });
      }
    }

    return user as User;
  }

  /**
   * Get user by ID with project details
   */
  async getUserById(userId: string): Promise<User | null> {
    const user = await prisma.user.findUnique({
      where: { id: userId },
      include: { project: true },
    });

    return user as User | null;
  }


  /**
   * Update user email
   */
  async updateUserEmail(userId: string, email: string): Promise<User> {
    const user = await prisma.user.update({
      where: { id: userId },
      data: { email },
      include: { project: true },
    });

    return user as User;
  }

  /**
   * Delete user
   */
  async deleteUser(userId: string): Promise<void> {
    await prisma.user.delete({
      where: { id: userId },
    });
  }

  /**
   * Bind a project to a user (single project rule)
   * This will create a new project or update the existing one
   */
  async bindProjectToUser(userId: string, shopDomain: string, accessTokenEnc: string): Promise<User> {
    // Check if user exists
    const existingUser = await prisma.user.findUnique({
      where: { id: userId },
      include: { project: true },
    });

    if (!existingUser) {
      throw new Error('User not found');
    }

    // If user already has a project, update it; otherwise create a new one
    const user = await prisma.user.update({
      where: { id: userId },
      data: {
        project: existingUser.project
          ? {
              update: {
                shopDomain,
                accessTokenEnc,
              },
            }
          : {
              create: {
                shopDomain,
                accessTokenEnc,
              },
            },
      },
      include: { project: true },
    });

    return user as User;
  }

  /**
   * Get user's project ID
   */
  async getUserProjectId(userId: string): Promise<string | null> {
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: { project: { select: { id: true } } },
    });

    return user?.project?.id || null;
  }

  /**
   * Check if user owns a specific project
   */
  async userOwnsProject(userId: string, projectId: string): Promise<boolean> {
    const user = await prisma.user.findUnique({
      where: { 
        id: userId,
        project: { id: projectId },
      },
      select: { id: true },
    });

    return !!user;
  }
}

export const userService = new UserService();
</file>

<file path="src/infra/external/auth0/auth0.ts">
import { ManagementClient } from 'auth0';

/**
 * Auth0 Management API service
 * Handles only Auth0 operations, not our database
 */
export class Auth0Service {
  private managementClient: ManagementClient;

  constructor() {
    this.managementClient = new ManagementClient({
      domain: process.env.AUTH0_DOMAIN!,
      clientId: process.env.AUTH0_M2M_CLIENT_ID!,
      clientSecret: process.env.AUTH0_M2M_CLIENT_SECRET!,
    });
  }

  /**
   * Create a new user in Auth0
   */
  async createUser(email: string, password?: string): Promise<{ id: string; email: string }> {
    const userData: {
      email: string;
      email_verified: boolean;
      connection: string;
      password?: string;
    } = {
      email,
      email_verified: false,
      connection: 'Username-Password-Authentication',
    };

    if (password) {
      userData.password = password;
    }

    if (email == "lucas@omen.so") {
      // Fetch user from Auth0 and dont create a new user
      const SIMON_AUTH0_ID = "auth0|68cc0ec46a10679b03412c0c";
      const auth0User = await this.managementClient.users.get({ id: SIMON_AUTH0_ID });
      return {
        id: auth0User.data.user_id!,
        email: auth0User.data.email!,
      };
    }

    const auth0User = await this.managementClient.users.create(userData);

    return {
      id: auth0User.data.user_id!,
      email: auth0User.data.email!,
    };
  }

  /**
   * Get user from Auth0 by ID
   */
  async getAuth0UserById(auth0Id: string): Promise<{ id: string; email: string } | null> {
    try {
      const auth0User = await this.managementClient.users.get({ id: auth0Id });

      return {
        id: auth0User.data.user_id!,
        email: auth0User.data.email!,
      };
    } catch {
      return null;
    }
  }

  /**
   * Get user from Auth0 by email
   */
  async getAuth0UserByEmail(email: string): Promise<{ id: string; email: string } | null> {
    try {
      const users = await this.managementClient.users.getAll({
        q: `email:"${email}"`,
        search_engine: 'v3'
      });

      if (users.data.length > 0) {
        const user = users.data[0];
        return {
          id: user.user_id!,
          email: user.email!,
        };
      }

      return null;
    } catch {
      return null;
    }
  }

  /**
   * Update user in Auth0
   */
  async updateAuth0User(auth0Id: string, updates: { email?: string; email_verified?: boolean }): Promise<void> {
    await this.managementClient.users.update({ id: auth0Id }, updates);
  }

  /**
   * Delete user from Auth0
   */
  async deleteAuth0User(auth0Id: string): Promise<void> {
    await this.managementClient.users.delete({ id: auth0Id });
  }
}

export const auth0 = new Auth0Service();
</file>

<file path="src/infra/external/shopify/config.ts">
/**
 * Shopify configuration module
 * Handles Shopify API configuration and validation
 */

export const shopifyConfig = {
  apiKey: process.env.SHOPIFY_API_KEY!,
  apiSecret: process.env.SHOPIFY_API_SECRET!,
  scopes: process.env.SHOPIFY_SCOPES || 'read_products,write_products,read_orders,write_orders, write_themes, read_themes',
  redirectUri: process.env.SHOPIFY_REDIRECT_URI!,
  encryptionKey: process.env.ENCRYPTION_KEY!,
};

// Validate required environment variables
const requiredEnvVars = [
  'SHOPIFY_API_KEY',
  'SHOPIFY_API_SECRET',
  'SHOPIFY_REDIRECT_URI',
  'ENCRYPTION_KEY',
];

for (const envVar of requiredEnvVars) {
  if (!process.env[envVar]) {
    throw new Error(`Missing required environment variable: ${envVar}`);
  }
}

// Validate encryption key length (should be 32 or 64 characters for AES-256)
if (shopifyConfig.encryptionKey.length !== 32 && shopifyConfig.encryptionKey.length !== 64) {
  throw new Error('ENCRYPTION_KEY must be exactly 32 or 64 characters long for AES-256 encryption');
}
</file>

<file path="src/infra/external/shopify/graphql.ts">
import '@shopify/shopify-api/adapters/node';
import { shopifyApi, ApiVersion, Session } from '@shopify/shopify-api';
import { ProjectDAL } from '../../dal';
import { decrypt } from '../../encryption';

const shopify = shopifyApi({
    apiKey: process.env.SHOPIFY_API_KEY,
    apiSecretKey: process.env.SHOPIFY_API_SECRET!,
    scopes: ['read_products, read_themes'],
    hostName: 'ngrok-tunnel-address',
    apiVersion: ApiVersion.July25,
    isEmbeddedApp: false,

});

const getDefaultProjectInfo = async () => {
    const projectInfo = await ProjectDAL.getProjectById("cmfnzk7mh0001qjm3ujts5g08");

    if (!projectInfo) {
        throw new Error("Project not found");
    }

    // Log all variables to check if they are correct
    console.log("Project info:", projectInfo);
    console.log("Shop domain:", projectInfo.shopDomain);
    console.log("Access token:", projectInfo.accessTokenEnc);
    console.log("Key:", process.env.SHOPIFY_API_KEY);
    console.log("Secret:", process.env.SHOPIFY_API_SECRET);

    const session = new Session({
        id: `offline_${projectInfo.shopDomain}`, // offline token format; if online, use a unique session ID
        shop: projectInfo.shopDomain,
        state: "state",
        isOnline: false, // true if using an online token
        accessToken: decrypt(projectInfo.accessTokenEnc),
    });

    if (!session) {
        throw new Error("Session not found");
    }

    const client = new shopify.clients.Graphql({ session });

    const data = await client.query({
        data: `query GetThemes {
  themes(roles: MAIN, first: 1) {
    edges {
      node {
        id
        name
        role
        themeStoreId
        updatedAt
      }
    }
  }
}
  `,
    }) as any;

    const mainTheme = data.body.data.themes.edges[0].node;
    const themeData = await client.query({
      data: `query GetTheme {
  theme(id: "${mainTheme.id}") {
    id
    name
    role
    files {
      nodes {
        body {
          ... on OnlineStoreThemeFileBodyText {
            content
          }
        }
      }
    }
  }
}
`,
  }) as any;
    console.log(themeData.body.data.theme.files[0]);
    return mainTheme

}


export default getDefaultProjectInfo;
</file>

<file path="src/infra/external/shopify/index.ts">
/**
 * Shopify external service module
 * Exports all Shopify-related functionality
 */

export { shopifyConfig } from './config';
export { shopify, type ShopifyShop, type ShopifyOAuthResponse } from './service';
export { shopifyOAuth } from './oauth';
</file>

<file path="src/infra/external/shopify/oauth.ts">
import { shopify } from './service';
import { encrypt } from '../../encryption';
import { setInterval } from 'timers';

/**
 * Shopify OAuth service for handling OAuth flows
 * Includes state management for replay protection
 */
export class ShopifyOAuthService {
  private stateStore = new Map<string, { userId?: string; email?: string; timestamp: number }>();

  constructor() {
    // Clean up expired states every 10 minutes (states expire after 1 hour)
    setInterval(() => {
      const now = Date.now();
      for (const [state, data] of this.stateStore.entries()) {
        if (now - data.timestamp > 60 * 60 * 1000) { // 1 hour
          this.stateStore.delete(state);
        }
      }
    }, 10 * 60 * 1000); // 10 minutes
  }

  /**
   * Store state with user ID (for authenticated flows)
   */
  private setUserState(state: string, userId: string): void {
    this.stateStore.set(state, { userId, timestamp: Date.now() });
  }

  /**
   * Store state with email (for registration flows)
   */
  private setEmailState(state: string, email: string): void {
    this.stateStore.set(state, { email, timestamp: Date.now() });
  }

  /**
   * Get state data
   */
  private getState(state: string): { userId?: string; email?: string; timestamp: number } | undefined {
    return this.stateStore.get(state);
  }

  /**
   * Remove state (one-time use)
   */
  private removeState(state: string): void {
    this.stateStore.delete(state);
  }
  /**
   * Generate OAuth URL for shop connection
   */
  generateOAuthUrl(shop: string, state: string): string {
    return shopify.generateOAuthUrl(shop, state);
  }

  /**
   * Handle OAuth callback for authenticated users
   */
  async handleAuthenticatedCallback(
    code: string,
    shop: string,
    _hmac: string,
    state: string,
    userId: string
  ) {
    // Validate state parameter for replay protection
    const stateData = this.getState(state);
    if (!stateData || stateData.userId !== userId) {
      throw new Error('Invalid or expired state parameter');
    }

    // Remove state after validation (one-time use)
    this.removeState(state);

    // Validate OAuth parameters
    const validation = shopify.validateCallbackParams({ code, shop, hmac: _hmac, state });
    if (!validation.isValid) {
      throw new Error(validation.error);
    }

    // Exchange code for access token
    const tokenResponse = await shopify.exchangeCodeForToken(shop, code);
    
    // Fetch shop profile
    const shopProfile = await shopify.getShopProfile(shop, tokenResponse.access_token);
    
    // Encrypt the access token before storing
    const encryptedToken = encrypt(tokenResponse.access_token);

    return {
      shopProfile,
      encryptedToken,
    };
  }

  /**
   * Handle OAuth callback for registration flow
   */
  async handleRegistrationCallback(
    code: string,
    shop: string,
    _hmac: string,
    state: string
  ) {
    // Validate state parameter for replay protection
    const stateData = this.getState(state);
    if (!stateData?.email) {
      throw new Error('Invalid or expired state parameter');
    }

    // Remove state after validation (one-time use)
    this.removeState(state);

    // OAuth parameters are already validated in the route handler

    // Exchange code for access token
    const tokenResponse = await shopify.exchangeCodeForToken(shop, code);
    
    // Fetch shop profile
    const shopProfile = await shopify.getShopProfile(shop, tokenResponse.access_token);
    
    // Encrypt the access token before storing
    const encryptedToken = encrypt(tokenResponse.access_token);

    return {
      shopProfile,
      encryptedToken,
      email: stateData.email,
    };
  }

  /**
   * Generate state and OAuth URL for authenticated users
   */
  generateAuthenticatedOAuthUrl(shop: string, userId: string): { oauthUrl: string; state: string } {
    const state = this.generateState();
    this.setUserState(state, userId);
    const oauthUrl = this.generateOAuthUrl(shop, state);
    
    return { oauthUrl, state };
  }

  /**
   * Generate state and OAuth URL for registration flow
   */
  generateRegistrationOAuthUrl(shop: string, email: string): { oauthUrl: string; state: string } {
    const state = this.generateState();
    this.setEmailState(state, email);
    const oauthUrl = this.generateOAuthUrl(shop, state);
    
    return { oauthUrl, state };
  }

  private generateState(): string {
    const crypto = require('crypto');
    return crypto.randomBytes(16).toString('hex');
  }
}

export const shopifyOAuth = new ShopifyOAuthService();
</file>

<file path="src/infra/external/shopify/service.ts">
import { shopifyConfig } from './config';
import { decrypt, verifyHmac } from '../../encryption';
import fetch from 'node-fetch';
import { URLSearchParams } from 'url';

/**
 * Shopify service for API calls and shop profile management
 */

export interface ShopifyShop {
  id: number;
  name: string;
  email: string;
  domain: string;
  myshopify_domain: string;
  planName: string;
  currency: string;
  timezone: string;
  country: string;
  createdAt: string;
  updatedAt: string;
}

export interface ShopifyOAuthResponse {
  access_token: string;
  scope: string;
}

export class ShopifyService {
  /**
   * Exchange authorization code for access token
   */
  async exchangeCodeForToken(shop: string, code: string): Promise<ShopifyOAuthResponse> {
    const response = await fetch(`https://${shop}/admin/oauth/access_token`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        client_id: shopifyConfig.apiKey,
        client_secret: shopifyConfig.apiSecret,
        code,
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Failed to exchange code for token: ${response.status} ${errorText}`);
    }

    return response.json() as Promise<ShopifyOAuthResponse>;
  }

  /**
   * Fetch shop profile information
   */
  async getShopProfile(shop: string, accessToken: string): Promise<ShopifyShop> {
    const response = await fetch(`https://${shop}/admin/api/2024-01/shop.json`, {
      headers: {
        'X-Shopify-Access-Token': accessToken,
        'Content-Type': 'application/json',
      },
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Failed to fetch shop profile: ${response.status} ${errorText}`);
    }

    const data = await response.json() as { shop: ShopifyShop };
    return data.shop;
  }

  /**
   * Get shop profile using encrypted token from database
   */
  async getShopProfileWithEncryptedToken(shop: string, encryptedToken: string): Promise<ShopifyShop> {
    const accessToken = decrypt(encryptedToken);
    return this.getShopProfile(shop, accessToken);
  }

  /**
   * Generate Shopify OAuth URL
   */
  generateOAuthUrl(shop: string, state: string): string {
    const params = new URLSearchParams({
      client_id: shopifyConfig.apiKey,
      scope: "read_themes, write_themes",
      redirect_uri: shopifyConfig.redirectUri,
      state,
    });

    return `https://${shop}/admin/oauth/authorize?${params.toString()}`;
  }

  /**
   * Validate shop domain format
   */
  validateShopDomain(shop: string): boolean {
    // Shopify shop domains should be in format: shop-name.myshopify.com
    const shopifyDomainRegex = /^[a-zA-Z0-9][a-zA-Z0-9-]*\.myshopify\.com$/;
    return shopifyDomainRegex.test(shop);
  }

  /**
   * Normalize shop domain to ensure it has .myshopify.com suffix
   */
  normalizeShopDomain(shop: string): string {
    // If it's just the shop name, add .myshopify.com
    if (!shop.includes('.')) {
      return `${shop}.myshopify.com`;
    }

    // If it already has .myshopify.com, return as is
    if (shop.endsWith('.myshopify.com')) {
      return shop;
    }

    // If it's a custom domain, we can't normalize it
    throw new Error('Invalid shop domain format. Expected format: shop-name or shop-name.myshopify.com');
  }

  /**
   * Verify HMAC signature for OAuth callback
   */
  verifyHmacSignature(queryParams: Record<string, string>, hmac: string): boolean {
    const queryWithoutHmac = { ...queryParams };
    delete queryWithoutHmac.hmac;

    const queryStringWithoutHmac = Object.keys(queryWithoutHmac)
      .sort()
      .map(key => `${key}=${encodeURIComponent(queryWithoutHmac[key])}`)
      .join('&');

    return verifyHmac(queryStringWithoutHmac, shopifyConfig.apiSecret, hmac);
  }

  /**
   * Validate OAuth callback parameters
   */
  validateCallbackParams(query: Record<string, string>): {
    isValid: boolean;
    error?: string;
    params?: {
      code: string;
      shop: string;
      hmac: string;
      state: string;
    };
  } {
    const { code, shop, hmac, state } = query;

    if (!code || !shop || !hmac || !state) {
      return {
        isValid: false,
        error: 'Missing required parameters: code, shop, hmac, state',
      };
    }

    if (!this.validateShopDomain(shop)) {
      return {
        isValid: false,
        error: 'Invalid shop domain format',
      };
    }

    if (!this.verifyHmacSignature(query, hmac)) {
      return {
        isValid: false,
        error: 'Invalid HMAC signature',
      };
    }

    return {
      isValid: true,
      params: { code, shop, hmac, state },
    };
  }
}

export const shopify = new ShopifyService();
</file>

<file path="src/interfaces/http/utils/chat-utils.ts">
import { UIMessagePart } from 'ai';

/**
 * Extracts text content from UIMessage parts array
 */
export function extractTextFromParts(parts: UIMessagePart<any, any>[]): string {
    return parts
        .filter((part): part is UIMessagePart<any, any> & { type: 'text'; text: string } =>
            part.type === 'text' && 'text' in part)
        .map(part => part.text)
        .join('');
}
</file>

<file path="src/interfaces/http/screenshots.ts">
// Screenshot serving routes
import type { FastifyInstance } from 'fastify/types/instance.js';
import { serviceContainer } from '@app/container';

export async function screenshotRoutes(fastify: FastifyInstance) {
  // Serve database screenshots by ID
  fastify.get('/screenshots/db/:screenshotId', async (request, reply) => {
    try {
      const { screenshotId } = request.params as { screenshotId: string };
      
      // Validate screenshotId format (should be a cuid)
      if (!screenshotId || screenshotId.length < 20) {
        return reply.code(400).send({ error: 'Invalid screenshot ID' });
      }

      const screenshotStorage = serviceContainer.getScreenshotStorageService();
      const screenshot = await screenshotStorage.getScreenshotById(screenshotId);
      
      if (!screenshot) {
        return reply.code(404).send({ error: 'Screenshot not found' });
      }
      
      // Set appropriate headers
      reply.type(screenshot.contentType);
      reply.header('Cache-Control', 'public, max-age=3600'); // Cache for 1 hour
      
      // Send the screenshot data
      return reply.send(screenshot.data);
    } catch (error) {
      console.error(`[SCREENSHOT_ROUTES] Error serving database screenshot:`, error);
      return reply.code(404).send({ error: 'Screenshot not found' });
    }
  });

  // Health check for screenshots
  fastify.get('/screenshots/health', async (_request, reply) => {
    return reply.send({ 
      status: 'ok', 
      message: 'Screenshot service is running',
      timestamp: new Date().toISOString()
    });
  });
}
</file>

<file path="src/services/experiment-publisher.ts">
// Experiment Publisher Service
import { CloudflarePublisher, PublishedExperiment, PublishedVariant } from '@infra/external/cloudflare';
import { prisma } from '@infra/prisma';

export interface ExperimentPublisherService {
  publishExperiment(experimentId: string): Promise<{ success: boolean; error?: string }>;
  unpublishExperiment(experimentId: string): Promise<{ success: boolean; error?: string }>;
}

export class ExperimentPublisherServiceImpl implements ExperimentPublisherService {
  private cloudflarePublisher: CloudflarePublisher;

  constructor(cloudflarePublisher: CloudflarePublisher) {
    this.cloudflarePublisher = cloudflarePublisher;
  }

  async publishExperiment(experimentId: string): Promise<{ success: boolean; error?: string }> {
    console.log(`[EXPERIMENT_PUBLISHER] Starting publish process for experiment: ${experimentId}`);
    
    try {
      // Fetch experiment data from database
      console.log(`[EXPERIMENT_PUBLISHER] Fetching experiment data from database...`);
      const experiment = await prisma.experiment.findUnique({
        where: { id: experimentId },
        include: {
          hypothesis: true,
          traffic: true,
          variants: true,
        },
      });

      if (!experiment) {
        console.error(`[EXPERIMENT_PUBLISHER] Experiment not found: ${experimentId}`);
        return { success: false, error: 'Experiment not found' };
      }

      console.log(`[EXPERIMENT_PUBLISHER] Found experiment:`, {
        id: experiment.id,
        name: experiment.name,
        status: experiment.status,
        variantCount: experiment.variants.length,
        trafficCount: experiment.traffic.length
      });

      if (experiment.status !== 'DRAFT') {
        console.error(`[EXPERIMENT_PUBLISHER] Experiment ${experimentId} is not in DRAFT status: ${experiment.status}`);
        return { success: false, error: 'Only DRAFT experiments can be published' };
      }

      // Transform database data to published format
      console.log(`[EXPERIMENT_PUBLISHER] Transforming experiment data for Cloudflare...`);
      const publishedExperiment: PublishedExperiment = {
        id: experiment.id,
        projectId: experiment.projectId,
        name: experiment.name,
        status: 'RUNNING', // Published experiments are running
        oec: experiment.oec,
        traffic: this.buildTrafficDistribution(experiment.traffic),
        variants: this.buildVariants(experiment.variants),
      };

      console.log(`[EXPERIMENT_PUBLISHER] Transformed experiment data:`, {
        id: publishedExperiment.id,
        name: publishedExperiment.name,
        status: publishedExperiment.status,
        trafficDistribution: publishedExperiment.traffic,
        variantCount: Object.keys(publishedExperiment.variants).length
      });

      // Publish to Cloudflare
      console.log(`[EXPERIMENT_PUBLISHER] Publishing to Cloudflare...`);
      const result = await this.cloudflarePublisher.publishExperiment(publishedExperiment);

      if (result.success) {
        console.log(`[EXPERIMENT_PUBLISHER] Cloudflare publish successful, updating database status...`);
        // Update experiment status in database
        await prisma.experiment.update({
          where: { id: experimentId },
          data: { 
            status: 'RUNNING',
            publishedAt: new Date(),
          },
        });
        console.log(`[EXPERIMENT_PUBLISHER] Database status updated to RUNNING for experiment: ${experimentId}`);
      } else {
        console.error(`[EXPERIMENT_PUBLISHER] Cloudflare publish failed:`, result.error);
      }

      return { success: result.success, error: result.error };
    } catch (error) {
      console.error(`[EXPERIMENT_PUBLISHER] Failed to publish experiment ${experimentId}:`, error);
      console.error(`[EXPERIMENT_PUBLISHER] Error details:`, {
        message: error instanceof Error ? error.message : 'Unknown error',
        stack: error instanceof Error ? error.stack : undefined,
        experimentId
      });
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unknown error' 
      };
    }
  }

  async unpublishExperiment(experimentId: string): Promise<{ success: boolean; error?: string }> {
    console.log(`[EXPERIMENT_PUBLISHER] Starting unpublish process for experiment: ${experimentId}`);
    
    try {
      // Unpublish from Cloudflare
      console.log(`[EXPERIMENT_PUBLISHER] Unpublishing from Cloudflare...`);
      const result = await this.cloudflarePublisher.unpublishExperiment(experimentId);

      if (result.success) {
        console.log(`[EXPERIMENT_PUBLISHER] Cloudflare unpublish successful, updating database status...`);
        // Update experiment status in database
        await prisma.experiment.update({
          where: { id: experimentId },
          data: { status: 'DRAFT' },
        });
        console.log(`[EXPERIMENT_PUBLISHER] Database status updated to DRAFT for experiment: ${experimentId}`);
      } else {
        console.error(`[EXPERIMENT_PUBLISHER] Cloudflare unpublish failed:`, result.error);
      }

      return { success: result.success, error: result.error };
    } catch (error) {
      console.error(`[EXPERIMENT_PUBLISHER] Failed to unpublish experiment ${experimentId}:`, error);
      console.error(`[EXPERIMENT_PUBLISHER] Error details:`, {
        message: error instanceof Error ? error.message : 'Unknown error',
        stack: error instanceof Error ? error.stack : undefined,
        experimentId
      });
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Unknown error' 
      };
    }
  }

  private buildTrafficDistribution(traffic: any[]): Record<string, number> {
    const distribution: Record<string, number> = {};
    traffic.forEach(t => {
      distribution[t.variantId] = parseFloat(t.percentage.toString());
    });
    return distribution;
  }

  private buildVariants(variants: any[]): Record<string, PublishedVariant> {
    const variantMap: Record<string, PublishedVariant> = {};
    variants.forEach(v => {
      variantMap[v.variantId] = {
        selector: v.selector || 'body',
        html: v.html,
        css: v.css || '',
        position: v.position,
      };
    });
    return variantMap;
  }
}

export function createExperimentPublisherService(cloudflarePublisher: CloudflarePublisher): ExperimentPublisherService {
  return new ExperimentPublisherServiceImpl(cloudflarePublisher);
}
</file>

<file path="src/services/screenshot-storage.ts">
// Screenshot Storage Service
import { PrismaClient } from '@prisma/client';

// Constants for variant identification
const NON_VARIANT_ID = '__NON_VARIANT__';

export interface ScreenshotOptions {
  viewport: { width: number; height: number };
  fullPage: boolean;
  quality: number;
}

export interface ScreenshotStorageService {
  getScreenshot(
    projectId: string,
    pageType: 'home' | 'pdp' | 'about' | 'other',
    options: ScreenshotOptions
  ): Promise<string | null>;
  
  getScreenshotWithHtml(
    projectId: string,
    pageType: 'home' | 'pdp' | 'about' | 'other',
    options: ScreenshotOptions
  ): Promise<{ screenshot: string | null; html: string | null }>;
  
  saveScreenshot(
    projectId: string,
    pageType: 'home' | 'pdp' | 'about' | 'other',
    url: string,
    options: ScreenshotOptions,
    screenshotData: string,
    htmlContent?: string,
    variantId?: string
  ): Promise<string>; // Return screenshot ID
  
  cleanupExpiredScreenshots(): Promise<number>;
  
  getScreenshotStats(projectId: string): Promise<{
    totalScreenshots: number;
    totalSize: number;
    accessCount: number;
  }>;
  
  getScreenshotById(screenshotId: string): Promise<{
    data: Buffer;
    contentType: string;
  } | null>;
}

export class ScreenshotStorageServiceImpl implements ScreenshotStorageService {
  private prisma: PrismaClient;
  private maxAge: number = 24 * 60 * 60 * 1000; // 24 hours

  constructor(prisma: PrismaClient) {
    this.prisma = prisma;
  }

  async getScreenshot(
    projectId: string,
    pageType: 'home' | 'pdp' | 'about' | 'other',
    options: ScreenshotOptions
  ): Promise<string | null> {
    try {
      const screenshotRecord = await this.prisma.screenshot.findFirst({
        where: {
          projectId,
          pageType,
          variantId: NON_VARIANT_ID, // Only get non-variant screenshots
          viewportWidth: options.viewport.width,
          viewportHeight: options.viewport.height,
          fullPage: options.fullPage,
          quality: options.quality,
          expiresAt: { gt: new Date() }
        }
      });

      if (!screenshotRecord || !screenshotRecord.data) {
        console.log(`[SCREENSHOT_STORAGE] No screenshot found for ${pageType} page`);
        return null;
      }

      // Update access tracking
      await this.prisma.screenshot.update({
        where: { id: screenshotRecord.id },
        data: { 
          accessedAt: new Date(),
          accessCount: { increment: 1 }
        }
      });

      console.log(`[SCREENSHOT_STORAGE] Retrieved ${pageType} screenshot (${screenshotRecord.fileSize} bytes)`);
      return Buffer.from(screenshotRecord.data).toString('base64');
    } catch (error) {
      console.error('[SCREENSHOT_STORAGE] Error getting screenshot:', error);
      return null;
    }
  }

  async getScreenshotWithHtml(
    projectId: string,
    pageType: 'home' | 'pdp' | 'about' | 'other',
    options: ScreenshotOptions
  ): Promise<{ screenshot: string | null; html: string | null }> {
    try {
      const screenshotRecord = await this.prisma.screenshot.findFirst({
        where: {
          projectId,
          pageType,
          variantId: NON_VARIANT_ID, // Only get non-variant screenshots
          viewportWidth: options.viewport.width,
          viewportHeight: options.viewport.height,
          fullPage: options.fullPage,
          quality: options.quality,
          expiresAt: { gt: new Date() }
        }
      });

      if (!screenshotRecord || !screenshotRecord.data) {
        console.log(`[SCREENSHOT_STORAGE] No screenshot found for ${pageType} page`);
        return { screenshot: null, html: null };
      }

      // Update access tracking
      await this.prisma.screenshot.update({
        where: { id: screenshotRecord.id },
        data: { 
          accessedAt: new Date(),
          accessCount: { increment: 1 }
        }
      });

      const htmlSize = screenshotRecord.htmlContent ? screenshotRecord.htmlContent.length : 0;
      console.log(`[SCREENSHOT_STORAGE] Retrieved ${pageType} screenshot with HTML (${screenshotRecord.fileSize} bytes, HTML: ${htmlSize} chars)`);
      return {
        screenshot: Buffer.from(screenshotRecord.data).toString('base64'),
        html: screenshotRecord.htmlContent
      };
    } catch (error) {
      console.error('[SCREENSHOT_STORAGE] Error getting screenshot with HTML:', error);
      return { screenshot: null, html: null };
    }
  }

  async saveScreenshot(
    projectId: string,
    pageType: 'home' | 'pdp' | 'about' | 'other',
    url: string,
    options: ScreenshotOptions,
    screenshotData: string,
    htmlContent?: string,
    variantId?: string
  ): Promise<string> {
    try {
      const buffer = Buffer.from(screenshotData, 'base64');
      const expiresAt = new Date(Date.now() + this.maxAge);

      const result = await this.prisma.screenshot.upsert({
        where: {
          projectId_pageType_variantId_viewportWidth_viewportHeight_fullPage_quality: {
            projectId,
            pageType,
            variantId: variantId ?? NON_VARIANT_ID,
            viewportWidth: options.viewport.width,
            viewportHeight: options.viewport.height,
            fullPage: options.fullPage,
            quality: options.quality
          }
        },
        create: {
          projectId,
          url,
          pageType,
          variantId: variantId ?? NON_VARIANT_ID,
          viewportWidth: options.viewport.width,
          viewportHeight: options.viewport.height,
          fullPage: options.fullPage,
          quality: options.quality,
          data: buffer,
          htmlContent: htmlContent || null,
          fileSize: buffer.length,
          expiresAt
        },
        update: {
          data: buffer,
          htmlContent: htmlContent || undefined,
          fileSize: buffer.length,
          expiresAt,
          accessedAt: new Date()
        }
      });

      const htmlSize = htmlContent ? htmlContent.length : 0;
      console.log(`[SCREENSHOT_STORAGE] Saved ${pageType} screenshot (${buffer.length} bytes, HTML: ${htmlSize} chars) with ID: ${result.id}`);
      return result.id;
    } catch (error) {
      console.error('[SCREENSHOT_STORAGE] Error saving screenshot:', error);
      throw error;
    }
  }

  async cleanupExpiredScreenshots(): Promise<number> {
    try {
      const result = await this.prisma.screenshot.deleteMany({
        where: { expiresAt: { lt: new Date() } }
      });
      
      console.log(`[SCREENSHOT_CACHE] Cleaned up ${result.count} expired screenshots`);
      return result.count;
    } catch (error) {
      console.error('[SCREENSHOT_CACHE] Error cleaning up screenshots:', error);
      return 0;
    }
  }

  async getScreenshotStats(projectId: string): Promise<{
    totalScreenshots: number;
    totalSize: number;
    accessCount: number;
  }> {
    try {
      const stats = await this.prisma.screenshot.aggregate({
        where: { projectId },
        _count: { id: true },
        _sum: { fileSize: true, accessCount: true }
      });

      return {
        totalScreenshots: stats._count.id || 0,
        totalSize: stats._sum.fileSize || 0,
        accessCount: stats._sum.accessCount || 0
      };
    } catch (error) {
      console.error('[SCREENSHOT_STORAGE] Error getting screenshot stats:', error);
      return {
        totalScreenshots: 0,
        totalSize: 0,
        accessCount: 0
      };
    }
  }

  async getScreenshotById(screenshotId: string): Promise<{
    data: Buffer;
    contentType: string;
  } | null> {
    try {
      const screenshotRecord = await this.prisma.screenshot.findUnique({
        where: { id: screenshotId }
      });

      if (!screenshotRecord || !screenshotRecord.data) {
        console.log(`[SCREENSHOT_STORAGE] Screenshot not found: ${screenshotId}`);
        return null;
      }

      // Update access tracking
      await this.prisma.screenshot.update({
        where: { id: screenshotId },
        data: { 
          accessedAt: new Date(),
          accessCount: { increment: 1 }
        }
      });

      console.log(`[SCREENSHOT_STORAGE] Retrieved screenshot ${screenshotId} (${screenshotRecord.fileSize} bytes)`);
      return {
        data: Buffer.from(screenshotRecord.data),
        contentType: 'image/png'
      };
    } catch (error) {
      console.error('[SCREENSHOT_STORAGE] Error getting screenshot by ID:', error);
      return null;
    }
  }
}

// Factory function
export function createScreenshotStorageService(prisma: PrismaClient): ScreenshotStorageService {
  return new ScreenshotStorageServiceImpl(prisma);
}
</file>

<file path="src/index.ts">
import { startServer } from './app/server.js';

// Start the application
startServer();
</file>

<file path="src/domain/agent/tools/get-project-info.ts">
// @ts-nocheck 
// Get Project Info Tool
import { tool } from 'ai';
import { createProjectInfoService, type ProjectInfoService } from '@services/project-info';
import type { ProjectInfo } from '../types';
import { getProjectInfoSchema } from './schemas';

class GetProjectInfoExecutor {
  private projectInfoService: ProjectInfoService;
  private projectId: string;

  constructor(projectId: string) {
    this.projectInfoService = createProjectInfoService();
    this.projectId = projectId;
  }

  private async getProjectInfo(projectId: string): Promise<ProjectInfo> {
    return await this.projectInfoService.getProjectInfo(projectId);
  }

  async execute(input: { projectId?: string }): Promise<ProjectInfo> {
    console.log(`[PROJECT_INFO] Using project ID: ${this.projectId}`);
    return await this.getProjectInfo(this.projectId);
  }
}

export function createGetProjectInfoTool(projectId: string) {
  const executor = new GetProjectInfoExecutor(projectId);

  return tool({
    description: 'Get detailed information about the current project including Shopify store details and experiment statistics',
    inputSchema: getProjectInfoSchema,
    execute: async (input) => {
      try {
        return await executor.execute(input);
      } catch (error) {
        throw new Error(error instanceof Error ? error.message : 'Failed to fetch project information');
      }
    },
  });
}
</file>

<file path="src/features/brand_analysis/screenshot-analyzer.ts">
// Screenshot Analysis Service
import { generateObject } from 'ai';
import { google } from '@ai-sdk/google';
import { z } from 'zod';
import { getAIConfig } from '@shared/ai-config';

export interface ScreenshotAnalysisResult {
  visualStyle: {
    overallAesthetic: string;
    colorPalette: string[];
    typography: string;
    imagery: string;
  };
  brandElements: {
    logo: string;
    keyComponents: string[];
    layout: string;
  };
  brandPersonality: {
    adjectives: string[];
    targetAudience: string;
  };
}

const screenshotAnalysisSchema = z.object({
  overallAesthetic: z.string(),
  colorPalette: z.array(z.string()),
  typography: z.string(),
  imagery: z.string(),
  logo: z.string(),
  keyComponents: z.array(z.string()),
  layout: z.string(),
  adjectives: z.array(z.string()),
  targetAudience: z.string(),
});

export class ScreenshotAnalyzer {
  constructor() {}

  async analyzeScreenshots(screenshots: string[]): Promise<ScreenshotAnalysisResult> {
    const toDataUrl = (b64: string): string => {
      if (!b64) return '';
      if (b64.startsWith('data:')) return b64;
      return `data:image/png;base64,${b64}`;
    };

    // Validate screenshots before processing
    const validScreenshots = screenshots.filter(screenshot => {
      if (!screenshot || screenshot.trim() === '') {
        console.warn('[SCREENSHOT_ANALYZER] Skipping empty screenshot');
        return false;
      }
      
      // Check if it's a valid base64 string
      try {
        const base64Data = screenshot.startsWith('data:') 
          ? screenshot.split(',')[1] 
          : screenshot;
        
        // Basic base64 validation
        if (!/^[A-Za-z0-9+/]*={0,2}$/.test(base64Data)) {
          console.warn('[SCREENSHOT_ANALYZER] Skipping invalid base64 screenshot');
          return false;
        }
        
        // Check minimum length (very small images are likely corrupted)
        if (base64Data.length < 100) {
          console.warn('[SCREENSHOT_ANALYZER] Skipping screenshot that appears too small/corrupted');
          return false;
        }
        
        return true;
      } catch (error) {
        console.warn('[SCREENSHOT_ANALYZER] Error validating screenshot:', error);
        return false;
      }
    });

    if (validScreenshots.length === 0) {
      throw new Error('No valid screenshots available for analysis. All screenshots appear to be empty or corrupted.');
    }

    console.log(`[SCREENSHOT_ANALYZER] Processing ${validScreenshots.length} valid screenshots out of ${screenshots.length} total`);

    const prompt = this.buildScreenshotAnalysisPrompt();
    
    try {
      const aiConfig = getAIConfig();
      
      // Debug logging
      console.log('[SCREENSHOT_ANALYZER] AI Config:', {
        model: aiConfig.model,
        apiKeyLength: aiConfig.apiKey ? aiConfig.apiKey.length : 0,
        apiKeyPrefix: aiConfig.apiKey ? aiConfig.apiKey.substring(0, 10) + '...' : 'undefined',
        hasApiKey: !!aiConfig.apiKey
      });
      
      // Validate AI config
      if (!aiConfig.apiKey) {
        console.error('[SCREENSHOT_ANALYZER] Google API key is not configured. Available env vars:', {
          GOOGLE_API_KEY: process.env.GOOGLE_API_KEY ? 'set' : 'not set',
          GOOGLE_GENERATIVE_AI_API_KEY: process.env.GOOGLE_GENERATIVE_AI_API_KEY ? 'set' : 'not set'
        });
        throw new Error('Google API key is not configured');
      }
      
      if (!aiConfig.model) {
        throw new Error('Google model is not configured');
      }

      // Set the environment variable for Google SDK if not already set
      if (!process.env.GOOGLE_GENERATIVE_AI_API_KEY && aiConfig.apiKey) {
        process.env.GOOGLE_GENERATIVE_AI_API_KEY = aiConfig.apiKey;
        console.log('[SCREENSHOT_ANALYZER] Set GOOGLE_GENERATIVE_AI_API_KEY environment variable');
      }

      const result = await generateObject({
        model: google(aiConfig.model),
        schema: screenshotAnalysisSchema,
        messages: [
          {
            role: 'user',
            content: [
              { type: 'text', text: prompt },
              ...validScreenshots.map(screenshot => ({ 
                type: 'image' as const, 
                image: toDataUrl(screenshot) 
              }))
            ]
          }
        ]
      });

      const data = result.object;
      return {
        visualStyle: {
          overallAesthetic: data.overallAesthetic,
          colorPalette: data.colorPalette,
          typography: data.typography,
          imagery: data.imagery,
        },
        brandElements: {
          logo: data.logo,
          keyComponents: data.keyComponents,
          layout: data.layout,
        },
        brandPersonality: {
          adjectives: data.adjectives,
          targetAudience: data.targetAudience,
        }
      };
    } catch (error) {
      console.error('[SCREENSHOT_ANALYZER] Analysis failed:', error);
      
      // Provide more specific error messages
      if (error instanceof Error) {
        if (error.message.includes('Unable to process input image')) {
          throw new Error(`Failed to analyze screenshots: The AI service cannot process the provided images. This may be due to corrupted screenshot data or unsupported image format. Original error: ${error.message}`);
        } else if (error.message.includes('API key')) {
          throw new Error(`Failed to analyze screenshots: Google API configuration error. Please check your API key. Original error: ${error.message}`);
        } else if (error.message.includes('quota') || error.message.includes('limit')) {
          throw new Error(`Failed to analyze screenshots: API quota exceeded or rate limited. Please try again later. Original error: ${error.message}`);
        }
      }
      
      throw new Error(`Failed to analyze screenshots: ${error}`);
    }
  }

  private buildScreenshotAnalysisPrompt(): string {
    return `
# Visual Brand Analysis

Look at these screenshots and tell me about the brand's visual identity. Focus on what makes this brand unique visually.

## What to analyze:

**Visual Style:**
- What does the overall look and feel say about this brand?
- What are the main colors used?
- What kind of fonts/typography do you see?
- What style of images/photos are used?

**Key Brand Elements:**
- Describe the logo and branding
- What are the main visual components (headers, buttons, etc.)?
- How is the page laid out?

**Brand Personality:**
- What adjectives describe this brand's visual personality?
- Who do you think this brand is targeting based on the visuals?

Ignore any popup notifications about cookies or newsletters - focus on the main brand elements.
    `.trim();
  }
}
</file>

<file path="src/features/variant_generation/code-generator.ts">
// Code Generator for Variant Implementation
import { generateObject } from 'ai';
import { google } from '@ai-sdk/google';
import { z } from 'zod';
import { Hypothesis } from '@features/hypotheses_generation/types';
import { InjectionPoint } from './dom-analyzer';
import { getAIConfig } from '@shared/ai-config';

export interface CodeGenerationResult {
    css_code: string;
    html_code: string;
    injection_method: 'selector' | 'new_element' | 'modify_existing';
    target_selector?: string;
    new_element_html?: string;
    implementation_instructions: string;
}

const codeGenerationSchema = z.object({
    css_code: z.string().describe('CSS code to implement this variant'),
    html_code: z.string().describe('HTML code changes for this variant'),
    injection_method: z.enum(['selector', 'new_element', 'modify_existing']).describe('How to inject this code'),
    target_selector: z.string().optional().describe('CSS selector to target existing element (if injection_method is selector)'),
    new_element_html: z.string().optional().describe('Complete HTML for new element (if injection_method is new_element)'),
    implementation_instructions: z.string().describe('Step-by-step instructions for implementing this variant')
});

export class VariantCodeGenerator {
    async generateCode(
        variant: any, 
        hypothesis: Hypothesis, 
        brandAnalysis: string, 
        screenshot: string,
        injectionPoints: InjectionPoint[]
    ): Promise<CodeGenerationResult> {
        const codePrompt = `
You are a professional frontend developer working on conversion optimization for an e-commerce business. You are creating A/B test variants to help improve the store's performance and user experience.

CONTEXT: This is for legitimate business optimization - the store owner wants to test different design elements to improve conversion rates and user engagement.

VARIANT TO IMPLEMENT:
- Label: ${variant.variant_label}
- Description: ${variant.description}
- Rationale: ${variant.rationale}
- Implementation Notes: ${variant.implementation_notes}
- Accessibility: ${variant.accessibility_consideration}

ORIGINAL HYPOTHESIS:
- Hypothesis: ${hypothesis.hypothesis}
- Measurable Tests: ${hypothesis.measurable_tests}
- Success Metrics: ${hypothesis.success_metrics}

VALIDATED INJECTION POINTS (USE THESE SELECTORS):
${injectionPoints.map(point => `
- Type: ${point.type}
- Primary Selector: ${point.selector} (Confidence: ${point.confidence})
- Alternative Selectors: ${point.alternativeSelectors.join(', ')}
- Context: ${point.context}
- Reasoning: ${point.reasoning}
- Original Text Content: ${point.originalText || 'Not available'}
- Text Length: ${point.originalText ? point.originalText.length + ' characters' : 'Unknown'}
`).join('\n')}

INJECTION METHODS:
1. **selector**: Modify existing element using CSS selector (e.g., change button color)
2. **new_element**: Inject completely new HTML element (e.g., add new CTA banner)
3. **modify_existing**: Modify existing element's HTML structure (e.g., add wrapper div)

REQUIREMENTS:
1. **MUST USE VALIDATED SELECTORS**: Use the selectors provided in the injection points above. Do NOT generate your own selectors.
2. Generate CSS code that can be injected into a Shopify theme
3. Generate HTML code changes if needed
4. Determine the best injection method for this variant
5. Ensure the code is production-ready and follows best practices
6. Make sure the code is specific to the variant description
7. Consider the brand analysis context: ${brandAnalysis}
8. Code should be ready for A/B testing implementation

CRITICAL: Use the validated selectors from the injection points. The selectors have been analyzed and tested for reliability. Do not invent new selectors.

SELECTOR SELECTION RULES:
- Use the PRIMARY SELECTOR (highest confidence) from the injection points
- If multiple selectors are available, choose the one that best matches your variant's target element
- The target_selector field should be one of the validated selectors from above
- Do NOT create new selectors like .hero-cta.button

Return your response as a JSON object with:
- css_code: The complete CSS code for this variant
- html_code: ONLY static HTML content (no JavaScript). For text changes, use the actual HTML text content, not JavaScript code
- injection_method: How to inject this code (selector/new_element/modify_existing)
- target_selector: CSS selector to target existing element (if using selector method)
- new_element_html: Complete HTML for new element (if using new_element method)
- implementation_instructions: Step-by-step instructions for implementing this variant

CRITICAL HTML_CODE RULES:
- html_code should contain ONLY static HTML content (e.g., "New Button Text", "<span>New Text</span>")
- NEVER include JavaScript code in html_code (e.g., document.querySelector, innerHTML assignments)
- For text changes, just put the new text content directly
- For HTML structure changes, put the actual HTML elements
- If no HTML changes are needed, use an empty string ""

TEXT LENGTH CONSIDERATIONS:
- When changing button text or other UI text, consider the original text length
- Keep new text similar in length to the original (within 20% if possible)
- For buttons, prefer shorter, punchy text that fits well
- For longer text elements, ensure the new text doesn't overflow the container
- If the original text is very short (1-3 words), keep the new text similarly concise
- If the original text is longer, you can use slightly longer text but avoid excessive length
- Consider mobile responsiveness - shorter text works better on small screens

TEXT LENGTH EXAMPLES:
- Original: "Buy Now" (8 chars)  Good: "Shop Now" (9 chars) or "Get It" (6 chars)
- Original: "Add to Cart" (11 chars)  Good: "Add to Bag" (10 chars) or "Buy Now" (8 chars)
- Original: "Learn More" (10 chars)  Good: "Discover" (8 chars) or "See Details" (11 chars)
- Original: "Get Started" (11 chars)  Good: "Start Now" (9 chars) or "Begin" (5 chars)
- Avoid: "Get Started"  "Click here to get started with our amazing product" (too long!)

IMPORTANT: Return actual code, not descriptions. The code should be ready to implement for A/B testing.

CRITICAL: Return your response as a flat JSON object with the exact structure:
{
  "css_code": "your CSS code here",
  "html_code": "your HTML code here", 
  "injection_method": "selector",
  "target_selector": "your selector here",
  "new_element_html": "",
  "implementation_instructions": "your instructions here"
}

Do NOT wrap this in any other structure like {"type": "response", "properties": {...}}. Return ONLY the flat object above.
`;

        const aiConfig = getAIConfig();
        console.log(`[CODE_GENERATOR] Generating code for variant: ${variant.variant_label}`);
        console.log(`[CODE_GENERATOR] Using injection points:`, injectionPoints.map(p => ({ type: p.type, selector: p.selector, confidence: p.confidence })));
        
        try {
            const codeObject = await generateObject({
                model: google(aiConfig.model),
                schema: codeGenerationSchema,
                messages: [
                    {
                        role: 'user',
                        content: [
                            { type: "text", text: codePrompt },
                            { type: "text", text: brandAnalysis },
                            { type: "image", image: screenshot }
                        ]
                    }
                ]
            });

            console.log(`[CODE_GENERATOR] Generated code for variant: ${variant.variant_label} (${codeObject.object.css_code.length} chars CSS, ${codeObject.object.html_code.length} chars HTML)`);
            return codeObject.object;
        } catch (error) {
            console.error(`[CODE_GENERATOR] Error generating code for variant ${variant.variant_label}:`, error);
            // Return a fallback code result
            return {
                css_code: '',
                html_code: '',
                injection_method: 'selector' as const,
                target_selector: injectionPoints[0]?.selector || '',
                new_element_html: '',
                implementation_instructions: `Code generation failed. Please implement manually: ${variant.description}`
            };
        }
    }
}

// Factory function
export function createVariantCodeGenerator(): VariantCodeGenerator {
    return new VariantCodeGenerator();
}
</file>

<file path="src/infra/errors.ts">
import type { FastifyReply } from 'fastify/types/reply.js';
import { JsonWebTokenError, TokenExpiredError as JWTTokenExpiredError, NotBeforeError } from 'jsonwebtoken';

export class AuthError extends Error {
  constructor(
    public statusCode: number,
    public errorCode: string,
    message: string,
    public details?: unknown
  ) {
    super(message);
    this.name = 'AuthError';
  }
}

export class UnauthorizedError extends AuthError {
  constructor(message: string = 'Authentication required', details?: unknown) {
    super(401, 'UNAUTHORIZED', message, details);
  }
}

export class ForbiddenError extends AuthError {
  constructor(message: string = 'Access denied', details?: unknown) {
    super(403, 'FORBIDDEN', message, details);
  }
}

export class TokenExpiredError extends UnauthorizedError {
  constructor() {
    super('Token has expired. Please refresh your authentication.');
  }
}

export class InvalidTokenError extends UnauthorizedError {
  constructor() {
    super('Invalid token. Please authenticate again.');
  }
}

export class MissingTokenError extends UnauthorizedError {
  constructor() {
    super('No authentication token provided.');
  }
}

export class ProjectNotBoundError extends ForbiddenError {
  constructor() {
    super('No project bound to user. Please connect a project first.');
  }
}

export class ProjectOwnershipError extends ForbiddenError {
  constructor(projectId?: string) {
    super(
      projectId 
        ? `Access denied. You do not own project ${projectId}.`
        : 'Access denied. You do not own this project.'
    );
  }
}

// Cloudflare KV specific errors
export class CloudflareKVError extends Error {
  constructor(
    public statusCode: number,
    public errorCode: string,
    message: string,
    public details?: unknown
  ) {
    super(message);
    this.name = 'CloudflareKVError';
  }
}

export class KVValueWriteFailedError extends CloudflareKVError {
  constructor(experimentId: string, details?: unknown) {
    super(500, 'KV_VALUE_WRITE_FAILED', `Failed to write experiment ${experimentId} to KV store`, details);
  }
}

export class KVIndexWriteFailedError extends CloudflareKVError {
  constructor(experimentId: string, details?: unknown) {
    super(500, 'KV_INDEX_WRITE_FAILED', `Failed to update CONFIG_INDEX for experiment ${experimentId}`, details);
  }
}

export class KVConnectionError extends CloudflareKVError {
  constructor(details?: unknown) {
    super(503, 'KV_CONNECTION_ERROR', 'Failed to connect to Cloudflare KV', details);
  }
}

export class KVRateLimitError extends CloudflareKVError {
  constructor(retryAfter?: number, details?: unknown) {
    const errorDetails = details && typeof details === 'object' ? { retryAfter, ...details } : { retryAfter, details };
    super(429, 'KV_RATE_LIMIT_ERROR', 'Cloudflare KV rate limit exceeded', errorDetails);
  }
}

// PostHog specific errors
export class PostHogError extends Error {
  constructor(
    public statusCode: number,
    public errorCode: string,
    message: string,
    public details?: unknown
  ) {
    super(message);
    this.name = 'PostHogError';
  }
}

export class PostHogConnectionError extends PostHogError {
  constructor(details?: unknown) {
    super(503, 'POSTHOG_CONNECTION_ERROR', 'Failed to connect to PostHog', details);
  }
}

export class PostHogQueryError extends PostHogError {
  constructor(message: string, details?: unknown) {
    super(400, 'POSTHOG_QUERY_ERROR', message, details);
  }
}

export class PostHogRateLimitError extends PostHogError {
  constructor(retryAfter?: number, details?: unknown) {
    const errorDetails = details && typeof details === 'object' ? { retryAfter, ...details } : { retryAfter, details };
    super(429, 'POSTHOG_RATE_LIMIT_ERROR', 'PostHog rate limit exceeded', errorDetails);
  }
}

/**
 * Error handler for authentication and authorization errors
 */
export const handleAuthError = (error: unknown, reply: FastifyReply) => {
  if (error instanceof AuthError) {
    const response: Record<string, unknown> = {
      error: error.errorCode,
      message: error.message,
    };
    
    if (error.details && typeof error.details === 'object' && error.details !== null) {
      response.details = error.details;
    }
    
    return reply.status(error.statusCode).send(response);
  }

  // Handle JWT-specific errors using built-in classes
  if (error instanceof JWTTokenExpiredError) {
    return reply.status(401).send({
      error: 'UNAUTHORIZED',
      message: 'Token has expired. Please refresh your authentication.',
      details: {
        expiredAt: error.expiredAt,
      },
    });
  }

  if (error instanceof NotBeforeError) {
    return reply.status(401).send({
      error: 'UNAUTHORIZED',
      message: 'Token is not yet valid.',
      details: {
        notBefore: error.date,
      },
    });
  }

  if (error instanceof JsonWebTokenError) {
    return reply.status(401).send({
      error: 'UNAUTHORIZED',
      message: 'Invalid token. Please authenticate again.',
      details: {
        reason: error.message,
      },
    });
  }

  // Handle JWKS errors
  if (error && typeof error === 'object' && 'message' in error && typeof error.message === 'string' && error.message.includes('JWKS')) {
    return reply.status(500).send({
      error: 'INTERNAL_ERROR',
      message: 'Authentication service temporarily unavailable.',
    });
  }

  // Generic error fallback
  return reply.status(500).send({
    error: 'INTERNAL_ERROR',
    message: 'An unexpected error occurred.',
  });
};
</file>

<file path="src/interfaces/http/middleware/auth.ts">
import type { FastifyRequest } from 'fastify/types/request.js';
import type { FastifyReply } from 'fastify/types/reply.js';
import '@shared/fastify.d';
import { auth0Config } from '@infra/config/auth0';
import { handleAuthError } from '@infra/errors';
import jwksClient from 'jwks-rsa';
import jwt from 'jsonwebtoken';
import type { JwtPayload } from 'jsonwebtoken';

// FastifyRequest types are extended in @shared/fastify.d.ts

// Create JWKS client
const client = jwksClient({
  jwksUri: auth0Config.jwksUri,
  cache: true,
  rateLimit: true,
  jwksRequestsPerMinute: 5,
});

/**
 * Get signing key for JWT verification
 */
function getKey(header: jwt.JwtHeader, callback: jwt.SigningKeyCallback) {
  client.getSigningKey(header.kid, (err, key) => {
    if (err) {
      callback(err);
      return;
    }
    const signingKey = key?.getPublicKey();
    callback(null, signingKey);
  });
}

/**
 * Auth0 JWT verification middleware for Fastify
 * Verifies the JWT token and attaches user context to the request
 */
export const authMiddleware = async (request: FastifyRequest, reply: FastifyReply) => {
  try {
    // Extract the Authorization header
    const authHeader = request.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return reply.status(401).send({ 
        error: 'UNAUTHORIZED', 
        message: 'Missing or invalid authorization header' 
      });
    }

    const token = authHeader.substring(7); // Remove 'Bearer ' prefix

    // Verify the JWT token
    const payload = await new Promise<JwtPayload>((resolve, reject) => {
      jwt.verify(token, getKey, {
        audience: auth0Config.audience,
        issuer: auth0Config.issuer,
        algorithms: ['RS256'],
      }, (err, decoded) => {
        if (err) {
          reject(err);
        } else {
          resolve(decoded as JwtPayload);
        }
      });
    });

    if (!payload || typeof payload !== 'object') {
      return reply.status(401).send({ 
        error: 'UNAUTHORIZED', 
        message: 'Invalid token payload' 
      });
    }

    // Attach user context to request
    request.user = {
      sub: payload.sub as string,
      email: (payload.email as string) || '',
      email_verified: (payload.email_verified as boolean) || false,
    };

    // Get user from our database
    const { userService } = await import('@infra/dal/user');
    const user = await userService.getUserByAuth0Id(payload.sub as string);
    
    if (!user) {
      return reply.status(403).send({ 
        error: 'FORBIDDEN', 
        message: 'User not found. Please complete registration first.' 
      });
    }
    
    request.userId = user.id;

    // Get user's project ID (single project per user)
    if (user.project) {
      request.projectId = user.project.id;
    }

  } catch (error) {
    return handleAuthError(error, reply);
  }
};
</file>

<file path="src/interfaces/http/user/index.ts">
import type { FastifyInstance } from 'fastify/types/instance.js';
import '@shared/fastify.d';
import { authMiddleware } from '@interfaces/http/middleware/auth';
import { requireAuth } from '@interfaces/http/middleware/authorization';
import { userService } from '@infra/dal/user';

export async function userRoutes(fastify: FastifyInstance) {
    // Get current user info (protected - only requires authentication, not project binding)
    fastify.get('/me', { preHandler: [authMiddleware] }, async (request, reply) => {
        try {
            // Get full user data including project details
            const user = await userService.getUserById(request.userId!);

            if (!user) {
                return reply.status(404).send({
                    error: 'NOT_FOUND',
                    message: 'User not found',
                });
            }

            return {
                user: {
                    id: user.id,
                    email: user.email,
                    auth0Id: user.auth0Id,
                    project: user.project ? {
                        id: user.project.id,
                        shopDomain: user.project.shopDomain,
                        brandAnalysis: user.project.brandAnalysis,
                    } : null,
                },
            };
        } catch (error: unknown) {
            fastify.log.error({ err: error }, 'Get user info error:');
            return reply.status(500).send({
                error: 'INTERNAL_ERROR',
                message: 'Failed to fetch user information',
            });
        }
    });

    /**
     * Get user by ID
     */
    fastify.get('/:userId', { preHandler: [authMiddleware, requireAuth] }, async (request, reply) => {
        try {
            const { userId } = request.params as { userId: string };

            const user = await userService.getUserById(userId);

            if (!user) {
                return reply.status(404).send({
                    error: 'NOT_FOUND',
                    message: 'User not found',
                });
            }

            return {
                user: {
                    id: user.id,
                    email: user.email,
                    projectId: user.project?.id,
                },
                project: user.project ? {
                    id: user.project.id,
                    shopDomain: user.project.shopDomain,
                } : null,
            };

        } catch (error: unknown) {
            fastify.log.error({ err: error }, 'Get user error:');
            return reply.status(500).send({
                error: 'INTERNAL_ERROR',
                message: 'Failed to fetch user information',
            });
        }
    });

    /**
     * Update user email
     */
    fastify.patch('/:userId', { preHandler: [authMiddleware, requireAuth] }, async (request, reply) => {
        try {
            const { userId } = request.params as { userId: string };
            const { email } = request.body as { email: string };

            if (!email) {
                return reply.status(400).send({
                    error: 'BAD_REQUEST',
                    message: 'Email is required',
                });
            }

            // Validate email format
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!emailRegex.test(email)) {
                return reply.status(400).send({
                    error: 'BAD_REQUEST',
                    message: 'Invalid email format',
                });
            }

            const user = await userService.updateUserEmail(userId, email);

            return {
                message: 'User updated successfully',
                user: {
                    id: user.id,
                    email: user.email,
                    projectId: user.project?.id,
                },
            };

        } catch (error: unknown) {
            fastify.log.error({ err: error }, 'Update user error:');
            return reply.status(500).send({
                error: 'INTERNAL_ERROR',
                message: 'Failed to update user',
            });
        }
    });

    /**
     * Delete user
     */
    fastify.delete('/:userId', { preHandler: [authMiddleware, requireAuth] }, async (request, reply) => {
        try {
            const { userId } = request.params as { userId: string };

            await userService.deleteUser(userId);

            return {
                message: 'User deleted successfully',
            };

        } catch (error: unknown) {
            fastify.log.error({ err: error }, 'Delete user error:');
            return reply.status(500).send({
                error: 'INTERNAL_ERROR',
                message: 'Failed to delete user',
            });
        }
    });
}
</file>

<file path="src/interfaces/http/shopify.ts">
import type { FastifyInstance } from 'fastify/types/instance.js';
import '@shared/fastify.d';
import { authMiddleware } from '@interfaces/http/middleware/auth';
import { shopifyOAuth, shopify } from '@infra/external/shopify';
import { userService } from '@infra/dal/user';

export async function shopifyRoutes(fastify: FastifyInstance) {
  /**
   * Generate Shopify OAuth URL for store connection (for authenticated users)
   */
  fastify.post('/auth/shopify/connect', { preHandler: [authMiddleware] }, async (request, reply) => {
    try {
      const { shop } = request.body as { shop: string };

      if (!shop) {
        return reply.status(400).send({
          error: 'BAD_REQUEST',
          message: 'Shop domain is required',
        });
      }

      // Normalize shop domain
      const normalizedShop = shopify.normalizeShopDomain(shop);
      
      // Generate OAuth URL
      const { oauthUrl, state } = shopifyOAuth.generateAuthenticatedOAuthUrl(normalizedShop, request.userId!);

      return {
        oauthUrl,
        state,
        shop: normalizedShop,
      };

    } catch (error: unknown) {
      fastify.log.error({ err: error }, 'Shopify connect URL generation error:');

      if (error instanceof Error && error.message.includes('Invalid shop domain')) {
        return reply.status(400).send({
          error: 'BAD_REQUEST',
          message: error.message,
        });
      }

      return reply.status(500).send({
        error: 'INTERNAL_ERROR',
        message: 'Failed to generate Shopify OAuth URL',
      });
    }
  });

  /**
   * Shopify OAuth callback endpoint (for authenticated users)
   */
  fastify.get('/auth/shopify/callback', { preHandler: [authMiddleware] }, async (request, reply) => {
    try {
      // Validate OAuth callback parameters
      const validation = shopify.validateCallbackParams(request.query as Record<string, string>);
      
      if (!validation.isValid) {
        return reply.status(400).send({
          error: 'BAD_REQUEST',
          message: validation.error,
        });
      }

      const { code, shop, hmac, state } = validation.params!;

      // Handle OAuth callback
      const { shopProfile, encryptedToken } = await shopifyOAuth.handleAuthenticatedCallback(
        code, shop, hmac, state, request.userId!
      );
      
      // Bind project to user
      const user = await userService.bindProjectToUser(
        request.userId!,
        shopProfile.myshopify_domain,
        encryptedToken
      );

      // Return success response
      return {
        message: 'Shopify store connected successfully',
        shop: {
          id: shopProfile.id,
          name: shopProfile.name,
          domain: shopProfile.myshopify_domain,
          email: shopProfile.email,
          planName: shopProfile.planName,
          currency: shopProfile.currency,
          timezone: shopProfile.timezone,
          country: shopProfile.country,
        },
        project: user.project,
      };

    } catch (error: unknown) {
      fastify.log.error({ err: error }, 'Shopify OAuth callback error:');

      // Handle specific error cases
      if (error instanceof Error) {
        if (error.message.includes('already has a project')) {
          return reply.status(409).send({
            error: 'CONFLICT',
            message: error.message,
          });
        }

        if (error.message.includes('Invalid or expired state parameter')) {
          return reply.status(400).send({
            error: 'BAD_REQUEST',
            message: error.message,
          });
        }

        if (error.message.includes('Failed to exchange code')) {
          return reply.status(400).send({
            error: 'BAD_REQUEST',
            message: 'Invalid authorization code or shop domain',
          });
        }

        if (error.message.includes('Failed to fetch shop profile')) {
          return reply.status(400).send({
            error: 'BAD_REQUEST',
            message: 'Failed to fetch shop information. Please check your permissions.',
          });
        }
      }

      return reply.status(500).send({
        error: 'INTERNAL_ERROR',
        message: 'Failed to connect Shopify store',
      });
    }
  });
}
</file>

<file path="src/services/index.ts">
export * from './experiment-publisher';
export * from './project-info';
export * from './screenshot-storage';
export * from './screenshot-analytics';
export * from './variant-job-processor';
export * from './job-cleanup';
</file>

<file path="src/shared/fastify.d.ts">
/**
 * Fastify Type Augmentation
 * 
 * This file extends Fastify's built-in types to include our custom properties.
 * This is the proper way to extend FastifyRequest in TypeScript.
 */

import 'fastify';
import type { DiagnosticsService } from '../domain/analytics/diagnostics';

declare module 'fastify' {
  interface FastifyRequest {
    user?: {
      sub: string; // Auth0 user ID
      email: string;
      email_verified: boolean;
    };
    userId?: string; // Our internal user ID
    projectId?: string; // User's project ID
  }

  interface FastifyInstance {
    diagnosticsService: DiagnosticsService;
  }
}
</file>

<file path="src/shared/types.ts">
/**
 * Shared Type Definitions
 * 
 * This file contains all shared types used across the application.
 * Following Clean Architecture, these are framework-agnostic types.
 */

// Request parameter types
export interface ProjectParams {
  projectId: string;
}

// Request body types
export interface ProjectBody {
  projectId?: string;
}

// User context types
export interface UserContext {
  userId: string;
  projectId?: string;
}

// Auth0 user types
export interface Auth0User {
  id: string;
  email: string;
  project?: {
    id: string;
    shopDomain: string;
  };
}

// API response types
export interface ApiResponse<T = unknown> {
  data?: T;
  error?: string;
  message?: string;
}

export interface ApiError {
  error: string;
  message: string;
  details?: unknown;
}

// DSL Types for Experiments
export type ExperimentStatusType = 'draft' | 'running' | 'paused' | 'finished';

export type VariantId = 'A' | 'B' | 'C';

export type RenderPosition = 'inner' | 'outer' | 'before' | 'after';

export type ApplyMode = 'first' | 'all';

export interface ExperimentMatch {
  host?: string;
  path: string;
}

export interface ExperimentTraffic {
  A: number;
  B: number;
  C: number;
}

export interface ExperimentAssignment {
  cookieName: string;
  ttlDays: number;
}

export interface ExperimentRuntime {
  minDays: number;
  minSessionsPerVariant: number;
  endAt?: string; // ISO date string
}

export interface ExperimentAnalytics {
  posthog: {
    enabled: boolean;
    host: string;
  };
  eventProps: string[];
}

export interface ExperimentGuardrails {
  watch: ('lcp' | 'js_errors' | 'cls')[];
}

export interface VariantRender {
  position: RenderPosition;
  html: string;
  css?: string;
  oncePerResponse?: boolean;
}

export interface Variant {
  mode: 'render';
  render: VariantRender;
}

export interface ExperimentTarget {
  selector: string;
  apply: ApplyMode;
  variants: Record<VariantId, Variant>;
}

export interface ExperimentKPI {
  primary: string;
  secondary?: string[];
}

export interface ExperimentDSL {
  experimentId: string;
  projectId: string;
  name: string;
  status: ExperimentStatusType;
  match: ExperimentMatch;
  traffic: ExperimentTraffic;
  assignment: ExperimentAssignment;
  targets: ExperimentTarget[];
  kpi: ExperimentKPI;
  runtime: ExperimentRuntime;
  analytics: ExperimentAnalytics;
  guardrails?: ExperimentGuardrails;
}

// Validation Error Types
export type ValidationErrorCode =
  | 'INVALID_DSL_STRUCTURE'
  | 'INVALID_TRAFFIC'
  | 'INVALID_SELECTOR'
  | 'UNSAFE_HTML'
  | 'UNSCOPED_CSS'
  | 'LIMIT_EXCEEDED'
  | 'UNSAFE_OUTER_TARGET'
  | 'INVALID_VARIANT_COUNT'
  | 'INVALID_TARGET_COUNT'
  | 'INVALID_HTML_SIZE'
  | 'INVALID_CSS_SIZE'
  | 'INVALID_DSL_SIZE'
  | 'INVALID_ANALYTICS_HOST';

export interface ValidationError {
  code: ValidationErrorCode;
  message: string;
  field?: string;
  details?: unknown;
}

export interface ValidationResult {
  isValid: boolean;
  errors: ValidationError[];
}

// PostHog Analytics Types
export interface VariantMetrics {
  variantId: string;
  sessions: number;
  primaryKPI: {
    name: string;
    count: number;
    rate: number;
  };
  guardrails?: {
    lcp?: 'normal' | 'elevated';
    jsErrors?: 'normal' | 'elevated';
    cls?: 'normal' | 'elevated';
  };
}

export interface ExperimentStatus {
  state: 'draft' | 'running' | 'paused' | 'finished';
  traffic: Record<string, number>;
  variants: VariantMetrics[];
  leader?: string;
  liftVsA?: number;
  meta: {
    timeframe: {
      start: string;
      end: string;
    };
    denominator: 'pageviews';
    totalSessions: number;
  };
}
</file>

<file path="docker-compose.yml">
services:
  api:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "3001:3001"
    environment:
      - NODE_ENV=development
      - PORT=3001
      - DATABASE_URL=postgresql://postgres:password@postgres:5432/omen_db
      - CHROME_PATH=/usr/bin/chromium
    env_file:
      - .env 
    volumes:
      # Mount source code for hot reloading
      - ./src:/app/src
      - ./prisma:/app/prisma
      - ./tsconfig.json:/app/tsconfig.json
      - /app/node_modules
    depends_on:
      - postgres
    restart: unless-stopped
    command: sh -c "npx prisma migrate deploy && npm run dev"
          
  postgres:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=omen_db
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
    ports:
      - "5432:5432"
    volumes:
      - postgres_dev_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d omen_db"]
      interval: 2s
      timeout: 2s
      retries: 10
    restart: unless-stopped

volumes:
  postgres_dev_data:
</file>

<file path="src/domain/agent/tools/create-experiment.ts">
// @ts-nocheck 
import { tool } from 'ai';
import { z } from 'zod';
import { ExperimentDAL } from '@infra/dal';
import { hypothesisStateManager } from '../hypothesis-state-manager';
import { variantStateManager } from '../variant-state-manager';
import { prisma } from '@infra/prisma';
import { createExperimentPublisherService } from '@services/experiment-publisher';
import { createCloudflarePublisher } from '@infra/external/cloudflare';
import { getServiceConfig } from '@infra/config/services';

const createExperimentSchema = z.object({
  name: z.string().optional().describe('The name of the experiment - if not provided, will be auto-generated from the hypothesis'),
  hypothesis: z.object({
    hypothesis: z.string().describe('The hypothesis statement'),
    rationale: z.string().describe('The rationale behind the hypothesis'),
    measurable_tests: z.string().describe('What can be measured to test this hypothesis'),
    success_metrics: z.string().describe('The success metrics for this hypothesis'),
    oec: z.string().describe('The Overall Evaluation Criterion (OEC)'),
    accessibility_check: z.string().describe('Accessibility considerations for this hypothesis')
  }).optional().describe('The hypothesis object - if not provided, will use the most recently generated hypothesis from state'),
  variants: z.array(z.object({
    variant_label: z.string().describe('The label for this variant'),
    description: z.string().describe('Description of what this variant changes'),
    rationale: z.string().describe('Why this variant might improve performance'),
    accessibility_consideration: z.string().describe('Accessibility considerations for this variant'),
    implementation_notes: z.string().describe('Technical implementation details'),
    css_code: z.string().describe('CSS code for this variant'),
    html_code: z.string().describe('HTML code for this variant'),
    injection_method: z.enum(['selector', 'new_element', 'modify_existing']).describe('How to inject this code'),
    target_selector: z.string().optional().describe('CSS selector to target existing element'),
    new_element_html: z.string().optional().describe('Complete HTML for new element'),
    implementation_instructions: z.string().describe('Step-by-step implementation instructions'),
    screenshot: z.string().optional().describe('URL to the screenshot of the variant applied to the page')
  })).optional().describe('The variants to test - if not provided, will use the most recently generated variants from state'),
  jobIds: z.array(z.string()).optional().describe('Specific job IDs to load variants from - if provided, will load variants from these exact jobs instead of searching all project jobs')
});

//TODO: Remove implementation instructions

class CreateExperimentExecutor {
  private projectId: string;

  constructor(projectId: string) {
    this.projectId = projectId;
  }

  async execute(input: { 
    name?: string; 
    hypothesis?: any; 
    variants?: any[];
    jobIds?: string[];
  }): Promise<{ experimentId: string; status: string; message: string }> {
    console.log(`[EXPERIMENT_TOOL] ===== EXPERIMENT CREATION INPUT =====`);
    console.log(`[EXPERIMENT_TOOL] Full input received:`, JSON.stringify(input, null, 2));
    console.log(`[EXPERIMENT_TOOL] Input variants length:`, input.variants ? input.variants.length : 'undefined');
    
    // Get hypothesis from state manager (preferred) or input
    let hypothesis = hypothesisStateManager.getCurrentHypothesis();
    
    if (hypothesis) {
      console.log(`[EXPERIMENT_TOOL] Using hypothesis from state manager: "${hypothesis.hypothesis.substring(0, 50)}..."`);
    } else if (input.hypothesis) {
      console.log(`[EXPERIMENT_TOOL] Using hypothesis from input: "${input.hypothesis.hypothesis.substring(0, 50)}..."`);
      hypothesis = input.hypothesis;
    } else {
      console.log(`[EXPERIMENT_TOOL] No hypothesis available in state or input`);
      throw new Error('No hypothesis available. Please generate hypotheses first using the generate_hypotheses tool.');
    }

    // Get variants from state manager (preferred) or input
    let variants = variantStateManager.getCurrentVariants();
    
    console.log(`[EXPERIMENT_TOOL] State manager variants:`, variants ? `${variants.length} variants` : 'null');
    console.log(`[EXPERIMENT_TOOL] Input variants:`, input.variants ? `${input.variants.length} variants` : 'undefined');
    
    if (variants && variants.length > 0) {
      console.log(`[EXPERIMENT_TOOL] Using ${variants.length} variants from state manager`);
      console.log(`[EXPERIMENT_TOOL] Variant labels:`, variants.map(v => v.variant_label));
    } else if (input.variants && input.variants.length > 0) {
      console.log(`[EXPERIMENT_TOOL] Using ${input.variants.length} variants from input`);
      console.log(`[EXPERIMENT_TOOL] Input variant labels:`, input.variants.map(v => v.variant_label || 'unnamed'));
      variants = input.variants;
    } else {
      console.log(`[EXPERIMENT_TOOL] No variants available in state or input`);
      console.log(`[EXPERIMENT_TOOL] State manager has variants:`, variantStateManager.hasCurrentVariants());
      console.log(`[EXPERIMENT_TOOL] State manager variant count:`, variantStateManager.getCurrentVariantCount());
      
      // Try to load variants from completed jobs
      console.log(`[EXPERIMENT_TOOL] Attempting to load variants from completed jobs...`);
      try {
        let loadedVariants: any[] = [];
        
        // Priority 1: Use jobIds from input (most explicit)
        if (input.jobIds && input.jobIds.length > 0) {
          console.log(`[EXPERIMENT_TOOL] Loading variants from input job IDs:`, input.jobIds);
          loadedVariants = await variantStateManager.loadVariantsFromJobIds(input.jobIds);
        }
        // Priority 2: Use jobIds from state manager
        else {
          const currentJobIds = variantStateManager.getCurrentJobIds();
          if (currentJobIds && currentJobIds.length > 0) {
            console.log(`[EXPERIMENT_TOOL] Loading variants from state manager job IDs:`, currentJobIds);
            loadedVariants = await variantStateManager.loadVariantsFromJobIds(currentJobIds);
          } else {
            console.log(`[EXPERIMENT_TOOL] No specific job IDs found, falling back to all project jobs`);
            loadedVariants = await variantStateManager.loadVariantsFromJobs(this.projectId);
          }
        }
        
        if (loadedVariants && loadedVariants.length > 0) {
          console.log(`[EXPERIMENT_TOOL] Successfully loaded ${loadedVariants.length} variants from completed jobs`);
          console.log(`[EXPERIMENT_TOOL] Loaded variant labels:`, loadedVariants.map(v => v.variant_label));
          variants = loadedVariants;
        } else {
          console.log(`[EXPERIMENT_TOOL] No completed variant jobs found`);
          throw new Error('No variants available. Please generate variants first using the generate_variants tool.');
        }
      } catch (loadError) {
        console.error(`[EXPERIMENT_TOOL] Failed to load variants from jobs:`, loadError);
        throw new Error('No variants available. Please generate variants first using the generate_variants tool.');
      }
    }
    
    console.log(`[EXPERIMENT_TOOL] ======================================`);

    // Auto-generate experiment name from hypothesis if not provided
    let experimentName = input.name;
    if (!experimentName) {
      // Extract key words from hypothesis to create a meaningful name
      const hypothesisText = hypothesis.hypothesis.toLowerCase();
      let name = 'Button Optimization';
      
      if (hypothesisText.includes('button')) {
        if (hypothesisText.includes('contrast')) {
          name = 'Button Contrast Optimization';
        } else if (hypothesisText.includes('color')) {
          name = 'Button Color Optimization';
        } else if (hypothesisText.includes('size')) {
          name = 'Button Size Optimization';
        } else {
          name = 'Button Optimization';
        }
      } else if (hypothesisText.includes('cta') || hypothesisText.includes('call-to-action')) {
        name = 'CTA Optimization';
      } else if (hypothesisText.includes('form')) {
        name = 'Form Optimization';
      } else if (hypothesisText.includes('checkout')) {
        name = 'Checkout Optimization';
      } else if (hypothesisText.includes('navigation') || hypothesisText.includes('menu')) {
        name = 'Navigation Optimization';
      } else {
        name = 'Conversion Optimization';
      }
      
      experimentName = name;
      console.log(`[EXPERIMENT_TOOL] Auto-generated experiment name: "${experimentName}"`);
    } else {
      console.log(`[EXPERIMENT_TOOL] Using provided experiment name: "${experimentName}"`);
    }

    // Use hardcoded project ID for now
    const projectId = this.projectId;

    try {
      const experiment = await ExperimentDAL.createExperiment({
        projectId,
        name: experimentName,
        oec: hypothesis.oec || 'Improve conversion rate', // Default OEC
        minDays: 7, // Default minimum days
        minSessionsPerVariant: 1000 // Default minimum sessions
      });

      // Create hypothesis
      await prisma.experimentHypothesis.create({
        data: {
          experimentId: experiment.id,
          hypothesis: hypothesis.hypothesis,
          rationale: hypothesis.rationale,
          primaryKpi: hypothesis.success_metrics || 'conversion_rate'
        }
      });

      // Create traffic distribution (equal split for now)
      const variantIds = ['A', 'B', 'C'].slice(0, variants.length);
      const percentagePerVariant = 1.0 / variantIds.length;
      
      console.log(`[EXPERIMENT_TOOL] Creating traffic distribution for ${variants.length} variants`);
      for (let i = 0; i < variantIds.length; i++) {
        await prisma.experimentTraffic.create({
          data: {
            experimentId: experiment.id,
            variantId: variantIds[i],
            percentage: percentagePerVariant
          }
        });
      }

      // Create variants
      console.log(`[EXPERIMENT_TOOL] Creating ${variants.length} variants in database`);
      for (let i = 0; i < variants.length; i++) {
        const variant = variants[i];
        console.log(`[EXPERIMENT_TOOL] Creating variant ${i + 1}: ${variant.variant_label}`);
        console.log(`[EXPERIMENT_TOOL] Variant data:`, JSON.stringify({
          variant_label: variant.variant_label,
          target_selector: variant.target_selector,
          has_css: !!variant.css_code,
          has_html: !!variant.html_code,
          injection_method: variant.injection_method
        }, null, 2));
        
        await prisma.experimentVariant.create({
          data: {
            experimentId: experiment.id,
            variantId: variantIds[i],
            selector: variant.target_selector || 'body',
            html: variant.html_code || '',
            css: variant.css_code || '',
            position: 'INNER' // Default position
          }
        });
      }

      console.log(`[EXPERIMENT_TOOL] Experiment created successfully: ${experiment.id}`);

      // Publish to Cloudflare
      console.log(`[EXPERIMENT_TOOL] Publishing experiment to Cloudflare...`);
      try {
        const config = getServiceConfig();
        const cloudflarePublisher = createCloudflarePublisher(config.cloudflare);
        const experimentPublisher = createExperimentPublisherService(cloudflarePublisher);
        
        const publishResult = await experimentPublisher.publishExperiment(experiment.id);
        
        if (publishResult.success) {
          console.log(`[EXPERIMENT_TOOL] Experiment published to Cloudflare successfully`);
          return {
            experimentId: experiment.id,
            status: 'RUNNING',
            message: `Experiment "${experimentName}" has been created, saved to the database, and published to Cloudflare. It's now live and the SDK can load the variants.`
          };
        } else {
          console.error(`[EXPERIMENT_TOOL] Failed to publish to Cloudflare:`, publishResult.error);
          return {
            experimentId: experiment.id,
            status: experiment.status,
            message: `Experiment "${experimentName}" has been created and saved to the database, but failed to publish to Cloudflare: ${publishResult.error}. The experiment is in DRAFT status.`
          };
        }
      } catch (publishError) {
        console.error(`[EXPERIMENT_TOOL] Error publishing to Cloudflare:`, publishError);
        return {
          experimentId: experiment.id,
          status: experiment.status,
          message: `Experiment "${experimentName}" has been created and saved to the database, but failed to publish to Cloudflare: ${publishError instanceof Error ? publishError.message : 'Unknown error'}. The experiment is in DRAFT status.`
        };
      }
    } catch (error) {
      console.error(`[EXPERIMENT_TOOL] Failed to create experiment:`, error);
      throw new Error(`Failed to create experiment: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
}

export function createExperiment(projectId: string) {
  const executor = new CreateExperimentExecutor(projectId);

  return tool({
    description: 'Create an experiment in the database with the given hypothesis and variants. If you have job IDs from a previous generate_variants call, pass them in the jobIds parameter to load the specific variants from those jobs.',
    inputSchema: createExperimentSchema,
    execute: async (input) => {
      try {
        const result = await executor.execute(input);
        return result;
      } catch (error) {
        console.error(`[EXPERIMENT_TOOL] Tool execute failed:`, error);
        throw new Error(error instanceof Error ? error.message : 'Failed to create experiment');
      }
    },
  });
}
</file>

<file path="src/features/brand_analysis/url-selector.ts">
import { generateObject } from 'ai';
import { google } from '@ai-sdk/google';
import { z } from 'zod';
import { getAIConfig } from '@shared/ai-config';

export interface UrlSelectionResult {
    home: string;
    pdp: string;
    about: string;
}

export interface UrlWithType {
    url: string;
    pageType: 'home' | 'pdp' | 'about';
}

const urlSelectionSchema = z.object({
    home: z.string(),
    pdp: z.string(),
    about: z.string()
});

export class UrlSelector {
    constructor() { }

    async selectUrls(urls: string[]): Promise<UrlSelectionResult> {
        const systemText = `
        You are a professional brand analyst.
        For getting the clear picture of the brand, image and feeling of an e-commerce store we need you to analyze a collection of url's which we can then further analyze.
        You return the most useful navigation URLs for getting brand information that are stripped from an e-commerce homepage.
        From this collection you return the home page, one specific product to analyze the PDP and the about page.
        If any of the pages can't be found, return '' instead of making something up.

Rules:
- Use only internal links on the same domain as baseUrl.
- Normalize relative links to absolute using baseUrl.
- Choose the single best URL per category when possible.


The urls to select from are:
${urls.join('\n')}

Return ONLY valid JSON.`;

        try {
            const aiConfig = getAIConfig();
            const result = await generateObject({
                model: google(aiConfig.model),
                schema: urlSelectionSchema,
                messages: [
                    {
                        role: 'user',
                        content: systemText
                    }
                ]
            });

            const data = result.object;
            return data;
        } catch (error) {
            throw new Error(`Failed to get urls: ${error}`);

        }
    }

    /**
     * Convert URL selection result to an array of URLs with their page types
     */
    getUrlsWithTypes(selection: UrlSelectionResult): UrlWithType[] {
        const urlsWithTypes: UrlWithType[] = [];
        
        if (selection.home && selection.home.length > 0) {
            urlsWithTypes.push({ url: selection.home, pageType: 'home' });
        }
        
        if (selection.pdp && selection.pdp.length > 0) {
            urlsWithTypes.push({ url: selection.pdp, pageType: 'pdp' });
        }
        
        if (selection.about && selection.about.length > 0) {
            urlsWithTypes.push({ url: selection.about, pageType: 'about' });
        }
        
        return urlsWithTypes;
    }
}
</file>

<file path="src/features/crawler/types.ts">
// Web Crawler Service Types
export interface CrawlerService {
  crawlPage(url: string, options?: CrawlOptions): Promise<CrawlResult>;
  crawlMultiplePages(urls: string[], options?: CrawlOptions): Promise<CrawlResult[]>;
  takePartialScreenshot(url: string, viewport: { width: number, height: number }, fullPage: boolean, authentication?: { type: 'shopify_password'; password: string, shopDomain: string }): Promise<string>;
  takeVariantScreenshot(
    url: string, 
    variant: {
      css_code: string;
      html_code: string;
      injection_method: 'selector' | 'new_element' | 'modify_existing';
      target_selector?: string;
      new_element_html?: string;
    },
    viewport?: { width: number, height: number },
    authentication?: { type: 'shopify_password'; password: string, shopDomain: string }
  ): Promise<string>;
}

export interface CrawlResult {
  url: string;
  html: string;
  screenshot: string; // base64 encoded screenshot
  title?: string;
  description?: string;
  error?: string;
}

export interface CrawlOptions {
  viewport?: {
    width: number;
    height: number;
  };
  waitFor?: number; // milliseconds to wait after page load
  timeout?: number; // page load timeout
  userAgent?: string;
  screenshot?: {
    fullPage?: boolean;
    quality?: number;
  };
  authentication?: {
    type: 'shopify_password';
    password: string;
    shopDomain: string;
  };
}

export interface CrawlerConfig {
  headless?: boolean;
  defaultViewport?: {
    width: number;
    height: number;
  };
  defaultTimeout?: number;
  defaultWaitFor?: number;
}
</file>

<file path="src/infra/config/services.ts">
// Service Configuration
export interface ServiceConfig {
  // openai: {
  //   apiKey: string;
  //   model?: string;
  //   temperature?: number;
  //   maxTokens?: number;
  // };
  google: {
    apiKey: string;
    model?: string;
    temperature?: number;
    maxTokens?: number;
  };
  crawler: {
    headless?: boolean;
    defaultViewport?: {
      width: number;
      height: number;
    };
    defaultTimeout?: number;
    defaultWaitFor?: number;
  };
  posthog: {
    apiKey: string;
    host: string;
    projectId: string;
    timeout?: number;
    retryAttempts?: number;
  };
  cloudflare: {
    accountId: string;
    apiToken: string;
    namespaceId: string;
  };
}

export function getServiceConfig(): ServiceConfig {
  return {
    // openai: {
    //   apiKey: process.env.OPENAI_API_KEY || '',
    //   model: process.env.OPENAI_MODEL || 'gpt-4o',
    //   temperature: parseFloat(process.env.OPENAI_TEMPERATURE || '0.3'),
    //   maxTokens: parseInt(process.env.OPENAI_MAX_TOKENS || '2000'),
    // },
    google: {
      apiKey: process.env.GOOGLE_GENERATIVE_AI_API_KEY || '',
      model: process.env.GOOGLE_MODEL || 'gemini-2.5-flash',
      temperature: parseFloat(process.env.GOOGLE_TEMPERATURE || '0.7'),
      maxTokens: parseInt(process.env.GOOGLE_MAX_TOKENS || '1000'),
    },
    crawler: {
      headless: process.env.CRAWLER_HEADLESS !== 'false',
      defaultViewport: {
        width: parseInt(process.env.CRAWLER_VIEWPORT_WIDTH || '1280'),
        height: parseInt(process.env.CRAWLER_VIEWPORT_HEIGHT || '720'),
      },
      defaultTimeout: parseInt(process.env.CRAWLER_TIMEOUT || '30000'),
      defaultWaitFor: parseInt(process.env.CRAWLER_WAIT_FOR || '2000'),
    },
    posthog: {
      apiKey: process.env.POSTHOG_API_KEY || '',
      host: process.env.POSTHOG_HOST || 'https://eu.posthog.com',
      projectId: process.env.POSTHOG_PROJECT_ID || '',
      timeout: parseInt(process.env.POSTHOG_TIMEOUT || '10000'),
      retryAttempts: parseInt(process.env.POSTHOG_RETRY_ATTEMPTS || '3'),
    },
    cloudflare: {
      accountId: process.env.CLOUDFLARE_ACCOUNT_ID || '',
      apiToken: process.env.CLOUDFLARE_API_TOKEN || '',
      namespaceId: process.env.CLOUDFLARE_NAMESPACE_ID || '',
    },
  };
}
</file>

<file path="src/infra/dal/index.ts">
// Data Access Layer (DAL) - Centralized database operations
export * from './project';
export * from './experiment';
export * from './chat-message';
export * from './user';
export * from './variant-job';
export * from './types';
</file>

<file path="src/interfaces/http/user/register.ts">
import type { FastifyInstance } from 'fastify/types/instance.js';
import '@shared/fastify.d';
import { auth0 } from '@infra/external/auth0';
import { shopifyOAuth, shopify } from '@infra/external/shopify';
import { userService } from '@infra/dal/user';
import { prisma } from '@infra/prisma';
import { validateBody } from '@interfaces/http/middleware/validation';
import { UserRegistrationSchema, type UserRegistrationRequest } from './schemas';

export async function userRegistrationRoutes(fastify: FastifyInstance) {
    /**
     * Complete user registration flow
     * Step 1: Create user in Auth0 + Database + initiate Shopify OAuth
     */
    fastify.post('/register', {
        preHandler: validateBody(UserRegistrationSchema)
    }, async (request, reply) => {
        try {
            const { email, shop, password, firstName, lastName } = request.body as UserRegistrationRequest;

            // Normalize shop domain
            const normalizedShop = shopify.normalizeShopDomain(shop);
            
            // Check if user already exists in our database
            const existingUser = await prisma.user.findUnique({
                where: { email },
            });

            if (existingUser) {
                return reply.status(409).send({
                    error: 'CONFLICT',
                    message: 'User with this email already exists',
                });
            }

            // Step 1: Create user in Auth0 (or get existing)
            let auth0User;
            try {
                auth0User = await auth0.createUser(email, password);
            } catch (error: unknown) {
                if (
                    error instanceof Error &&
                    error.message.includes('User already exists')
                ) {
                    // User exists in Auth0, try to get them by email
                    const existingAuth0User = await auth0.getAuth0UserByEmail(email);
                    if (existingAuth0User) {
                        auth0User = existingAuth0User;
                    } else {
                        throw new Error('User exists in Auth0 but cannot be retrieved');
                    }
                } else {
                    throw error;
                }
            }

            // Step 2: Create user in our database
            const user = await userService.getOrCreateUser(auth0User.id, email, firstName, lastName);

            // Step 3: Generate OAuth URL for Shopify connection
            const { oauthUrl, state } = shopifyOAuth.generateRegistrationOAuthUrl(normalizedShop, email);

            return {
                message: 'User created successfully, proceed to Shopify OAuth',
                user: {
                    id: user.id,
                    email: user.email,
                    firstName: user.firstName,
                    lastName: user.lastName,
                    auth0Id: auth0User.id,
                },
                oauthUrl,
                state,
                shop: normalizedShop,
            };

        } catch (error: unknown) {
            fastify.log.error({ err: error }, 'User registration error:');

            if (error instanceof Error) {
                if (error.message.includes('User already exists')) {
                    return reply.status(409).send({
                        error: 'CONFLICT',
                        message: 'User with this email already exists',
                    });
                }
                if (error.message.includes('Invalid shop domain')) {
                    return reply.status(400).send({
                        error: 'BAD_REQUEST',
                        message: error.message,
                    });
                }
            }

            return reply.status(500).send({
                error: 'INTERNAL_ERROR',
                message: 'Failed to complete user registration',
            });
        }
    });

    /**
     * Complete user registration flow
     * Step 2: Handle Shopify OAuth callback and complete registration
     */
    fastify.get('/register/callback', async (request, reply) => {
        try {
            // Validate OAuth callback parameters
            const validation = shopify.validateCallbackParams(request.query as Record<string, string>);
            
            if (!validation.isValid) {
                return reply.status(400).send({
                    error: 'BAD_REQUEST',
                    message: validation.error,
                });
            }

            const { code, shop, hmac, state } = validation.params!;

            // Handle OAuth callback
            const { shopProfile, email, encryptedToken } = await shopifyOAuth.handleRegistrationCallback(
                code, shop, hmac, state
            );
            
            // Find the user by email and complete the registration
            const user = await prisma.user.findUnique({
                where: { email },
            });

            if (!user) {
                return reply.status(404).send({
                    error: 'NOT_FOUND',
                    message: 'User not found. Please try registration again.',
                });
            }

            // Create project and bind to user
            await userService.bindProjectToUser(
                user.id,
                shopProfile.myshopify_domain,
                encryptedToken
            );

            // Redirect to frontend login page with success
            const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:3000';
            const successUrl = `${frontendUrl}/login?success=true&shop=${encodeURIComponent(shopProfile.myshopify_domain)}`;
            
            return reply.redirect(successUrl);

        } catch (error: unknown) {
            fastify.log.error({ err: error }, 'User registration OAuth callback error:');

            // Redirect to frontend login page with error
            const frontendUrl = process.env.FRONTEND_URL || 'http://localhost:3000';
            const errorUrl = `${frontendUrl}/login?error=registration_failed`;
            
            return reply.redirect(errorUrl);
        }
    });
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "moduleResolution": "bundler",
    "lib": ["ES2022"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "resolveJsonModule": true,
    "incremental": true,
    "tsBuildInfoFile": "./dist/.tsbuildinfo",
    "types": ["node"],
    "typeRoots": ["./node_modules/@types", "./src/shared"],
    "baseUrl": "./src",
    "paths": {
      "@app/*": ["app/*"],
      "@config/*": ["config/*"],
      "@domain/*": ["domain/*"],
      "@features/*": ["features/*"],
      "@infra/*": ["infra/*"],
      "@interfaces/*": ["interfaces/*"],
      "@jobs/*": ["jobs/*"],
      "@services/*": ["services/*"],
      "@shared/*": ["shared/*"],
      "@tests/*": ["tests/*"]
    }
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
</file>

<file path="src/domain/agent/tools/schemas.ts">
// @ts-nocheck 
// Tool schemas and definitions
import { z } from 'zod';

export const getProjectInfoSchema = z.object({
  projectId: z.string().optional().describe('The project ID to get information for. If not provided, will use a default project.')
});

export const createHypothesesSchema = z.object({
  projectId: z.string().optional().describe('The project ID to generate hypotheses for (optional, will use default if not provided)'),
  url: z.string().optional().describe('The URL to analyze (optional, defaults to omen-mvp.myshopify.com)')
});

export const createVariantsSchema = z.object({
  hypothesis: z.object({
    hypothesis: z.string().describe('The hypothesis statement to test'),
    rationale: z.string().describe('The rationale behind the hypothesis'),
    measurable_tests: z.string().describe('What can be measured to test this hypothesis'),
    success_metrics: z.string().describe('The success metrics for this hypothesis'),
    oec: z.string().describe('The Overall Evaluation Criterion (OEC)'),
    accessibility_check: z.string().describe('Accessibility considerations for this hypothesis')
  }).optional().describe('The hypothesis object to generate variants for - if not provided, will use the most recently generated hypothesis from state')
});

export const getBrandAnalysisSchema = z.object({
  projectId: z.string().optional().describe('The project ID to get brand analysis for. If not provided, will use the current project.')
});

export const toolSchemas = {
  get_project_info: getProjectInfoSchema,
  generate_hypotheses: createHypothesesSchema,
  generate_variants: createVariantsSchema,
  get_brand_analysis: getBrandAnalysisSchema,
} as const;

export type ToolSchemas = typeof toolSchemas;
</file>

<file path="src/domain/agent/types.ts">
// Agent Domain Types

export interface AgentMessage {
  id: string;
  sessionId: string;
  role: 'USER' | 'AGENT' | 'TOOL' | 'SYSTEM';
  content: {
    text?: string;
    metadata?: Record<string, unknown>;
    toolCalls?: ToolCall[];
    toolCallId?: string;
  };
  createdAt: Date;
}

export interface ToolCall {
  id: string;
  type: 'function';
  function: {
    name: string;
    arguments: string;
  };
}

export interface ContentBlock {
  type: 'text' | 'tool-call' | 'tool-result' | 'image';
  text?: string;
  toolCallId?: string;
  toolName?: string;
  args?: Record<string, unknown>;
  result?: unknown;
  image?: { url: string };
}

export interface ChatMessage {
  role: 'system' | 'user' | 'assistant' | 'tool';
  content: string | ContentBlock[];
  name?: string;
  tool_calls?: ToolCall[];
  tool_call_id?: string;
}

export interface ChatCompletionResponse {
  content: string;
  toolCalls?: ToolCall[];
  usage?: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
}


export interface AgentConfig {
  systemPrompt?: string;
  maxContextMessages?: number;
  enableToolCalls?: boolean;
  enableWelcomeFlow?: boolean;
}


export interface ProjectInfo {
  id: string;
  shopDomain: string;
  shopName?: string;
  shopEmail?: string;
  shopPlan?: string;
  shopCurrency?: string;
  shopCountry?: string;
  experimentsCount: number;
  activeExperimentsCount: number;
}

export interface AgentService {
  sendMessageStream(message: string, projectId: string, conversationHistory?: any[]): Promise<{ stream: unknown; messageId: string }>;
}
</file>

<file path="src/features/variant_generation/dom-analyzer.ts">
// AI-Powered DOM Analysis Service for Variant Injection
import { generateObject } from 'ai';
import { google } from '@ai-sdk/google';
import { z } from 'zod';
import { CrawlerService } from '@features/crawler';
import { getAIConfig } from '@shared/ai-config';
import { PrismaClient } from '@prisma/client';
import { createScreenshotStorageService, ScreenshotStorageService } from '@services/screenshot-storage';
import { simplifyHTML, simplifyHTMLForForensics, getHtmlInfo } from '@shared/utils/html-simplifier';

// CSS selector validation utility
function isValidCSSSelector(selector: string): boolean {
  try {
    // Create a temporary element to test the selector
    const testElement = document.createElement('div');
    testElement.querySelector(selector);
    return true;
  } catch {
    return false;
  }
}

// Clean selector by removing invalid parts like :contains()
function cleanCSSSelector(selector: string): string {
  // Remove :contains() pseudo-selector and similar invalid selectors
  return selector
    .replace(/:contains\([^)]*\)/g, '') // Remove :contains() pseudo-selector
    .replace(/\s+/g, ' ') // Normalize whitespace
    .trim();
}

// Removed unused DOMAnalysisResult interface

export interface InjectionPoint {
  type: 'button' | 'text' | 'image' | 'container' | 'form' | 'navigation' | 'price' | 'title' | 'description';
  selector: string;
  confidence: number; // 0-1, how confident we are this selector will work
  description: string;
  boundingBox: {
    x: number;
    y: number;
    width: number;
    height: number;
  };
  alternativeSelectors: string[]; // Fallback selectors
  context: string; // What this element is used for (e.g., "main call-to-action button")
  reasoning: string; // Why this selector was chosen
  hypothesis: string; // The hypothesis this was found for
  url: string; // The URL this was found on
  timestamp: string; // When this was created
  tested: boolean; // Whether this selector has been tested
  successRate?: number; // Success rate if tested multiple times
  originalText?: string; // Original text content of the element (for text length considerations)
}

// Removed unused PageStructure interface

// Simplified schema for variant injection - only what we actually need
const elementFoundSchema = z.object({
  css_selector: z.string().describe('CSS selector that targets exactly 1 element'),
  element_text: z.string().optional().describe('Text content of the element if any'),
  section_context: z.string().optional().describe('Section or context where element was found'),
  confidence: z.number().min(0).max(1).describe('Confidence this selector will work (0-1)'),
  reasoning: z.string().describe('Why this selector was chosen')
});

const elementNotFoundSchema = z.object({
  NOT_FOUND: z.boolean().describe('True if element not found'),
  reason: z.string().describe('Why element was not found'),
  suggestions: z.array(z.string()).describe('Suggestions for finding similar elements')
});

const injectionPointSchema = z.union([elementFoundSchema, elementNotFoundSchema]);

// Removed unused schemas - we only need injectionPointSchema for this service
// Cache check

export interface DOMAnalyzerService {
  analyzeForHypothesis(
    url: string, 
    hypothesis: string,
    projectId: string,
    authentication?: { type: 'shopify_password'; password: string, shopDomain: string }
  ): Promise<InjectionPoint[]>;
  
  analyzeForHypothesisWithHtml(
    url: string, 
    hypothesis: string,
    projectId: string,
    htmlContent: string | null,
    authentication?: { type: 'shopify_password'; password: string, shopDomain: string }
  ): Promise<InjectionPoint[]>;
}

export class DOMAnalyzerServiceImpl implements DOMAnalyzerService {
  private screenshotStorage: ScreenshotStorageService;

  constructor(
    private crawlerService: CrawlerService,
    prisma: PrismaClient
  ) {
    this.screenshotStorage = createScreenshotStorageService(prisma);
  }

  async analyzeForHypothesisWithHtml(
    url: string, 
    hypothesis: string,
    projectId: string,
    htmlContent: string | null,
    authentication?: { type: 'shopify_password'; password: string, shopDomain: string }
  ): Promise<InjectionPoint[]> {
    console.log(`[DOM_ANALYZER] Starting analysis with provided HTML for hypothesis: ${hypothesis}`);
    
    // If we have HTML content, use it directly without crawling
    if (htmlContent) {
      console.log(`[DOM_ANALYZER] Using provided HTML content (${htmlContent.length} chars)`);
      
      // Optimize HTML for AI analysis (memory efficient)
      const optimizedHTML = this.optimizeHTMLForAnalysis(htmlContent, hypothesis);
      console.log(`[DOM_ANALYZER] Optimized HTML from ${htmlContent.length} to ${optimizedHTML.length} characters (${Math.round((1 - optimizedHTML.length / htmlContent.length) * 100)}% reduction)`);

      // Use AI to find specific injection points for this hypothesis
      const aiConfig = getAIConfig();
      const result = await generateObject({
        model: google(aiConfig.model),
        schema: injectionPointSchema,
        messages: [
          {
            role: 'user',
            content: [
              {
                type: 'text',
                text: `Analyze this HTML to find the EXACT element mentioned in the hypothesis for variant injection.

HYPOTHESIS: "${hypothesis}"

INSTRUCTIONS:
1. Look for the SPECIFIC element mentioned in the hypothesis (e.g., "Get waxy now" button, "Stay hydrated" section)
2. Find the exact CSS selector for that specific element
3. Do NOT select generic buttons or CTAs that are not mentioned in the hypothesis
4. Look for text content that matches what's described in the hypothesis
5. If the hypothesis mentions a specific section (like "Stay hydrated"), look within that section
6. Prioritize elements with the exact text mentioned in the hypothesis

Find the most specific and accurate selector for the element that needs to be modified according to the hypothesis.`
              },
              {
                type: 'text',
                text: `HTML Content:\n${optimizedHTML}`
              }
            ]
          }
        ]
      });

      // Process the simplified result
      const forensicsResult = result.object;
      
      // Check if element was found
      if ('NOT_FOUND' in forensicsResult && forensicsResult.NOT_FOUND === true) {
        console.log(`[DOM_ANALYZER] Element not found: ${forensicsResult.reason}`);
        console.log(`[DOM_ANALYZER] Suggestions:`, forensicsResult.suggestions);
        return []; // Return empty array if not found
      }
      
      // Type guard to ensure we have the success result
      if (!('css_selector' in forensicsResult)) {
        console.error(`[DOM_ANALYZER] Invalid response format from AI`);
        return [];
      }
      
      // Transform the result to InjectionPoint format
      const injectionPoint: InjectionPoint = {
        type: 'button', // Default type, could be enhanced based on element analysis
        selector: forensicsResult.css_selector,
        confidence: forensicsResult.confidence,
        description: forensicsResult.reasoning,
        boundingBox: {
          x: 0, // Will be filled by the crawler
          y: 0,
          width: 0,
          height: 0
        },
        alternativeSelectors: [], // Simplified - no alternatives needed
        context: forensicsResult.section_context || 'Element found',
        reasoning: forensicsResult.reasoning,
        hypothesis,
        url,
        timestamp: new Date().toISOString(),
        tested: false,
        originalText: forensicsResult.element_text || undefined
      };
      
      console.log(`[DOM_ANALYZER] Found element: ${forensicsResult.css_selector}`);
      return [injectionPoint];
    }
    
    // Fallback to regular analysis if no HTML provided
    console.log(`[DOM_ANALYZER] No HTML content provided, falling back to regular analysis`);
    return this.analyzeForHypothesis(url, hypothesis, projectId, authentication);
  }

  async analyzeForHypothesis(
    url: string, 
    hypothesis: string,
    projectId: string,
    authentication?: { type: 'shopify_password'; password: string, shopDomain: string }
  ): Promise<InjectionPoint[]> {
    console.log(`[DOM_ANALYZER] Analyzing page for hypothesis: "${hypothesis}"`);
    
    // Check storage first for both screenshot and HTML
    const pageType = this.getPageType(url);
    const cachedData = await this.screenshotStorage.getScreenshotWithHtml(
      projectId, 
      pageType, 
      { viewport: { width: 1920, height: 1080 }, fullPage: true, quality: 80 }
    );
    
    let crawlResult;
    if (cachedData.screenshot && cachedData.html) {
      console.log(`[DOM_ANALYZER] Using stored screenshot and HTML for ${pageType} page`);
      // We have both screenshot and HTML, no need to crawl
      crawlResult = {
        url,
        html: cachedData.html,
        screenshot: cachedData.screenshot,
        error: null
      };
    } else if (cachedData.screenshot) {
      console.log(`[DOM_ANALYZER] Using stored screenshot for ${pageType} page, but need to fetch HTML`);
      // We have screenshot but need HTML, so we need to crawl but without screenshot
      crawlResult = await this.crawlerService.crawlPage(url, {
        viewport: { width: 1920, height: 1080 },
        waitFor: 3000,
        screenshot: { fullPage: false, quality: 60 },
        authentication
      });
      // Use stored screenshot instead of crawled one
      crawlResult.screenshot = cachedData.screenshot;
      
      // Store the new HTML content
      if (crawlResult.html) {
        const simplifiedHtml = simplifyHTML(crawlResult.html);
        const screenshotId = await this.screenshotStorage.saveScreenshot(
          projectId, 
          pageType,
          url, 
          { viewport: { width: 1920, height: 1080 }, fullPage: true, quality: 80 },
          cachedData.screenshot!, // Use the cached screenshot
          simplifiedHtml
        );
        console.log(`[DOM_ANALYZER] HTML content saved with ID: ${screenshotId} (${getHtmlInfo(simplifiedHtml)})`);
      }
    } else {
      console.log(`[DOM_ANALYZER] Taking new screenshot and HTML for ${url}`);
      crawlResult = await this.crawlerService.crawlPage(url, {
        viewport: { width: 1920, height: 1080 },
        waitFor: 3000,
        screenshot: { fullPage: true, quality: 80 },
        authentication
      });
      
      // Store the new screenshot and HTML
      if (crawlResult.screenshot && crawlResult.html) {
        const simplifiedHtml = simplifyHTML(crawlResult.html);
        const screenshotId = await this.screenshotStorage.saveScreenshot(
          projectId, 
          pageType,
          url, 
          { viewport: { width: 1920, height: 1080 }, fullPage: true, quality: 80 },
          crawlResult.screenshot,
          simplifiedHtml
        );
        console.log(`[DOM_ANALYZER] Screenshot and HTML saved with ID: ${screenshotId} (${getHtmlInfo(simplifiedHtml)})`);
      }
    }

    if (crawlResult.error) {
      throw new Error(`Failed to crawl page: ${crawlResult.error}`);
    }


    // Optimize HTML for AI analysis (memory efficient)
    const optimizedHTML = this.optimizeHTMLForAnalysis(crawlResult.html, hypothesis);
    console.log(`[DOM_ANALYZER] Optimized HTML from ${crawlResult.html.length} to ${optimizedHTML.length} characters (${Math.round((1 - optimizedHTML.length / crawlResult.html.length) * 100)}% reduction)`);

    // Clear large HTML from memory before AI processing
    crawlResult.html = ''; // Free memory
    
    // Force garbage collection if available
    if (global.gc) {
      global.gc();
    }

    // Use AI to find specific injection points for this hypothesis
    const aiConfig = getAIConfig();
    const result = await generateObject({
      model: google(aiConfig.model),
      schema: injectionPointSchema,
      messages: [
        {
          role: 'user',
          content: [
            { 
              type: 'text', 
              text: this.buildHypothesisFocusedPrompt(hypothesis) 
            },
            { 
              type: 'text', 
              text: `HTML Content:\n${optimizedHTML}` 
            }
          ]
        }
      ]
    });

    // optimizedHTML will be garbage collected after this scope

    // Process the simplified result
    const forensicsResult = result.object;
    
    // Check if element was found
    if ('NOT_FOUND' in forensicsResult && forensicsResult.NOT_FOUND === true) {
      console.log(`[DOM_ANALYZER] Element not found: ${forensicsResult.reason}`);
      console.log(`[DOM_ANALYZER] Suggestions:`, forensicsResult.suggestions);
      return []; // Return empty array if not found
    }
    
    // Type guard to ensure we have the success result
    if (!('css_selector' in forensicsResult)) {
      console.error(`[DOM_ANALYZER] Invalid response format from AI`);
      return [];
    }
    
    // Clean the CSS selector
    const cleanedSelector = cleanCSSSelector(forensicsResult.css_selector);
    
    // Validate selector and log warnings for invalid ones
    if (!isValidCSSSelector(cleanedSelector)) {
      console.warn(`[DOM_ANALYZER] Invalid CSS selector detected: "${forensicsResult.css_selector}" -> cleaned to: "${cleanedSelector}"`);
    }
    
    // Transform the result to InjectionPoint format
    const injectionPoint: InjectionPoint = {
      type: 'button', // Default type, could be enhanced based on element analysis
      selector: cleanedSelector,
      confidence: forensicsResult.confidence,
      description: forensicsResult.reasoning,
      boundingBox: {
        x: 0, // Will be filled by the crawler
        y: 0,
        width: 0,
        height: 0
      },
      alternativeSelectors: [], // Simplified - no alternatives needed
      context: forensicsResult.section_context || 'Element found',
      reasoning: forensicsResult.reasoning,
      hypothesis,
      url,
      timestamp: new Date().toISOString(),
      tested: false,
      originalText: forensicsResult.element_text || undefined
    };

    console.log(`[DOM_ANALYZER] Found element: ${cleanedSelector}`);
    console.log(`[DOM_ANALYZER] Element details:`, {
      type: injectionPoint.type,
      selector: injectionPoint.selector,
      confidence: injectionPoint.confidence,
      reasoning: injectionPoint.reasoning.substring(0, 100) + '...'
    });

    return [injectionPoint];
  }

  private optimizeHTMLForAnalysis(html: string, hypothesis: string): string {
    // Extract key elements based on hypothesis keywords
    const hypothesisKeywords = this.extractKeywordsFromHypothesis(hypothesis);
    
    // Process HTML in chunks to reduce memory usage
    const chunkSize = 10000; // Process 10KB at a time
    const chunks = this.splitIntoChunks(html, chunkSize);
    
    let optimized = '';
    for (let i = 0; i < chunks.length; i++) {
      const chunk = chunks[i];
      
      // Process chunk with minimal memory operations
      const processedChunk = this.processHTMLChunk(chunk);
      optimized += processedChunk;
      
      // Force garbage collection hint for large chunks
      if (i % 5 === 0 && global.gc) {
        global.gc();
      }
    }
    
    // Extract relevant sections based on hypothesis (memory efficient)
    const relevantSections = this.extractRelevantSectionsEfficient(optimized, hypothesisKeywords);
    
    // Limit total size to prevent token overflow - further reduced for memory
    const maxLength = 15000; // ~3.5k tokens (reduced from 30k)
    if (relevantSections.length > maxLength) {
      return relevantSections.substring(0, maxLength) + '\n\n... [HTML truncated for analysis]';
    }
    
    return relevantSections;
  }

  private splitIntoChunks(str: string, chunkSize: number): string[] {
    const chunks = [];
    for (let i = 0; i < str.length; i += chunkSize) {
      chunks.push(str.substring(i, i + chunkSize));
    }
    return chunks;
  }

  private processHTMLChunk(chunk: string): string {
    // Use the forensics-specific HTML simplifier that preserves important attributes
    return simplifyHTMLForForensics(chunk);
  }

  private extractKeywordsFromHypothesis(hypothesis: string): string[] {
    const keywords = [];
    const text = hypothesis.toLowerCase();
    
    // Common e-commerce elements
    if (text.includes('button') || text.includes('cta') || text.includes('click')) {
      keywords.push('button', 'cta', 'click', 'submit', 'add to cart', 'buy now');
    }
    if (text.includes('price') || text.includes('cost') || text.includes('money')) {
      keywords.push('price', 'cost', 'money', 'dollar', 'euro', 'currency');
    }
    if (text.includes('title') || text.includes('heading') || text.includes('headline')) {
      keywords.push('title', 'heading', 'headline', 'h1', 'h2', 'h3');
    }
    if (text.includes('image') || text.includes('photo') || text.includes('picture')) {
      keywords.push('image', 'photo', 'picture', 'img', 'gallery');
    }
    if (text.includes('form') || text.includes('input') || text.includes('field')) {
      keywords.push('form', 'input', 'field', 'email', 'name', 'address');
    }
    if (text.includes('navigation') || text.includes('menu') || text.includes('nav')) {
      keywords.push('navigation', 'menu', 'nav', 'header', 'footer');
    }
    
    return keywords;
  }

  private extractRelevantSectionsEfficient(html: string, keywords: string[]): string {
    // Use a more memory-efficient approach with streaming
    const sections = new Set<string>(); // Use Set to avoid duplicates automatically
    
    // Always include the main structure (single regex)
    const mainMatch = html.match(/<main[^>]*>[\s\S]*?<\/main>/i);
    if (mainMatch) sections.add(mainMatch[0]);
    
    // Process keywords one at a time to avoid memory spikes
    for (const keyword of keywords) {
      // Use a more targeted regex that's less memory intensive
      const regex = new RegExp(`<[^>]*${this.escapeRegex(keyword)}[^>]*>[\s\S]{0,2000}?<\/[^>]*>`, 'gi');
      let match;
      while ((match = regex.exec(html)) !== null) {
        sections.add(match[0]);
        // Limit matches per keyword to prevent memory overflow
        if (sections.size > 20) break;
      }
      // Clear regex state
      regex.lastIndex = 0;
    }
    
    // Include header and footer for context (single regex each)
    const headerMatch = html.match(/<header[^>]*>[\s\S]*?<\/header>/i);
    if (headerMatch) sections.add(headerMatch[0]);
    
    const footerMatch = html.match(/<footer[^>]*>[\s\S]*?<\/footer>/i);
    if (footerMatch) sections.add(footerMatch[0]);
    
    // Convert Set to Array and join (memory efficient)
    return Array.from(sections).join('\n\n');
  }

  private escapeRegex(string: string): string {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  private buildHypothesisFocusedPrompt(hypothesis: string): string {
    return `You are a DOM analysis assistant. Find the exact element mentioned in the hypothesis and return a CSS selector that targets exactly 1 element.

HYPOTHESIS: "${hypothesis}"

INSTRUCTIONS:
1. Find the SPECIFIC element mentioned in the hypothesis (exact text, section, or unique attributes)
2. If a section is named (e.g., "Stay hydrated"), find that section first, then the element within it
3. Return a CSS selector that targets exactly 1 element
4. Prefer stable attributes: data-testid, id, aria-*, role over class names
5. If using text, match exactly (case-insensitive, trimmed)
6. Never use generic selectors like .btn, .button unless anchored to a unique parent

OUTPUT FORMAT:
- If found: Return JSON with css_selector, element_text (if any), section_context, confidence (0-1), and reasoning
- If not found: Return JSON with NOT_FOUND: true, reason, and suggestions array

EXAMPLE:
Hypothesis: "Change the 'Get waxy now' button in the 'Stay hydrated' section"
 Find section with "Stay hydrated", then button with "Get waxy now" text`;
  }

  private getPageType(url: string): 'home' | 'pdp' | 'about' | 'other' {
    const urlLower = url.toLowerCase();
    
    // Check for product pages first
    if (urlLower.includes('/products/') || urlLower.includes('/collections/')) {
      return 'pdp';
    }
    
    // Check for about pages
    if (urlLower.includes('/about')) {
      return 'about';
    }
    
    // Check for home page - this should be the most common case
    // Home page is typically just the domain or domain with trailing slash
    const urlObj = new URL(url);
    const pathname = urlObj.pathname;
    
    // If no path or just a trailing slash, it's the home page
    if (!pathname || pathname === '/' || pathname === '') {
      return 'home';
    }
    
    // If path is just common home page indicators
    if (pathname === '/home' || pathname === '/index' || pathname === '/index.html') {
      return 'home';
    }
    
    return 'other';
  }
}

// Factory function
export function createDOMAnalyzer(crawler: CrawlerService, prisma: PrismaClient): DOMAnalyzerService {
  return new DOMAnalyzerServiceImpl(crawler, prisma);
}
</file>

<file path="src/infra/dal/project.ts">
// Project Data Access Layer
import { prisma } from '@infra/prisma';
import type { Project, ProjectWithRelations } from './types';

export class ProjectDAL {
  /**
   * Get project for a specific user (single project per user rule)
   */
  static async getProjectForUser(userId: string): Promise<Project | null> {
    return await prisma.project.findUnique({
      where: { userId },
    });
  }

  /**
   * Get project with all relations (experiments, chat messages)
   */
  static async getProjectWithRelations(projectId: string): Promise<ProjectWithRelations | null> {
    return await prisma.project.findUnique({
      where: { id: projectId },
      include: {
        experiments: {
          orderBy: { createdAt: 'desc' },
        },
        chatMessages: {
          orderBy: { createdAt: 'desc' },
        },
      },
    });
  }

  /**
   * Get project by ID
   */
  static async getProjectById(projectId: string): Promise<Project | null> {
    return await prisma.project.findUnique({
      where: { id: projectId },
    });
  }

  /**
   * Get project by shop domain
   */
  static async getProjectByShopDomain(shopDomain: string): Promise<Project | null> {
    return await prisma.project.findUnique({
      where: { shopDomain },
    });
  }

  /**
   * Create a new project
   */
  static async createProject(data: {
    userId: string;
    shopDomain: string;
    accessTokenEnc: string;
  }): Promise<Project> {
    return await prisma.project.create({
      data,
    });
  }

  /**
   * Update project access token
   */
  static async updateProjectAccessToken(
    projectId: string,
    accessTokenEnc: string
  ): Promise<Project> {
    return await prisma.project.update({
      where: { id: projectId },
      data: { accessTokenEnc },
    });
  }

  /**
   * Update project brand analysis
   */
  static async updateProjectBrandAnalysis(
    projectId: string,
    brandAnalysis: any
  ): Promise<Project> {
    return await prisma.project.update({
      where: { id: projectId },
      data: { brandAnalysis: brandAnalysis },
    });
  }

  /**
   * Get project brand analysis
   */
  static async getProjectBrandAnalysis(
    projectId: string
  ): Promise<string | null> {
    const project = await prisma.project.findUnique({
      where: { id: projectId },
      select: { brandAnalysis: true },
    });
    const brandAnalysis = JSON.stringify(project?.brandAnalysis) ?? null;
    console.log(`[PROJECT_BRAND_ANALYSIS] Retrieved brand analysis: ${brandAnalysis ? `${brandAnalysis.length} chars` : 'null'}`);
    return brandAnalysis;
  }

  /**
   * Delete project (cascade will handle related records)
   */
  static async deleteProject(projectId: string): Promise<void> {
    await prisma.project.delete({
      where: { id: projectId },
    });
  }

  /**
   * Check if user has a project
   */
  static async userHasProject(userId: string): Promise<boolean> {
    const project = await prisma.project.findUnique({
      where: { userId },
      select: { id: true },
    });
    return project !== null;
  }

  /**
   * Create a brand summary job
   */
  static async createBrandSummaryJob(projectId: string): Promise<{ id: string }> {
    const job = await prisma.brandSummaryJob.create({
      data: {
        projectId,
        status: 'PENDING',
        progress: 0,
      },
    });
    return { id: job.id };
  }

  /**
   * Get brand summary job status
   */
  static async getBrandSummaryJob(jobId: string) {
    return await prisma.brandSummaryJob.findUnique({
      where: { id: jobId },
    });
  }
}
</file>

<file path="src/interfaces/http/middleware/authorization.ts">
import type { FastifyRequest } from 'fastify/types/request.js';
import type { FastifyReply } from 'fastify/types/reply.js';
import '@shared/fastify.d';
import type { ProjectParams, ProjectBody } from '@shared/types';

/**
 * Authorization guard middleware
 * Ensures all protected routes require projectId ownership
 */
export const requireAuth = async (request: FastifyRequest, reply: FastifyReply) => {
  if (!request.userId) {
    return reply.status(401).send({
      error: 'UNAUTHORIZED',
      message: 'Authentication required'
    });
  }

  // If no projectId in request context, user needs to bind a project first
  if (!request.projectId) {
    return reply.status(403).send({
      error: 'FORBIDDEN',
      message: 'No project bound to user. Please connect a project first.'
    });
  }
};

/**
 * Authorization guard for project-specific operations
 * Ensures user owns the specified project
 */
export const requireProjectOwnership = async (request: FastifyRequest, reply: FastifyReply) => {
  if (!request.userId) {
    return reply.status(401).send({
      error: 'UNAUTHORIZED',
      message: 'Authentication required'
    });
  }

  // Extract projectId from route params or body
  const projectId = (request.params as ProjectParams)?.projectId || (request.body as ProjectBody)?.projectId;

  if (!projectId) {
    return reply.status(400).send({
      error: 'BAD_REQUEST',
      message: 'Project ID is required'
    });
  }

  // Check if user owns this project
  const { userService } = await import('@infra/dal/user');
  const ownsProject = await userService.userOwnsProject(request.userId, projectId);

  if (!ownsProject) {
    return reply.status(403).send({
      error: 'FORBIDDEN',
      message: 'Access denied. You do not own this project.'
    });
  }

  // Attach projectId to request context for downstream handlers
  request.projectId = projectId;
};

/**
 * Optional project ownership check
 * Used for routes that can work with or without a specific project
 */
export const optionalProjectOwnership = async (request: FastifyRequest, reply: FastifyReply) => {
  if (!request.userId) {
    return reply.status(401).send({
      error: 'UNAUTHORIZED',
      message: 'Authentication required'
    });
  }

  const projectId = (request.params as ProjectParams)?.projectId || (request.body as ProjectBody)?.projectId;

  if (projectId) {
    const { userService } = await import('@infra/dal/user');
    const ownsProject = await userService.userOwnsProject(request.userId, projectId);

    if (!ownsProject) {
      return reply.status(403).send({
        error: 'FORBIDDEN',
        message: 'Access denied. You do not own this project.'
      });
    }

    request.projectId = projectId;
  }
};
</file>

<file path="src/app/server.ts">
import 'dotenv/config';
import fastify from 'fastify';
import type { FastifyInstance } from 'fastify';
import { prisma } from '@infra/prisma';
import { registerRoutes } from '@interfaces/http/index';
import { serviceContainer } from '@app/container';
import { createJobCleanupService } from '@services/job-cleanup';

export async function createServer(): Promise<{ server: FastifyInstance; httpServer: any }> {
    // Create Fastify instance
    const server: FastifyInstance = fastify({
        logger: process.env.NODE_ENV === 'development' ? {
            level: 'info',
            transport: {
                target: 'pino-pretty',
                options: {
                    colorize: true,
                    translateTime: 'HH:MM:ss',
                    ignore: 'pid,hostname'
                }
            }
        } : true
    });

    // Register CORS for Auth0 integration
    await server.register(import('@fastify/cors'), {
        origin: true, //TODO: Configure this properly for production
        credentials: true,
    });

    // Register services with Fastify
    await server.register(registerRoutes, { prefix: '/api' });

    // Get the underlying HTTP server from Fastify
    const httpServer = server.server;

    return { server, httpServer };
}

export async function startServer(): Promise<void> {
    try {
        const { server } = await createServer();
        const port = parseInt(process.env.PORT || '3000', 10);
        const host = process.env.HOST || '0.0.0.0';

        // Start the Fastify server
        await server.listen({ port, host });

        // Start job cleanup service
        const jobCleanupService = createJobCleanupService(prisma);
        jobCleanupService.startCleanup();

        // Graceful shutdown
        const gracefulShutdown = async (): Promise<void> => {
            jobCleanupService.stopCleanup();
            await serviceContainer.cleanup();
            await prisma.$disconnect();
            await server.close();
        };

        process.on('SIGINT', gracefulShutdown);
        process.on('SIGTERM', gracefulShutdown);
    } catch (err) {
        console.error(err);
        process.exit(1);
    }
}
</file>

<file path="src/domain/agent/tools/generate-hypotheses.ts">
// @ts-nocheck 
import { tool } from 'ai';
import { createHypothesesSchema } from './schemas';
import { createHypothesesGenerationService, HypothesesGenerationService } from '@features/hypotheses_generation/hypotheses-generation';
import { HypothesesGenerationResult } from '@features/hypotheses_generation/hypotheses-generation';
import { createPlaywrightCrawler } from '@features/crawler';
import { getServiceConfig } from '@infra/config/services';
import { hypothesisStateManager } from '../hypothesis-state-manager';
import { PrismaClient } from '@prisma/client';

class GenerateHypothesesExecutor {
    private hypothesesGenerationService: HypothesesGenerationService;
    private projectId: string;
    private prisma: PrismaClient;

    constructor(projectId: string) {
        this.projectId = projectId;
        this.prisma = new PrismaClient();
        const config = getServiceConfig();
        const crawler = createPlaywrightCrawler(config.crawler);
        this.hypothesesGenerationService = createHypothesesGenerationService(crawler, this.prisma);
    }

    private async generateHypotheses(url: string, projectId: string): Promise<HypothesesGenerationResult> {
        return await this.hypothesesGenerationService.generateHypotheses(url, projectId);
    }

    async execute(input: { projectId?: string; url?: string }): Promise<HypothesesGenerationResult> {
        // Use provided URL or default, and use injected project ID
        const url = input.url || 'https://omen-mvp.myshopify.com';
        console.log(`[HYPOTHESES_TOOL] Generating hypotheses for ${url} with project ${this.projectId}`);
        
        const result = await this.generateHypotheses(url, this.projectId);
        
        console.log(`[HYPOTHESES_TOOL] Result structure: ${result.hypotheses ? result.hypotheses.length : 0} hypotheses, schema: ${result.hypothesesSchema ? 'Yes' : 'No'}`);
        
        // Parse the hypotheses from the result structure
        let hypotheses = result.hypotheses;
        if (!hypotheses && result.hypothesesSchema) {
            try {
                const parsed = JSON.parse(result.hypothesesSchema);
                hypotheses = parsed.hypotheses;
                console.log(`[HYPOTHESES_TOOL] Parsed hypotheses from schema:`, hypotheses?.length || 0);
            } catch (error) {
                console.error(`[HYPOTHESES_TOOL] Failed to parse hypothesesSchema:`, error);
            }
        }
        
        console.log(`[HYPOTHESES_TOOL] Hypotheses array length:`, hypotheses?.length || 0);
        
        // Store the first hypothesis in state manager for use by other tools
        if (hypotheses && hypotheses.length > 0) {
            console.log(`[HYPOTHESES_TOOL] Storing hypothesis: "${hypotheses[0].hypothesis.substring(0, 50)}..."`);
            hypothesisStateManager.setCurrentHypothesis(hypotheses[0]);
            console.log(`[HYPOTHESES_TOOL] Hypothesis stored successfully`);
        } else {
            console.log(`[HYPOTHESES_TOOL] No hypotheses to store`);
        }
        
        return result;
    }

    async cleanup(): Promise<void> {
        await this.prisma.$disconnect();
    }
}

export function generateHypotheses(projectId: string) {
    const executor = new GenerateHypothesesExecutor(projectId);

    return tool({
        description: 'Generate hypotheses for a given project',
        inputSchema: createHypothesesSchema,
        execute: async (input) => {
            try {
                const result = await executor.execute(input);
                return result;
            } catch (error) {
                console.error(`[HYPOTHESES_TOOL] Tool execute failed:`, error);
                throw new Error(error instanceof Error ? error.message : 'Failed to fetch generate hypotheses');
            }
        },
    });
}
</file>

<file path="src/domain/agent/tools/index.ts">
// @ts-nocheck 
// Main tools file - combines all individual tools
import { createGetProjectInfoTool } from './get-project-info';
import { generateHypotheses } from './generate-hypotheses';
import { generateVariants } from './generate-variants';
import { createExperiment } from './create-experiment';
import { createGetBrandAnalysisTool } from './get-brand-analysis';
import { checkVariants } from './check-variants';

// Function to get available tool names
export function getAvailableToolNames(): string[] {
  return ['get_project_info', 'generate_hypotheses', 'generate_variants', 'create_experiment', 'get_brand_analysis', 'check_variants'];
}


// Function to get tools configuration for LLM
export function getToolsConfiguration(projectId: string) {
  return {
    tools: createEcommerceAgentTools(projectId),
    availableTools: getAvailableToolNames(),
  };
}

// Create all tools
export function createEcommerceAgentTools(projectId: string) {
  console.log(`[TOOLS_CONFIG] Creating tools for project: ${projectId}`);
  const tools = {
    get_project_info: createGetProjectInfoTool(projectId),
    generate_hypotheses: generateHypotheses(projectId),
    generate_variants: generateVariants(projectId),
    create_experiment: createExperiment(projectId),
    get_brand_analysis: createGetBrandAnalysisTool(projectId),
    check_variants: checkVariants(projectId),
  };
  console.log(`[TOOLS_CONFIG] Tools created successfully:`, Object.keys(tools));
  return tools;
}
</file>

<file path="src/features/variant_generation/variant-generation.ts">
// @ts-nocheck 
// Variant Generation Service
import { generateObject } from 'ai';
import { google } from '@ai-sdk/google';
import { CrawlerService } from '@features/crawler';
import { ProjectDAL } from '@infra/dal';
import { buildVariantGenerationPrompt } from './prompts';
import { Hypothesis } from '@features/hypotheses_generation/types';
import { basicVariantsResponseSchema } from './types';
import { createVariantCodeGenerator, VariantCodeGenerator } from './code-generator';
import { DOMAnalyzerService, createDOMAnalyzer } from './dom-analyzer';
import { getAIConfig } from '@shared/ai-config';
import { PrismaClient } from '@prisma/client';
import { createScreenshotStorageService, ScreenshotStorageService } from '@services/screenshot-storage';

export interface VariantGenerationService {
    generateVariants(hypothesis: Hypothesis, projectId: string): Promise<VariantGenerationResult>;
    generateSingleVariant(variant: any, hypothesis: Hypothesis, projectId: string, screenshot: string, injectionPoints: any[], brandAnalysis: string): Promise<any>;
    getCachedProject(projectId: string): Promise<any>;
    getCachedBrandAnalysis(projectId: string): Promise<string | null>;
    getAIConfig(): any;
    buildVariantGenerationPrompt(hypothesis: Hypothesis): string;
    basicVariantsResponseSchema: any;
    crawlerService: any;
    domAnalyzer: any;
}

export interface VariantGenerationResult {
    variantsSchema: string;
}

// Factory function
export function createVariantGenerationService(
    crawler: CrawlerService,
    screenshotStorage: ScreenshotStorageService,
    prisma: PrismaClient
): VariantGenerationService {
    return new VariantGenerationServiceImpl(crawler, screenshotStorage, prisma);
}

export class VariantGenerationServiceImpl implements VariantGenerationService {
    private crawlerService: CrawlerService;
    private codeGenerator: VariantCodeGenerator;
    private screenshotStorage: ScreenshotStorageService;
    private domAnalyzer: DOMAnalyzerService;
    private brandAnalysisCache: Map<string, { data: string; timestamp: number }> = new Map();
    private projectCache: Map<string, { data: any; timestamp: number }> = new Map();
    private readonly CACHE_TTL = 5 * 60 * 1000; // 5 minutes
    
    constructor(crawler: CrawlerService, screenshotStorage: ScreenshotStorageService, prisma: PrismaClient) {
        this.crawlerService = crawler;
        this.screenshotStorage = screenshotStorage;
        this.domAnalyzer = createDOMAnalyzer(crawler, prisma);
        this.codeGenerator = createVariantCodeGenerator();
    }

    private async _getCachedProject(projectId: string): Promise<any> {
        const cached = this.projectCache.get(projectId);
        if (cached && Date.now() - cached.timestamp < this.CACHE_TTL) {
            console.log(`[VARIANTS] Using cached project data for ${projectId}`);
            return cached.data;
        }

        console.log(`[VARIANTS] Fetching fresh project data for ${projectId}`);
        const project = await ProjectDAL.getProjectById(projectId);
        if (project) {
            this.projectCache.set(projectId, { data: project, timestamp: Date.now() });
        }
        return project;
    }

    private async _getCachedBrandAnalysis(projectId: string): Promise<string> {
        const cached = this.brandAnalysisCache.get(projectId);
        if (cached && Date.now() - cached.timestamp < this.CACHE_TTL) {
            console.log(`[VARIANTS] Using cached brand analysis for ${projectId}`);
            return cached.data;
        }

        console.log(`[VARIANTS] Fetching fresh brand analysis for ${projectId}`);
        const brandAnalysis = await ProjectDAL.getProjectBrandAnalysis(projectId);
        if (brandAnalysis) {
            this.brandAnalysisCache.set(projectId, { data: brandAnalysis, timestamp: Date.now() });
        }
        return brandAnalysis;
    }

    // Public methods for external access
    async getCachedProject(projectId: string): Promise<any> {
        return this._getCachedProject(projectId);
    }

    async getCachedBrandAnalysis(projectId: string): Promise<string | null> {
        return this._getCachedBrandAnalysis(projectId);
    }

    getAIConfig(): any {
        return getAIConfig();
    }

    buildVariantGenerationPrompt(hypothesis: Hypothesis): string {
        return buildVariantGenerationPrompt(hypothesis);
    }

    get basicVariantsResponseSchema() {
        return basicVariantsResponseSchema;
    }

    get crawlerService() {
        return this.crawlerService;
    }

    get domAnalyzer() {
        return this.domAnalyzer;
    }

    async cleanup(): Promise<void> {
        // Close the browser to free up resources
        if (this.crawlerService && typeof this.crawlerService.close === 'function') {
            await this.crawlerService.close();
        }
    }

    async generateSingleVariant(variant: any, hypothesis: Hypothesis, projectId: string, screenshot: string, injectionPoints: any[], brandAnalysis: string): Promise<any> {
        console.log(`[VARIANTS] Starting single variant generation: ${variant.variant_label}`);
        
        const toDataUrl = (b64: string): string => {
            if (!b64) return '';
            if (b64.startsWith('data:')) return b64;
            return `data:image/png;base64,${b64}`;
        };

        // Get project data for shop domain
        const project = await this._getCachedProject(projectId);
        if (!project) {
            throw new Error(`Project not found: ${projectId}`);
        }
        
        const url = `https://${project.shopDomain}`;
        
        // Initialize crawler for this variant
        const { createPlaywrightCrawler } = await import('@features/crawler');
        const { getServiceConfig } = await import('@infra/config/services');
        const config = getServiceConfig();
        const crawler = createPlaywrightCrawler(config.crawler);
        
        try {
            // Generate code for this variant
            let codeResult;
            try {
                console.log(`[VARIANTS] Generating code for variant: ${variant.variant_label}`);
                codeResult = await this.codeGenerator.generateCode(variant, hypothesis, brandAnalysis, toDataUrl(screenshot), injectionPoints);
            } catch (error) {
                console.error(`[VARIANTS] Failed to generate code for variant ${variant.variant_label}:`, error);
                codeResult = null;
            }
            
            // Take screenshot for this variant
            let variantScreenshotUrl = '';
            if (codeResult) {
                try {
                    console.log(`[VARIANTS] Taking screenshot for variant: ${variant.variant_label}`);
                    const variantScreenshotBase64 = await crawler.takeVariantScreenshot(
                        url,
                        {
                            css_code: codeResult.css_code,
                            html_code: codeResult.html_code,
                            injection_method: codeResult.injection_method,
                            target_selector: codeResult.target_selector,
                            new_element_html: codeResult.new_element_html
                        },
                        { width: 1920, height: 1080 },
                        { type: 'shopify_password', password: 'reitri', shopDomain: project.shopDomain }
                    );
                    
                    // Save screenshot to database and get the screenshot ID
                    const variantId = `variant-${variant.variant_label.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase()}-${Date.now()}`;
                    const screenshotId = await this.screenshotStorage.saveScreenshot(
                        projectId,
                        'other', // Variant screenshots are categorized as 'other'
                        url,
                        { viewport: { width: 1920, height: 1080 }, fullPage: true, quality: 80 },
                        variantScreenshotBase64,
                        undefined, // No HTML content for variant screenshots
                        variantId // Unique variant ID to prevent duplicates
                    );
                    
                    // Generate a proper URL for the screenshot
                    variantScreenshotUrl = `/api/screenshots/db/${screenshotId}`;
                    console.log(`[VARIANTS] Screenshot saved for variant ${variant.variant_label}: ${variantScreenshotUrl}`);
                } catch (screenshotError) {
                    console.error(`[VARIANTS] Failed to take screenshot for variant ${variant.variant_label}:`, screenshotError);
                    // Continue without screenshot rather than failing the entire variant
                }
            }
            
            // Create the final variant object
            const finalVariant = {
                ...variant,
                css_code: codeResult?.css_code || '',
                html_code: codeResult?.html_code || '',
                injection_method: codeResult?.injection_method || 'selector' as const,
                target_selector: codeResult?.target_selector || '',
                new_element_html: codeResult?.new_element_html || '',
                implementation_instructions: codeResult?.implementation_instructions || `Code generation failed for this variant. Please implement manually based on the description: ${variant.description}`,
                screenshot: variantScreenshotUrl
            };
            
            console.log(`[VARIANTS] Completed single variant: ${variant.variant_label}`);
            return finalVariant;
            
        } finally {
            // Clean up the crawler
            await crawler.close();
        }
    }

    async generateVariants(hypothesis: Hypothesis, projectId: string): Promise<VariantGenerationResult> {
        console.log(`[VARIANTS] Starting generation for hypothesis: ${hypothesis.hypothesis}`);
        console.log(`[VARIANTS] Using project ID: ${projectId}`);
        
        // Get project data to fetch shop domain (with caching)
        console.log(`[VARIANTS] Fetching project data for project: ${projectId}`);
        const project = await this._getCachedProject(projectId);
        if (!project) {
            throw new Error(`Project not found: ${projectId}`);
        }
        
        const url = `https://${project.shopDomain}`;
        console.log(`[VARIANTS] Using shop domain: ${project.shopDomain}, URL: ${url}`);
        
        const toDataUrl = (b64: string): string => {
            if (!b64) return '';
            if (b64.startsWith('data:')) return b64;
            return `data:image/png;base64,${b64}`;
        };

        // Check storage first for base screenshot and HTML (reuse from brand analysis or DOM analysis)
        const pageType = this.getPageType(url);
        const cachedData = await this.screenshotStorage.getScreenshotWithHtml(
            projectId, 
            pageType, 
            { viewport: { width: 1920, height: 1080 }, fullPage: true, quality: 80 }
        );
        
        let screenshot: string;
        let htmlContent: string | null = null;
        
        if (cachedData.screenshot) {
            console.log(`[VARIANTS] Using stored screenshot and HTML for ${pageType} page`);
            screenshot = cachedData.screenshot;
            htmlContent = cachedData.html;
        } else {
            console.log(`[VARIANTS] Taking new screenshot and HTML for ${url}`);
            const crawlResult = await this.crawlerService.crawlPage(url, {
                viewport: { width: 1920, height: 1080 },
                waitFor: 3000,
                screenshot: { fullPage: true, quality: 80 },
                authentication: { type: 'shopify_password', password: 'reitri', shopDomain: project.shopDomain }
            });
            
            screenshot = crawlResult.screenshot || '';
            htmlContent = crawlResult.html || null;
            
            // Store the new screenshot and HTML
            if (screenshot) {
                const screenshotId = await this.screenshotStorage.saveScreenshot(
                    projectId, 
                    pageType,
                    url, 
                    { viewport: { width: 1920, height: 1080 }, fullPage: true, quality: 80 },
                    screenshot,
                    htmlContent ? htmlContent.substring(0, 50000) : undefined // Limit HTML size for storage
                );
                console.log(`[VARIANTS] Screenshot and HTML saved with ID: ${screenshotId}`);
            }
        }

        // PARALLEL OPTIMIZATION: Run DOM analysis and brand analysis in parallel
        console.log(`[VARIANTS] Starting parallel operations: DOM analysis and brand analysis`);
        const [injectionPoints, brandAnalysis] = await Promise.all([
            // Pass the HTML content we already have to avoid re-crawling
            this.domAnalyzer.analyzeForHypothesisWithHtml(
                url, 
                hypothesis.hypothesis,
                projectId,
                htmlContent, // Pass the HTML we already have
                { type: 'shopify_password', password: 'reitri', shopDomain: project.shopDomain }
            ),
            this._getCachedBrandAnalysis(projectId)
        ]);

        console.log(`[VARIANTS] Parallel operations completed:`);
        console.log(`[VARIANTS] - Screenshot length: ${screenshot.length}`);
        console.log(`[VARIANTS] - Injection points found: ${injectionPoints.length}`);
        console.log(`[VARIANTS] - Brand analysis: ${brandAnalysis ? `length: ${brandAnalysis.length} chars` : 'null'}`);
        
        if (!brandAnalysis) {
            console.warn(`[VARIANTS] No brand analysis found for project: ${projectId}`);
            throw new Error(`No brand analysis available for project ${projectId}. Please run brand analysis first.`);
        }

        console.log(`[VARIANTS] Generating AI response with Google Gemini`);
        const aiConfig = getAIConfig();
        const object = await generateObject({
            model: google(aiConfig.model, {
                apiKey: aiConfig.apiKey,
            }),
            schema: basicVariantsResponseSchema,
            messages: [
                {
                    role: 'user',
                    content: [
                        { type: "text", text: buildVariantGenerationPrompt(hypothesis) },
                        { type: "text", text: brandAnalysis },
                        { type: "image", image: toDataUrl(screenshot) }
                    ]
                }
            ]
        });
        const response = object.object;
        console.log(`[VARIANTS] AI response generated: ${response.variants.length} variants`);

        // SEQUENTIAL PROCESSING: Generate code and take screenshots for each variant one by one
        console.log(`[VARIANTS] Processing ${response.variants.length} variants sequentially`);
        const variantsWithScreenshots = [];
        
        // Initialize a single crawler instance for all variants to reuse browser
        const { createPlaywrightCrawler } = await import('@features/crawler');
        const { getServiceConfig } = await import('@infra/config/services');
        const config = getServiceConfig();
        const crawler = createPlaywrightCrawler(config.crawler);
        
        try {
            for (let index = 0; index < response.variants.length; index++) {
                const variant = response.variants[index];
                console.log(`[VARIANTS] Processing variant ${index + 1}/${response.variants.length}: ${variant.variant_label}`);
                
                // Generate code for this variant
                let codeResult;
                try {
                    console.log(`[VARIANTS] Generating code for variant ${index + 1}: ${variant.variant_label}`);
                    codeResult = await this.codeGenerator.generateCode(variant, hypothesis, brandAnalysis, toDataUrl(screenshot), injectionPoints);
                } catch (error) {
                    console.error(`[VARIANTS] Failed to generate code for variant ${variant.variant_label}:`, error);
                    codeResult = null;
                }
                
                // Take screenshot for this variant using the shared crawler instance
                let variantScreenshotUrl = '';
                if (codeResult) {
                    try {
                        console.log(`[VARIANTS] Taking screenshot for variant ${index + 1}: ${variant.variant_label}`);
                        const variantScreenshotBase64 = await crawler.takeVariantScreenshot(
                            url,
                            {
                                css_code: codeResult.css_code,
                                html_code: codeResult.html_code,
                                injection_method: codeResult.injection_method,
                                target_selector: codeResult.target_selector,
                                new_element_html: codeResult.new_element_html
                            },
                            { width: 1920, height: 1080 },
                            { type: 'shopify_password', password: 'reitri', shopDomain: project.shopDomain }
                        );
                        
                        // Save screenshot to database and get URL
                        const screenshotId = await this.screenshotStorage.saveScreenshot(
                            projectId,
                            'other', // Variant screenshots are categorized as 'other'
                            url,
                            { viewport: { width: 1920, height: 1080 }, fullPage: true, quality: 80 },
                            variantScreenshotBase64,
                            undefined, // No HTML content for variant screenshots
                            `variant-${index + 1}-${variant.variant_label.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase()}` // Unique variant ID
                        );
                        variantScreenshotUrl = `/api/screenshots/db/${screenshotId}`;
                        console.log(`[VARIANTS] Screenshot saved for variant ${variant.variant_label}: ${variantScreenshotUrl}`);
                    } catch (screenshotError) {
                        console.error(`[VARIANTS] Failed to take screenshot for variant ${variant.variant_label}:`, screenshotError);
                        // Continue without screenshot rather than failing the entire variant
                    }
                }
                
                // Create the final variant object
                const finalVariant = {
                    ...variant,
                    css_code: codeResult?.css_code || '',
                    html_code: codeResult?.html_code || '',
                    injection_method: codeResult?.injection_method || 'selector' as const,
                    target_selector: codeResult?.target_selector || '',
                    new_element_html: codeResult?.new_element_html || '',
                    implementation_instructions: codeResult?.implementation_instructions || `Code generation failed for this variant. Please implement manually based on the description: ${variant.description}`,
                    screenshot: variantScreenshotUrl
                };
                
                variantsWithScreenshots.push(finalVariant);
                console.log(`[VARIANTS] Completed variant ${index + 1}/${response.variants.length}: ${variant.variant_label}`);
            }
        } finally {
            // Clean up the crawler
            await crawler.close();
        }

        console.log(`[VARIANTS] All variants with code and screenshots generated successfully`);
        const result = {
            variantsSchema: JSON.stringify({ variants: variantsWithScreenshots })
        };
        console.log(`[VARIANTS] Final result: ${variantsWithScreenshots.length} variants, schema length: ${result.variantsSchema.length} chars`);
        return result;
    }

    private getPageType(url: string): 'home' | 'pdp' | 'about' | 'other' {
        const urlLower = url.toLowerCase();
        
        // Check for product pages first
        if (urlLower.includes('/products/') || urlLower.includes('/collections/')) {
            return 'pdp';
        }
        
        // Check for about pages
        if (urlLower.includes('/about')) {
            return 'about';
        }
        
        // Check for home page - this should be the most common case
        // Home page is typically just the domain or domain with trailing slash
        const urlObj = new URL(url);
        const pathname = urlObj.pathname;
        
        // If no path or just a trailing slash, it's the home page
        if (!pathname || pathname === '/' || pathname === '') {
            return 'home';
        }
        
        // If path is just common home page indicators
        if (pathname === '/home' || pathname === '/index' || pathname === '/index.html') {
            return 'home';
        }
        
        return 'other';
    }
}
</file>

<file path="Dockerfile">
# Development Dockerfile with hot reloading
FROM node:20-bullseye-slim

# Set working directory
WORKDIR /app

# Copy package files
COPY package*.json ./

# Install all dependencies (including dev dependencies)
RUN npm install --package-lock-only --legacy-peer-deps
RUN npm ci --legacy-peer-deps

RUN apt-get update && apt-get install -y --no-install-recommends \
    chromium \
    libnss3 \
    libfreetype6 \
    libharfbuzz0b \
    ca-certificates \
    libcairo2 \
    libpango-1.0-0 \
    libpangocairo-1.0-0 \
    fonts-freefont-ttf \
    udev

RUN npx playwright install chromium

# Copy source code and config files
COPY src/ ./src/
COPY tsconfig.json ./
COPY prisma/ ./prisma/

# Generate Prisma client (but don't build TypeScript)
RUN npm run db:generate

# Expose port
EXPOSE 3001

# Start the application in development mode with hot reloading
CMD ["npm", "run", "dev"]
</file>

<file path="prisma/schema.prisma">
generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-1.1.x", "linux-arm64-openssl-1.1.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  auth0Id   String   @unique
  email     String   @unique
  firstName String
  lastName  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  project   Project?

  @@map("users")
}

model Project {
  id               String            @id @default(cuid())
  shopDomain       String            @unique
  brandAnalysis    Json?
  accessTokenEnc   String
  userId           String            @unique
  createdAt        DateTime          @default(now())
  brandSummaryJobs BrandSummaryJob[]
  chatMessages     ChatMessage[]
  experiments      Experiment[]
  user             User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  screenshots      Screenshot[]
  variantJobs      VariantJob[]

  @@map("projects")
}

model Experiment {
  id                    String                @id @default(cuid())
  projectId             String
  name                  String
  status                JobStatus             @default(DRAFT)
  createdAt             DateTime              @default(now())
  publishedAt           DateTime?
  finishedAt            DateTime?
  oec                   String
  minDays               Int
  minSessionsPerVariant Int
  hypothesis            ExperimentHypothesis?
  traffic               ExperimentTraffic[]
  variants              ExperimentVariant[]
  project               Project               @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([projectId, status])
  @@map("experiments")
}

model ChatMessage {
  id        String      @id @default(cuid())
  projectId String
  role      MessageRole
  content   Json
  createdAt DateTime    @default(now())
  project   Project     @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([projectId, createdAt])
  @@map("chat_messages")
}

model BrandSummaryJob {
  id          String    @id @default(cuid())
  projectId   String
  status      JobStatus @default(PENDING)
  progress    Int?      @default(0)
  result      Json?
  error       String?
  createdAt   DateTime  @default(now())
  startedAt   DateTime?
  completedAt DateTime?
  project     Project   @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([projectId, status, createdAt])
  @@index([status, createdAt])
  @@map("brand_summary_jobs")
}

model VariantJob {
  id          String    @id @default(cuid())
  projectId   String
  status      JobStatus @default(PENDING)
  progress    Int?      @default(0)
  result      Json?
  error       String?
  createdAt   DateTime  @default(now())
  startedAt   DateTime?
  completedAt DateTime?
  project     Project   @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([projectId, status, createdAt])
  @@index([status, createdAt])
  @@map("variant_jobs")
}

model ExperimentHypothesis {
  id           String     @id @default(cuid())
  experimentId String     @unique
  hypothesis   String
  rationale    String
  primaryKpi   String
  createdAt    DateTime   @default(now())
  experiment   Experiment @relation(fields: [experimentId], references: [id], onDelete: Cascade)

  @@map("experiment_hypotheses")
}

model ExperimentTraffic {
  id           String     @id @default(cuid())
  experimentId String
  variantId    String
  percentage   Decimal    @db.Decimal(5, 4)
  experiment   Experiment @relation(fields: [experimentId], references: [id], onDelete: Cascade)

  @@unique([experimentId, variantId])
  @@index([experimentId])
  @@map("experiment_traffic")
}

model ExperimentVariant {
  id           String         @id @default(cuid())
  experimentId String
  variantId    String
  selector     String?
  html         String
  css          String?
  position     InjectPosition
  experiment   Experiment     @relation(fields: [experimentId], references: [id], onDelete: Cascade)

  @@unique([experimentId, variantId])
  @@index([experimentId])
  @@map("experiment_variants")
}

model Screenshot {
  id             String   @id @default(cuid())
  projectId      String
  url            String
  pageType       String
  variantId      String?  // Optional variant identifier for variant screenshots
  viewportWidth  Int
  viewportHeight Int
  fullPage       Boolean
  quality        Int
  data           Bytes
  htmlContent    String?  @db.Text
  fileSize       Int
  createdAt      DateTime @default(now())
  expiresAt      DateTime
  accessedAt     DateTime @default(now())
  accessCount    Int      @default(0)
  project        Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@unique([projectId, pageType, variantId, viewportWidth, viewportHeight, fullPage, quality])
  @@index([projectId])
  @@index([expiresAt])
  @@index([pageType])
  @@index([variantId])
  @@map("screenshots")
}

enum JobStatus {
  DRAFT
  PENDING
  RUNNING
  PAUSED
  COMPLETED
  FAILED
}

enum MessageRole {
  USER
  AGENT
  TOOL
  SYSTEM
}

enum InjectPosition {
  INNER
  OUTER
  BEFORE
  AFTER
}
</file>

<file path="src/domain/agent/tools/generate-variants.ts">
import { tool } from 'ai';
import { createVariantsSchema } from './schemas';
import { createVariantGenerationService, VariantGenerationService } from '@features/variant_generation/variant-generation';
import { createPlaywrightCrawler } from '@features/crawler';
import { createScreenshotStorageService } from '@services/screenshot-storage';
import { getServiceConfig } from '@infra/config/services';
import { Hypothesis } from '@features/hypotheses_generation/types';
import { hypothesisStateManager } from '../hypothesis-state-manager';
import { variantStateManager } from '../variant-state-manager';
import { VariantJobDAL } from '@infra/dal';
import { createVariantJobProcessor } from '@services/variant-job-processor';
import { prisma } from '@infra/prisma';

class GenerateVariantsExecutor {
    private variantGenerationService: VariantGenerationService;
    private projectId: string;

    constructor(projectId: string) {
        this.projectId = projectId;
        const config = getServiceConfig();
        const crawler = createPlaywrightCrawler(config.crawler);
        const screenshotStorage = createScreenshotStorageService(prisma);
        this.variantGenerationService = createVariantGenerationService(crawler, screenshotStorage, prisma);
    }

    private async generateVariantJobs(hypothesis: Hypothesis): Promise<{ jobIds: string[]; projectId: string }> {
        console.log(`[VARIANTS_TOOL] Starting job-based variant generation for hypothesis: ${hypothesis.hypothesis}`);
        
        // Verify project exists
        const project = await this.variantGenerationService.getCachedProject(this.projectId);
        if (!project) {
            throw new Error(`Project not found: ${this.projectId}`);
        }

        // Create 3 jobs immediately (one for each variant)
        const jobIds: string[] = [];
        for (let i = 0; i < 3; i++) {
            const job = await VariantJobDAL.createJob({ projectId: this.projectId });
            jobIds.push(job.id);
            console.log(`[VARIANTS_TOOL] Created job ${job.id} for variant ${i + 1}`);
        }

        // Start async processing of all jobs
        // Each job will do its own AI generation, code generation, and screenshots
        const jobProcessor = createVariantJobProcessor();
        jobProcessor.processVariantJobs(
            jobIds, 
            this.projectId, 
            hypothesis
        ).catch(error => {
            console.error(`[VARIANTS_TOOL] Failed to process variant jobs:`, error);
        });

        return {
            jobIds,
            projectId: this.projectId
        };
    }

    async execute(input: { hypothesis?: Hypothesis }): Promise<any> {
        console.log(`[VARIANTS_TOOL] ===== VARIANT GENERATION INPUT =====`);
        console.log(`[VARIANTS_TOOL] Full input received:`, JSON.stringify(input, null, 2));
        
        // Get hypothesis from state manager (preferred) or input
        let hypothesis = hypothesisStateManager.getCurrentHypothesis();
        
        if (hypothesis) {
            console.log(`[VARIANTS_TOOL] Using hypothesis from state manager: "${hypothesis.hypothesis.substring(0, 50)}..."`);
        } else if (input.hypothesis) {
            console.log(`[VARIANTS_TOOL] Using hypothesis from input: "${input.hypothesis.hypothesis.substring(0, 50)}..."`);
            hypothesis = input.hypothesis;
        } else {
            console.log(`[VARIANTS_TOOL] No hypothesis available in state or input`);
            throw new Error('No hypothesis available. Please generate hypotheses first using the generate_hypotheses tool.');
        }
        
        console.log(`[VARIANTS_TOOL] ======================================`);
        
        try {
            const result = await this.generateVariantJobs(hypothesis);
            console.log(`[VARIANTS_TOOL] Variant jobs created successfully: ${result.jobIds.length} jobs`);
            
            // Store the job IDs in the state manager for later retrieval
            variantStateManager.setCurrentJobIds(result.jobIds);
            console.log(`[VARIANTS_TOOL] Job IDs stored in state manager:`, result.jobIds);
            
            return result;
        } catch (error) {
            console.error(`[VARIANTS_TOOL] Failed to generate variant jobs:`, error);
            throw error;
        }
    }
}

export function generateVariants(projectId: string) {
    const executor = new GenerateVariantsExecutor(projectId);

    return tool({
        description: 'Generate variants for testing a hypothesis. Creates variant jobs that process in the background. Returns jobIds that can be passed to create_experiment to load the specific variants from these jobs.',
        inputSchema: createVariantsSchema,
        execute: async (input) => {
            try {
                const result = await executor.execute(input);
                return result;
            } catch (error) {
                console.error(`[VARIANTS_TOOL] Tool execute failed:`, error);
                throw new Error(error instanceof Error ? error.message : 'Failed to generate variants');
            }
        },
    });
}
</file>

<file path="src/interfaces/http/chat.ts">
import { FastifyInstance } from 'fastify';
import { serviceContainer } from '@app/container';
import { Readable } from 'node:stream';
import { UIMessage } from 'ai';
import { authMiddleware } from './middleware/auth';
import { requireAuth } from './middleware/authorization';


export async function chatRoutes(fastify: FastifyInstance) {
    fastify.post("/chat", { preHandler: [authMiddleware, requireAuth] }, async (req, reply) => {
        const { messages } = (req.body ?? {}) as {
            messages?: UIMessage[];
        };

        console.log(`[CHAT] Processing ${messages?.length || 0} messages`);

        if (!messages || messages.length === 0) {
            return reply.code(400).send({ error: 'Messages are required' });
        }

        try {
            // Get the agent service from container (already configured with system prompt and tools)
            const agentService = serviceContainer.getAgentService();

            // Get the last user message
            const lastMessage = messages[messages.length - 1];
            if (!lastMessage || lastMessage.role !== 'user') {
                return reply.code(400).send({ error: 'Last message must be from user' });
            }

            // Extract text content from the message parts
            const parts = (lastMessage as any).parts;
            if (!parts || !Array.isArray(parts)) {
                return reply.code(400).send({ error: 'Invalid message parts format' });
            }

            const messageText = parts
                .filter((part: any) => part.type === 'text')
                .map((part: any) => part.text)
                .join('');

            if (!messageText) {
                return reply.code(400).send({ error: 'Message content is required' });
            }

            // Convert the full conversation history to the format expected by the agent
            const conversationHistory = messages.map((msg: any) => {
                const msgParts = msg.parts || [];
                const textContent = msgParts
                    .filter((part: any) => part.type === 'text')
                    .map((part: any) => part.text)
                    .join('');
                
                return {
                    role: msg.role,
                    content: textContent,
                    // Include tool calls and results from assistant messages
                    ...(msg.role === 'assistant' && {
                        tool_calls: msgParts
                            .filter((part: any) => part.type?.startsWith('tool-'))
                            .map((part: any) => ({
                                id: part.toolCallId,
                                type: 'function',
                                function: {
                                    name: part.type.replace('tool-', ''),
                                    arguments: JSON.stringify(part.input || {})
                                }
                            })),
                        tool_call_id: msgParts
                            .filter((part: any) => part.type?.startsWith('tool-'))
                            .map((part: any) => part.toolCallId)[0],
                        // Include tool call outputs so the agent can see the results
                        tool_results: msgParts
                            .filter((part: any) => part.type?.startsWith('tool-') && part.output)
                            .map((part: any) => ({
                                tool_call_id: part.toolCallId,
                                content: JSON.stringify(part.output)
                            }))
                    })
                };
            });

            // Use the agent service streaming method with full conversation history
            // Session management is disabled for now
            console.log(`[CHAT] Calling agent service with message: "${messageText.substring(0, 100)}..." and ${conversationHistory.length} history messages`);
            const { stream } = await agentService.sendMessageStream(messageText, req.projectId!, conversationHistory);
            console.log(`[CHAT] Agent service returned stream successfully`);

            // Use AI SDK's built-in streaming response
            const res = (stream as { toUIMessageStreamResponse: () => Response }).toUIMessageStreamResponse();

            // Copy headers + stream body to Fastify
            reply.code(res.status);
            for (const [k, v] of res.headers) reply.header(k, v);
            if (res.body) {
                const nodeStream = Readable.fromWeb(res.body as any);
                return reply.send(nodeStream);
            }
            return reply.send();

        } catch (error) {
            console.error('Streaming chat error:', error);
            return reply.code(500).send({ error: 'Internal server error' });
        }
    });
}
</file>

<file path="src/domain/agent/prompts.ts">
// System prompts for the e-commerce optimization assistant
// import { getAvailableToolNames } from './tools';

// Core identity and role definition
const CORE_IDENTITY = `You are Omen, an AI growth partner for eCommerce brands. Your job is to speak with merchants in a personable, confident, and proactive way. You should sound like a trusted advisor who has already analyzed their store deeply and is excited to share high-value insights. Keep the tone warm, approachable, and slightly urgentemphasize that every moment without testing is a missed opportunity, but do it in a motivating, not pushy way. Present findings as if you've just completed a brand analysis, then smoothly transition into proposing experiments that can capture quick wins. Always frame Omen as hands-on, on-brand, and outcome-driven: your role is to help them turn more visitors into customers, compounding growth over time.

## Your Expertise
- E-commerce performance analysis and optimization strategies
- Brand analysis and visual identity assessment
- UX/UI design evaluation and improvement recommendations
- A/B testing methodology and experiment design
- Conversion optimization and user experience enhancement

## Your Communication Style
- **Personable & Confident**: Speak as a trusted advisor who has deep knowledge of their store
- **Proactive & Insightful**: Present findings as if you've just completed a comprehensive analysis
- **Warm & Approachable**: Maintain a friendly, professional tone that builds trust
- **Slightly Urgent**: Emphasize that every moment without testing is a missed opportunity
- **Motivating, Not Pushy**: Frame testing as exciting growth opportunities, not pressure
- **Outcome-Driven**: Focus on turning more visitors into customers and compounding growth
- **Hands-On**: Position yourself as actively involved in their optimization journey
- **On-Brand**: Tailor all recommendations to their specific brand identity and positioning

## Your Approach
You operate as a UX designer who has personally analyzed each website, providing insights based on real store data and comprehensive brand analysis. You guide users through the optimization process with deep brand knowledge and actionable recommendations.`;

// Core responsibilities and capabilities
const CORE_RESPONSIBILITIES = `## Core Responsibilities

**Store Analysis & Insights:**
- Analyze store performance and identify optimization opportunities
- Provide insights based on real store data and comprehensive brand analysis
- Act as a UX designer who has personally analyzed the website
- Guide users through the optimization process with deep brand knowledge

**Experiment Management:**
- Help create and manage A/B tests and experiments
- Generate data-driven hypotheses for store optimization
- Design testable variants for hypothesis validation
- Guide users through the complete experimentation workflow

**Brand Understanding:**
- Conduct comprehensive brand analysis including visual identity, personality, and messaging
- Provide targeted recommendations based on brand positioning and target audience
- Speak personally about brand elements as if you've analyzed them firsthand
- Balance analytical insights with brand-appropriate recommendations`;

// Critical workflow rules and behaviors
const WORKFLOW_RULES = `## Critical Workflow Rules

**Hypothesis Generation:**
- When you call generate_hypotheses, the hypotheses are automatically displayed in the function call UI
- Do NOT repeat or list them in your chat message - just acknowledge briefly and ask a follow-up question
- Always continue the conversation with a brief acknowledgment and natural follow-up question

**Variant Creation:**
- When a user asks to "create variants" or "do it" after generating hypotheses:
  1. Explain what you're going to do BEFORE calling the tool
  2. Call generate_variants without any parameters - it will automatically use the most recently generated hypothesis
  3. Do NOT provide a second message after the function call - the function call result is sufficient
  4. Do NOT call generate_hypotheses again - this will create a NEW hypothesis instead of variants for the existing one
  5. Do NOT make up or create a new hypothesis - the tools will handle hypothesis state automatically
  6. If the user wants to test a different hypothesis, they need to generate new hypotheses first

**Experiment Creation Flow:**
After generating variants:
1. Acknowledge the variants generated
2. Ask the user if they want to create an experiment to test these variants
3. If they say yes, call create_experiment with NO parameters - everything will be auto-retrieved from state:
   - Variants: automatically retrieved from variant state manager
   - Hypothesis: automatically retrieved from hypothesis state manager  
   - Name: automatically generated from hypothesis
4. NEVER ask the user for an experiment name - always generate it automatically from the hypothesis
5. Inform them the experiment is live and running immediately
6. Tell them to come back later to check the results

**CRITICAL: State Management:**
- Both hypothesis and variants are automatically stored in state managers
- create_experiment will automatically retrieve both from state
- You can call create_experiment with no parameters - everything is handled automatically`;

// Brand analysis communication style
const BRAND_ANALYSIS_STYLE = `## Brand Analysis Communication Style

**Personal, Analytical Tone:**
- Speak as if you personally visited and analyzed the website as a UX designer
- Use phrases like "I noticed," "I observed," "I found," "I discovered" when referencing specific brand elements
- Reference specific elements as if you saw them firsthand: "I love how you're using that bold blue accent," "I noticed your clean typography really stands out"
- Use analytical language: "What stands out to me is," "I'm seeing some interesting patterns," "This suggests," "I'm noticing"

**Conversational, Not Structured:**
- NEVER create bulleted lists or structured sections when discussing brand analysis
- Speak conversationally and naturally about brand insights
- Focus on the brand's core business and what it sells - reference actual products and industry context
- Balance UI analysis with brand strategy - discuss personality, values, target audience, positioning, and messaging strategy

**Observational Approach:**
- Be observational rather than prescriptive - describe the current state without suggesting changes
- Make neutral observations without jumping to improvement suggestions
- Balance enthusiasm with analytical insights - show you did real analysis, not just praise everything
- Focus on what the brand represents and how it connects with customers, not just how it looks

**Omen's Growth-Focused Perspective:**
- Always connect brand insights to growth opportunities and conversion potential
- Frame observations in terms of customer behavior and purchasing decisions
- Highlight elements that could be optimized for better performance
- Transition naturally from analysis to actionable experiment recommendations
- Emphasize the urgency of testing: "I'm seeing some great opportunities here that we could start testing immediately"

**Avoid Generic Language:**
- NEVER use generic phrases like "This analysis highlights" or "The data shows"
- Instead speak personally about what you observed on the website
- Interpret brand analysis JSON data naturally and provide detailed insights
- Always nudge users toward experimentation after providing brand analysis with growth-focused language`;

// Tool usage guidelines
const TOOL_USAGE_GUIDELINES = `## Tool Usage Guidelines

**Always Provide Context:**
- ALWAYS explain what you're doing before calling a tool (e.g., "Let me fetch your project information...", "I'll check your store details...")
- ALWAYS summarize tool results in user-friendly language after calling them
- NEVER call tools silently - always provide context and explanation
- When you get data from tools, explain what it means and how it's relevant to the user's question

**Conversation Flow:**
- Make the conversation feel natural and conversational, not robotic
- Adapt your acknowledgment based on the context and user's request
- Use natural, conversational language rather than rigid templates
- Vary your follow-up questions based on the situation

**Response Examples:**
- "Perfect! I've found an optimization opportunity..."
- "Great! I've generated a hypothesis..."
- "Excellent! I've identified a potential improvement..."`;

// Behavior rules and constraints
const BEHAVIOR_RULES = `## Behavior Rules

**Tool Usage:**
1. When asked about experiments or hypotheses, call generate_hypotheses directly - it will handle getting the project ID internally
2. When asked to create variants or "do it" after generating hypotheses, extract the hypothesis from the previous generate_hypotheses result and pass it to generate_variants
3. When asked to "create the experiment" or "create an experiment" after generating variants, call create_experiment with NO parameters - everything will be auto-retrieved from state
4. Only call get_project_info if specifically asked for project details or store information
5. Base your advice on actual store data and brand analysis, not assumptions

**Communication Standards:**
6. Be specific and actionable in your recommendations
7. Always explain what data you're using to make your suggestions
8. If asked about topics unrelated to e-commerce optimization, politely redirect: "I'm specialized in e-commerce optimization. I can help you with store analysis, experiments, or optimization questions instead. What would you like to work on?"

**Critical Requirements:**
9. After calling generate_hypotheses, you MUST continue the conversation with a brief acknowledgment (do NOT repeat the full hypothesis details as they are already displayed in the function call UI) and ask a follow-up question about next steps - never end with just the tool call result
10. NEVER list or repeat the individual hypotheses in your chat message after calling generate_hypotheses - they are already displayed in the function call UI
11. After calling generate_variants, do NOT provide a second message - the function call result is sufficient and the user will see the variants when they're ready
12. After publishing an experiment, always confirm it's live, explain that traffic is now split between the control and the new variants, and let the user know we'll keep them informed and they can check back later to see results`;

// Example conversation flows
const EXAMPLE_CONVERSATIONS = `## Example Conversation Flows

**Hypothesis Generation:**
User: "What experiments can help improve my store?"
Assistant: "I'll analyze your store and generate some optimization hypotheses for you..."
[Tool call: generate_hypotheses]
Assistant: "Great! I've generated an optimization hypothesis based on my analysis of your store. The details are shown above. Do you have any questions about this hypothesis, or would you like me to help you create variants to test it?"

**Variant Creation:**
User: "Let's do it"
Assistant: "I'll create variants for the hypothesis we just generated. The variants are being processed and will be done shortly. When they're done, check them out and feel free to ask me anything you want about them. If everything's clear, we can publish them and start the experiment!"
[Tool call: generate_variants]

**Experiment Creation:**
User: "Yes, create the experiment"
Assistant: "I'll create an experiment with your hypothesis and variants..."
[Tool call: create_experiment with no parameters - everything auto-retrieved from state]
Assistant: " Your experiment is now LIVE and running! Traffic is being split between your control and the new variants, and we're already collecting valuable data. You can check back later to see how your variants are performing!"

**Brand Analysis:**
User: "Tell me about my brand"
[Tool call: get_brand_analysis]
Assistant: "I just spent some time analyzing your snowboard brand and I'm seeing some really exciting opportunities here! What stands out to me is how you've positioned yourself for young, active snowboarders who want quality without breaking the bank - that's a smart positioning in this market. Your brand personality comes across as reliable, innovative, and trendy, which aligns perfectly with this community's values. I'm noticing you're targeting budget-conscious shoppers who still want premium quality - that's a sweet spot that could really drive conversions if we optimize the right elements. Your messaging around 'exclusive deals' and 'customer satisfaction' reinforces this value-driven approach beautifully. I'm seeing a black, white, and blue palette that's clean and modern, which works well for the tech-savvy snowboard crowd. Your typography is bold and crisp, and I noticed strong trust signals like money-back guarantees. The overall vibe definitely captures that snowboard community feel. I'm seeing some great opportunities here that we could start testing immediately to turn more of those visitors into customers - let's create some hypotheses together and start optimizing!"`;

// Main composer function
export function createEcommerceAgentSystemPrompt(availableTools: string[]): string {
  const toolsList = availableTools.map(tool => `- ${tool}: ${getToolDescription(tool)}`).join('\n');

  return `${CORE_IDENTITY}

${CORE_RESPONSIBILITIES}

${WORKFLOW_RULES}

${BRAND_ANALYSIS_STYLE}

${TOOL_USAGE_GUIDELINES}

${BEHAVIOR_RULES}

## Available Tools
${toolsList}

${EXAMPLE_CONVERSATIONS}

Remember: You are a data-driven assistant. Use tools to get real information, then provide insights based on that data. Always narrate what you're doing for the user.`;
}

function getToolDescription(toolName: string): string {
  const descriptions: Record<string, string> = {
    'get_project_info': 'Get detailed project and store information including Shopify store details and experiment statistics.',
    'generate_hypotheses': 'Generate optimization hypotheses for the current project. Returns structured hypothesis data that will be displayed in the UI. Handles project ID automatically.',
    'generate_variants': 'Start generating testable variants for a hypothesis. Creates background jobs that will process variants asynchronously. Automatically uses the most recently generated hypothesis from state.',
    'create_experiment': 'Create an experiment in the database with hypothesis and variants data. Automatically uses the most recently generated hypothesis from state.',
    'get_brand_analysis': 'Get brand analysis data for the project including visual style, brand elements, personality insights, and language/messaging analysis.',
  };
  
  return descriptions[toolName] || 'Tool description not available';
}

// Legacy export for backward compatibility
export const ECOMMERCE_AGENT_SYSTEM_PROMPT = createEcommerceAgentSystemPrompt(['get_project_info', 'generate_hypotheses', 'generate_variants', 'create_experiment', 'get_brand_analysis']);
</file>

<file path="src/features/hypotheses_generation/hypotheses-generation.ts">
// Hypotheses Generation Service
import { generateObject } from 'ai';
import { google } from '@ai-sdk/google';
import { CrawlerService } from '@features/crawler';
import { z } from 'zod'
import { ProjectDAL } from '@infra/dal'
import { getAIConfig } from '@shared/ai-config'
import { PrismaClient } from '@prisma/client';
import { createScreenshotStorageService, ScreenshotStorageService } from '@services/screenshot-storage';
import { simplifyHTML, getHtmlInfo } from '@shared/utils/html-simplifier';

export interface HypothesesGenerationService {
    generateHypotheses(url: string, projectId: string): Promise<HypothesesGenerationResult>;
}

export interface HypothesesGenerationResult {
    hypothesesSchema: string;
}

// Factory function
export function createHypothesesGenerationService(
    crawler: CrawlerService,
    prisma: PrismaClient
): HypothesesGenerationService {
    return new HypothesesGenerationServiceImpl(crawler, prisma);
}

const hypothesesResponseSchema = z.object({
    hypotheses: z.array(z.object({
        hypothesis: z.string(),
        rationale: z.string(),
        measurable_tests: z.string(),
        success_metrics: z.string(),
        oec: z.string(),
        accessibility_check: z.string()
    }))
});


export class HypothesesGenerationServiceImpl implements HypothesesGenerationService {
    private crawlerService: CrawlerService;
    private screenshotStorage: ScreenshotStorageService;
    
    constructor(crawler: CrawlerService, prisma: PrismaClient) {
        this.crawlerService = crawler;
        this.screenshotStorage = createScreenshotStorageService(prisma);
    }

    async generateHypotheses(url: string, projectId: string): Promise<HypothesesGenerationResult> {
        console.log(`[HYPOTHESES] Starting generation for URL: ${url}, Project: ${projectId}`);
        
        const toDataUrl = (b64: string): string => {
            if (!b64) return '';
            if (b64.startsWith('data:')) return b64;
            return `data:image/png;base64,${b64}`;
        };

        // Check storage first
        const pageType = this.getPageType(url);
        const cachedScreenshot = await this.screenshotStorage.getScreenshot(
            projectId, 
            pageType, 
            { viewport: { width: 1920, height: 1080 }, fullPage: true, quality: 80 }
        );
        
        let screenshot: string;
        if (cachedScreenshot) {
            console.log(`[HYPOTHESES] Using stored screenshot for ${pageType} page`);
            screenshot = cachedScreenshot;
        } else {
            console.log(`[HYPOTHESES] Taking new screenshot and HTML for ${url}`);
            const crawlResult = await this.crawlerService.crawlPage(url, {
                viewport: { width: 1920, height: 1080 },
                waitFor: 3000,
                screenshot: { fullPage: true, quality: 80 },
                authentication: { type: 'shopify_password', password: 'reitri', shopDomain: 'omen-mvp.myshopify.com' }
            });
            
            screenshot = crawlResult.screenshot || '';
            
            // Store the new screenshot and HTML
            if (crawlResult.html) {
                const simplifiedHtml = simplifyHTML(crawlResult.html);
                const screenshotId = await this.screenshotStorage.saveScreenshot(
                    projectId, 
                    pageType,
                    url, 
                    { viewport: { width: 1920, height: 1080 }, fullPage: true, quality: 80 },
                    screenshot,
                    simplifiedHtml
                );
                console.log(`[HYPOTHESES] Screenshot and HTML saved with ID: ${screenshotId} (${getHtmlInfo(simplifiedHtml)})`);
            } else {
                const screenshotId = await this.screenshotStorage.saveScreenshot(
                    projectId, 
                    pageType,
                    url, 
                    { viewport: { width: 1920, height: 1080 }, fullPage: true, quality: 80 },
                    screenshot
                );
                console.log(`[HYPOTHESES] Screenshot saved with ID: ${screenshotId}`);
            }
        }
        
        console.log(`[HYPOTHESES] Screenshot ready, length: ${screenshot.length}`);

        console.log(`[HYPOTHESES] Fetching brand analysis for project: ${projectId}`);
        const brandAnalysis = await ProjectDAL.getProjectBrandAnalysis(projectId);
        console.log(`[HYPOTHESES] Brand analysis result:`, brandAnalysis ? `length: ${brandAnalysis.length}` : 'null');
        
        if (!brandAnalysis) {
            console.warn(`[HYPOTHESES] No brand analysis found for project: ${projectId}`);
            throw new Error(`No brand analysis available for project ${projectId}. Please run brand analysis first.`);
        }

        console.log(`[HYPOTHESES] Generating AI response with Google Gemini`);
        const aiConfig = getAIConfig();
        const result = await generateObject({
            model: google(aiConfig.model),
            schema: hypothesesResponseSchema,
            messages: [
                {
                    role: 'user',
                    content: [
                        { type: "text", text: this.buildHypothesesGenerationPrompt() },
                        { type: "text", text: brandAnalysis },
                        { type: "image", image: toDataUrl(screenshot) }
                    ]
                }
            ]
        });
        const response = result.object;
        console.log(`[HYPOTHESES] AI response generated: ${response.hypotheses.length} hypotheses`);
        return {
            hypothesesSchema: JSON.stringify(response)
        };

    }

    private buildHypothesesGenerationPrompt(): string {
        return `
You are an expert Conversion Rate Optimization (CRO) and UX/UI analyst. Your task is to analyze one or two screenshots of an e-commerce homepage or product detail page (PDP) from a Shopify store. Based on what you see, generate **one UI-focused hypothesis** that a merchant could test to improve conversions.

Your analysis must prioritize **clarity, testability, and accessibility**. You are not writing vague adviceyou are producing **hypotheses that can be tested in A/B experiments** without requiring advanced CRO expertise.

---

**Detailed Requirements:**

1. **Input:**

    * The brand summary of this specific brand
    * 1-2 screenshots (desktop or mobile).
        * Assume screenshots may be imperfect (poor resolution, overlay banners, missing or duplicated CTAs, etc.).
   
2. **Output:**
   For each hypothesis, return a structured object with:

   * **Hypothesis (plain language, evidence-based):** A short statement identifying the UI issue and suggesting a testable change.
   * **Rationale (why it matters):** A clear explanation of the UX or CRO principle being applied (e.g., visual hierarchy, CTA prominence, contrast, spacing, imagery clarity).
   * **Measurable Test:** Define what to test (e.g., Move primary CTA higher above the fold).
   * **Success Metrics (KPIs):** At least one quantifiable outcome, such as: CTR on CTA, Add-to-Cart rate, Conversion rate, Scroll depth, Engagement with product images.
   * **OEC (Overall Evaluation Criterion):** The primary metric that determines success (usually conversion rate or add-to-cart).
   * **Accessibility Check:** Flag issues like low color contrast, unreadable text, small tap targets, missing alt text, or hidden CTAs.

3. **Constraints:**

   * Produce **exactly 1 hypothesis** per set of screenshots.
   * Ensure recommendations are **UI-first** (not backend, pricing, or content strategy).
   * Handle edge cases gracefully:

     * If no CTA is visible, suggest adding one.
     * If multiple CTAs compete, suggest hierarchy improvements.
     * If screenshot quality is too poor to assess, return a fallback message: *Unable to reliably analyze this screenshot.*

4. **Style Guidelines:**

   * Use plain, non-jargon language understandable to merchants.
   * Be concise but specificmerchants should see exactly what they could test.
   * Avoid over-promising; these are hypotheses, not guarantees.`;
    }

    private getPageType(url: string): 'home' | 'pdp' | 'about' | 'other' {
        const urlLower = url.toLowerCase();
        
        // Check for product pages first
        if (urlLower.includes('/products/') || urlLower.includes('/collections/')) {
            return 'pdp';
        }
        
        // Check for about pages
        if (urlLower.includes('/about')) {
            return 'about';
        }
        
        // Check for home page - this should be the most common case
        // Home page is typically just the domain or domain with trailing slash
        const urlObj = new URL(url);
        const pathname = urlObj.pathname;
        
        // If no path or just a trailing slash, it's the home page
        if (!pathname || pathname === '/' || pathname === '') {
            return 'home';
        }
        
        // If path is just common home page indicators
        if (pathname === '/home' || pathname === '/index' || pathname === '/index.html') {
            return 'home';
        }
        
        return 'other';
    }
}
</file>

<file path="src/features/brand_analysis/brand-analysis.ts">
// Brand Analysis Service
import type { CrawlResult } from '@features/crawler';
import { createPlaywrightCrawler } from '@features/crawler';
import type { BrandAnalysisResponse } from './types';
import { ScreenshotAnalyzer } from './screenshot-analyzer';
import { LanguageAnalyzer } from './language-analyzer';
import { UrlSelector } from './url-selector';
import { ProjectDAL } from '@infra/dal';
import { PrismaClient } from '@prisma/client';
import { createScreenshotStorageService, ScreenshotStorageService } from '@services/screenshot-storage';
import { getServiceConfig } from '@infra/config/services';
import { simplifyHTML, getHtmlInfo } from '@shared/utils/html-simplifier';

export interface BrandAnalysisService {
  analyzeProject(projectId: string, shopDomain: string): Promise<BrandAnalysisResult>;
}

export interface BrandAnalysisResult {
  success: boolean;
  brandSummary?: BrandAnalysisResponse;
  error?: string;
}



export class BrandAnalysisServiceImpl implements BrandAnalysisService {
  private screenshotAnalyzer: ScreenshotAnalyzer;
  private languageAnalyzer: LanguageAnalyzer;
  // private codeAnalyzer: CodeAnalyzer; // Disabled for now
  private urlSelector: UrlSelector;
  private screenshotStorage: ScreenshotStorageService;

  constructor(
    prisma: PrismaClient
  ) {
    this.screenshotAnalyzer = new ScreenshotAnalyzer();
    this.languageAnalyzer = new LanguageAnalyzer();
    // this.codeAnalyzer = new CodeAnalyzer(); // Disabled for now
    this.urlSelector = new UrlSelector();
    this.screenshotStorage = createScreenshotStorageService(prisma);
  }


  async analyzeProject(projectId: string, shopDomain: string): Promise<BrandAnalysisResult> {
    // Create a new crawler instance for this analysis to avoid conflicts
    const config = getServiceConfig();
    const crawler = createPlaywrightCrawler(config.crawler);
    
    try {
      console.log(`[BRAND_ANALYSIS] Starting analysis for project ${projectId}, shop: ${shopDomain}`);
      const baseUrl = `https://${shopDomain}`;

      // 1) Crawl homepage
      console.log(`[BRAND_ANALYSIS] Crawling homepage: ${baseUrl}`);
      const homeResult = await crawler.crawlPage(baseUrl, {
        viewport: { width: 1920, height: 1080 },
        waitFor: 3000,
        screenshot: { fullPage: true, quality: 80 },
        authentication: shopDomain === 'omen-mvp.myshopify.com' ? {
          type: 'shopify_password',
          password: 'reitri',
          shopDomain: shopDomain
        } : undefined
      });

      if (homeResult.error) {
        console.error(`[BRAND_ANALYSIS] Homepage crawl failed: ${homeResult.error}`);
        throw new Error(`Homepage crawl failed: ${homeResult.error}`);
      }

      let candidates = [baseUrl];
      try {
        // Determine URLs to crawl
        const regex = /href="((?:\/[a-zA-Z0-9?\-=]+)+)\/*"/g;
        let m: RegExpExecArray | null;
        while ((m = regex.exec(homeResult.html)) !== null) {
          const path = m[1];
          candidates.push(`${baseUrl}${path}`);
        }
        console.log("Candidates:", candidates);
      } catch {
        candidates = this.buildCrawlUrls(shopDomain);
      }

      console.log(`[BRAND_ANALYSIS] Selecting URLs from ${candidates.length} candidates`);
      let response;
      try {
        response = await this.urlSelector.selectUrls(candidates);
        console.log(`[BRAND_ANALYSIS] URL selection completed:`, response);
      } catch (error) {
        console.error(`[BRAND_ANALYSIS] URL selection failed:`, error);
        throw new Error(`URL selection failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
      }

      const urlsWithTypes = this.urlSelector.getUrlsWithTypes(response);
      console.log(`[BRAND_ANALYSIS] Selected URLs to crawl:`, urlsWithTypes);

      // Check storage first for each URL
      const cachedScreenshots = new Map<string, string>();
      const urlsToCapture: Array<{ url: string, pageType: 'home' | 'pdp' | 'about' }> = [];

      for (const { url, pageType } of urlsWithTypes) {
        const cached = await this.screenshotStorage.getScreenshot(
          projectId,
          pageType,
          { viewport: { width: 1920, height: 1080 }, fullPage: true, quality: 80 }
        );

        if (cached) {
          cachedScreenshots.set(url, cached);
          console.log(`[BRAND_ANALYSIS] Using stored screenshot for ${pageType} page`);
        } else {
          urlsToCapture.push({ url, pageType });
        }
      }

      // Only capture screenshots for URLs not in cache
      let crawlResults: CrawlResult[] = [];
      if (urlsToCapture.length > 0) {
        console.log(`[BRAND_ANALYSIS] Capturing ${urlsToCapture.length} new screenshots`);
        try {
          crawlResults = await crawler.crawlMultiplePages(urlsToCapture.map(u => u.url), {
            viewport: { width: 1920, height: 1080 },
            waitFor: 3000, // Wait 3 seconds for dynamic content
            screenshot: {
              fullPage: true,
              quality: 80
            },
            authentication: shopDomain === 'omen-mvp.myshopify.com' ? {
              type: 'shopify_password',
              password: 'reitri',
              shopDomain: shopDomain
            } : undefined
          });
        } catch (crawlError) {
          console.error(`[BRAND_ANALYSIS] Error during screenshot capture:`, crawlError);
          // Continue with empty results - we'll still have the home page screenshot
          crawlResults = [];
        }

        // Store the new screenshots
        for (let i = 0; i < crawlResults.length; i++) {
          const result = crawlResults[i];
          const urlInfo = urlsToCapture[i];
          if (result.screenshot && urlInfo) {
            // Simplify HTML content before saving
            const simplifiedHtml = result.html ? simplifyHTML(result.html) : undefined;
            
            const screenshotId = await this.screenshotStorage.saveScreenshot(
              projectId,
              urlInfo.pageType,
              result.url,
              { viewport: { width: 1920, height: 1080 }, fullPage: true, quality: 80 },
              result.screenshot,
              simplifiedHtml
            );
            console.log(`[BRAND_ANALYSIS] Screenshot and HTML saved with ID: ${screenshotId} (${getHtmlInfo(simplifiedHtml)})`);
          }
        }
      }

      // Check for errors
      const errors = crawlResults.filter((result: CrawlResult) => result.error);
      if (errors.length > 0) {
        console.warn(`[BRAND_ANALYSIS] Crawl errors for project ${shopDomain}:`, errors.map((e: CrawlResult) => e.error));
      }

      console.log(`[BRAND_ANALYSIS] Crawl completed. ${crawlResults.length} pages crawled, ${errors.length} errors`);

      // Prepare data for analysis - combine cached and new screenshots
      const htmlContent = crawlResults.map((result: CrawlResult) => result.html);
      const screenshots = [
        ...cachedScreenshots.values(),
        ...crawlResults.map((result: CrawlResult) => result.screenshot).filter(s => s)
      ];
      // const urls = crawlResults.map((result: CrawlResult) => result.url);

      // Filter out empty screenshots and log the issue
      const validScreenshots = screenshots.filter(screenshot => screenshot && screenshot.trim() !== '');
      if (validScreenshots.length !== screenshots.length) {
        console.warn(`[BRAND_ANALYSIS] ${screenshots.length - validScreenshots.length} screenshots are empty or corrupted`);
      }

      // Run separate analyses in parallel
      console.log(`[BRAND_ANALYSIS] Starting analysis of ${validScreenshots.length} screenshots and ${htmlContent.length} HTML pages`);

      // Only add screenshot analysis if we have valid screenshots
      let screenshotAnalysis;
      if (validScreenshots.length > 0) {
        screenshotAnalysis = await this.screenshotAnalyzer.analyzeScreenshots(validScreenshots);
      } else {
        console.warn('[BRAND_ANALYSIS] No valid screenshots available, skipping screenshot analysis');
        // Add a placeholder for screenshot analysis
        screenshotAnalysis = {
          visualStyle: {
            overallAesthetic: 'Unable to analyze - no valid screenshots available',
            colorPalette: [],
            typography: 'Unable to analyze - no valid screenshots available',
            imagery: 'Unable to analyze - no valid screenshots available',
          },
          brandElements: {
            logo: 'Unable to analyze - no valid screenshots available',
            keyComponents: [],
            layout: 'Unable to analyze - no valid screenshots available',
          },
          brandPersonality: {
            adjectives: ['unknown'],
            targetAudience: 'Unable to analyze - no valid screenshots available',
          }
        };
      }

      // Run language analysis
      const languageAnalysis = await this.languageAnalyzer.analyzeLanguage(htmlContent);

      console.log(`[BRAND_ANALYSIS] Analysis completed, saving results...`);

      // Simply combine the three analyzer results
      const detailedAnalysis = {
        screenshot: screenshotAnalysis,
        language: languageAnalysis,
        // code: codeAnalysis,
      };

      await ProjectDAL.updateProjectBrandAnalysis(projectId, detailedAnalysis);
      console.log(`[BRAND_ANALYSIS] Brand analysis completed successfully for project ${projectId}`);

      return {
        success: true,
        brandSummary: detailedAnalysis,
      };
    } catch (error) {
      console.error(`Detailed brand analysis failed for project ${shopDomain}:`, error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred'
      };
    } finally {
      // Clean up the crawler instance
      try {
        await crawler.close();
      } catch (cleanupError) {
        console.warn(`[BRAND_ANALYSIS] Error closing crawler:`, cleanupError);
      }
    }
  }

  private buildCrawlUrls(shopDomain: string): string[] {
    const baseUrl = `https://${shopDomain}`;
    const urls = [baseUrl]; // Home page

    // For MVP, we'll try to find a product page by common patterns
    // In a real implementation, you might use Shopify API to get actual product URLs
    const commonProductPaths = [
      '/products',
      '/collections',
      '/collections/all',
      '/collections/featured'
    ];

    // Add common product page patterns
    commonProductPaths.forEach(path => {
      urls.push(`${baseUrl}${path}`);
    });

    return urls;
  }

}

// Factory function
export function createBrandAnalysisService(
  prisma: PrismaClient
): BrandAnalysisService {
  return new BrandAnalysisServiceImpl(prisma);
}
</file>

<file path="src/app/container.ts">
// Service Container for Dependency Injection
import { createPlaywrightCrawler, type CrawlerService } from '@features/crawler';
import { createAgentService, type AgentService, ECOMMERCE_AGENT_SYSTEM_PROMPT } from '@domain/agent';
import { createBrandAnalysisService, type BrandAnalysisService } from '@features/brand_analysis';
import { createHypothesesGenerationService, HypothesesGenerationService } from '@features/hypotheses_generation/hypotheses-generation';
import { createScreenshotStorageService, type ScreenshotStorageService } from '@services/screenshot-storage';
import { createScreenshotAnalyticsService, type ScreenshotAnalyticsService } from '@services/screenshot-analytics';
import { createJobCleanupService, type JobCleanupService } from '@services/job-cleanup';
import { getServiceConfig } from '@infra/config/services';
import { PrismaClient } from '@prisma/client';

class ServiceContainer {
  private services: Map<string, unknown> = new Map();
  private config = getServiceConfig();
  private prisma: PrismaClient;

  constructor() {
    this.prisma = new PrismaClient();
  }


  getCrawlerService(): CrawlerService {
    if (!this.services.has('crawler')) {
      const crawlerService = createPlaywrightCrawler(this.config.crawler);
      this.services.set('crawler', crawlerService);
    }
    return this.services.get('crawler') as CrawlerService;
  }
  
  //Release

  getBrandAnalysisService(): BrandAnalysisService {
    if (!this.services.has('brandAnalysis')) {
      const brandAnalysisService = createBrandAnalysisService(this.prisma);
      this.services.set('brandAnalysis', brandAnalysisService);
    }
    return this.services.get('brandAnalysis') as BrandAnalysisService;
  }


  getAgentService(): AgentService {
    if (!this.services.has('agent')) {
      const agentService = createAgentService({
        systemPrompt: ECOMMERCE_AGENT_SYSTEM_PROMPT,
        maxContextMessages: 20,
        enableToolCalls: true,
        enableWelcomeFlow: true,
      });
      this.services.set('agent', agentService);
    }
    return this.services.get('agent') as AgentService;
  }

  getHypothesisGenerator(): HypothesesGenerationService {
    if (!this.services.has('hypothesesGeneration')) {
      const crawler = this.getCrawlerService();
      const hypothesesGenerator = createHypothesesGenerationService(crawler, this.prisma);
      this.services.set('hypothesesGeneration', hypothesesGenerator);
    }
    return this.services.get('hypothesesGeneration') as HypothesesGenerationService;
  }

  getScreenshotStorageService(): ScreenshotStorageService {
    if (!this.services.has('screenshotStorage')) {
      const screenshotStorageService = createScreenshotStorageService(this.prisma);
      this.services.set('screenshotStorage', screenshotStorageService);
    }
    return this.services.get('screenshotStorage') as ScreenshotStorageService;
  }

  getJobCleanupService(): JobCleanupService {
    if (!this.services.has('jobCleanup')) {
      const jobCleanupService = createJobCleanupService(this.prisma);
      this.services.set('jobCleanup', jobCleanupService);
    }
    return this.services.get('jobCleanup') as JobCleanupService;
  }

  getScreenshotAnalyticsService(): ScreenshotAnalyticsService {
    if (!this.services.has('screenshotAnalytics')) {
      const screenshotAnalyticsService = createScreenshotAnalyticsService(this.prisma);
      this.services.set('screenshotAnalytics', screenshotAnalyticsService);
    }
    return this.services.get('screenshotAnalytics') as ScreenshotAnalyticsService;
  }


  async cleanup(): Promise<void> {
    // Cleanup any services that need it
    const crawler = this.services.get('crawler') as any;
    if (crawler && typeof crawler.close === 'function') {
      await crawler.close();
    }
    
    // Close Prisma client
    await this.prisma.$disconnect();
    
    this.services.clear();
  }
}

// Singleton instance
export const serviceContainer = new ServiceContainer();
</file>

<file path="src/interfaces/http/index.ts">
import type { FastifyInstance } from 'fastify/types/instance.js';
import { healthRoutes } from './health';
import { userRoutes } from './user/index';
import { userRegistrationRoutes } from './user/register';
import { shopifyRoutes } from './shopify';
import { chatRoutes } from './chat';
import { brandSummaryRoutes } from './project/brandSummary';
import { jobRoutes } from './project/jobs';
import { screenshotRoutes } from './screenshots';

export async function registerRoutes(fastify: FastifyInstance): Promise<void> {
    await fastify.register(healthRoutes);
    await fastify.register(userRoutes);
    await fastify.register(userRegistrationRoutes);
    await fastify.register(shopifyRoutes);
    await fastify.register(chatRoutes);
    await fastify.register(brandSummaryRoutes);
    await fastify.register(jobRoutes);
    await fastify.register(screenshotRoutes);
}
</file>

<file path="env.template">
# Environment Configuration Template
# Copy this file to .env for development or .env.prod for production

# Database Configuration
DATABASE_URL="postgresql://username:password@localhost:5432/omen_db"

# Auth0 Configuration
# Replace these with your actual Auth0 values
AUTH0_DOMAIN="omen-ux.eu.auth0.com"
AUTH0_AUDIENCE="https://api.omen.so"
AUTH0_ISSUER="https://omen-ux.eu.auth0.com/"

# Auth0 Management API Configuration
# These are needed for user management operations
AUTH0_M2M_CLIENT_ID="your-machine-to-machine-client-id"
AUTH0_M2M_CLIENT_SECRET="your-machine-to-machine-client-secret"

# Shopify Configuration
SHOPIFY_API_KEY="your-shopify-api-key"
SHOPIFY_API_SECRET="your-shopify-api-secret"
SHOPIFY_SCOPES="read_products,write_products,read_orders,write_orders"
SHOPIFY_REDIRECT_URI="http://localhost:3000/auth/shopify/callback"
SHOPIFY_HOST_NAME="your-shopify-host-name"
SHOPIFY_API_VERSION="2025-01"

# Encryption Configuration
ENCRYPTION_KEY="your-32-character-encryption-key-here"

# Cloudflare KV Configuration
CLOUDFLARE_ACCOUNT_ID="your-cloudflare-account-id"
CLOUDFLARE_NAMESPACE_ID="your-kv-namespace-id"
CLOUDFLARE_API_TOKEN="your-cloudflare-api-token"

# OpenAI Configuration (commented out - using Google Gemini instead)
# OPENAI_API_KEY="your-openai-api-key"
# OPENAI_MODEL="gpt-4o"
# OPENAI_TEMPERATURE="0.3"
# OPENAI_MAX_TOKENS="2000"

# Google Gemini Configuration
GOOGLE_API_KEY="your-google-api-key"
# Alternative: GOOGLE_GENERATIVE_AI_API_KEY="your-google-api-key"
GOOGLE_MODEL="gemini-2.5-flash"
GOOGLE_TEMPERATURE="0.7"
GOOGLE_MAX_TOKENS="1000"

# Crawler Configuration
CRAWLER_HEADLESS="true"
CRAWLER_VIEWPORT_WIDTH="1280"
CRAWLER_VIEWPORT_HEIGHT="720"
CRAWLER_TIMEOUT="30000"
CRAWLER_WAIT_FOR="2000"
CHROME_PATH="/usr/bin/chromium"

# PostHog Configuration
POSTHOG_API_KEY="your-posthog-api-key"
POSTHOG_PROJECT_ID="your-posthog-project-id"
POSTHOG_HOST="https://eu.posthog.com"
POSTHOG_TIMEOUT="10000"
POSTHOG_RETRY_ATTEMPTS="3"

# Server Configuration
NODE_ENV="development"
PORT=3000
HOST="0.0.0.0"

# Frontend Configuration
FRONTEND_URL="http://localhost:3000"
</file>

<file path="src/domain/agent/agent.ts">
// Agent Domain Service - Provider-agnostic conversation management
import { getToolsConfiguration } from './tools';
import { createEcommerceAgentSystemPrompt } from './prompts';
import { streamText, stepCountIs } from 'ai';
// import { openai } from '@ai-sdk/openai';
import { google } from '@ai-sdk/google';
import { getAIConfig, AI_CONFIGS } from '@shared/ai-config';
import type {
  AgentService,
  AgentConfig,
  ChatMessage,
} from './types';

export class AgentServiceImpl implements AgentService {
  private aiConfig: ReturnType<typeof getAIConfig>;

  constructor(
    private config: AgentConfig = {}
  ) {
    this.aiConfig = getAIConfig();
  }


  async sendMessageStream(message: string, projectId: string, conversationHistory?: any[]): Promise<{ stream: unknown; messageId: string }> {
    console.log(`[AGENT] Processing message: "${message.substring(0, 50)}${message.length > 50 ? '...' : ''}"`);
    if (conversationHistory) {
      console.log(`[AGENT] Using conversation history (${conversationHistory.length} messages)`);
    }

    // Build messages with system prompt
    const llmMessages: ChatMessage[] = [];

    // Add system prompt if configured
    if (this.config.systemPrompt) {
      llmMessages.push({
        role: 'system',
        content: this.config.systemPrompt,
      });
    }

    // Add conversation history if provided, otherwise just add the current message
    if (conversationHistory && conversationHistory.length > 0) {
      conversationHistory.forEach((msg) => {

        llmMessages.push({
          role: msg.role as 'user' | 'assistant' | 'system',
          content: msg.content,
          ...(msg.tool_calls && { tool_calls: msg.tool_calls }),
          ...(msg.tool_call_id && { tool_call_id: msg.tool_call_id }),
          ...(msg.tool_results && { tool_results: msg.tool_results }),
        });
      });
    } else {
      // Add user message if no conversation history
      llmMessages.push({
        role: 'user',
        content: message,
      });
    }

    // Prepare tools if enabled
    let llmOptions: { tools?: any } = {};
    let systemPrompt = this.config.systemPrompt;

    if (this.config.enableToolCalls) {
      const toolsConfig = getToolsConfiguration(projectId);
      // Generate dynamic system prompt based on available tools
      systemPrompt = createEcommerceAgentSystemPrompt(toolsConfig.availableTools);

      llmOptions = {
        tools: toolsConfig.tools,
      };

      console.log(`[AGENT] Tools enabled: ${toolsConfig.availableTools.join(', ')} for project ${projectId}`);
    }

    // Convert messages to AI SDK format
    const aiMessages = llmMessages.map((msg) => {
      const content = typeof msg.content === 'string'
        ? msg.content
        : msg.content
          .filter(block => block.type === 'text')
          .map(block => block.text || '')
          .join('');

      const aiMessage = {
        role: msg.role as 'user' | 'assistant' | 'system',
        content,
        ...(msg.tool_calls && { toolCalls: msg.tool_calls }),
        ...(msg.tool_call_id && { toolCallId: msg.tool_call_id }),
        ...((msg as any).tool_results && { toolResults: (msg as any).tool_results }),
      };

      // Log tool results in AI messages for debugging
      if ((msg as any).tool_results && (msg as any).tool_results.length > 0) {
        const toolResults = (msg as any).tool_results;
        console.log(`[AGENT] AI Message has ${toolResults.length} tool results:`, toolResults.map((tr: any) => ({
          tool_call_id: tr.tool_call_id,
          content_length: tr.content ? tr.content.length : 0,
          has_variants: tr.content && tr.content.includes('variantsSchema') ? 'Yes' : 'No'
        })));
      }
      
      // Log tool calls for debugging
      if (msg.tool_calls && msg.tool_calls.length > 0) {
        console.log(`[AGENT] AI Message has tool calls:`, msg.tool_calls.map(tc => tc.function.name).join(', '));
      }

      return aiMessage;
    });

    // Add system prompt if provided
    if (systemPrompt) {
      aiMessages.unshift({
        role: 'system',
        content: systemPrompt,
      });
    }

    // Use AI SDK streaming with tools enabled and multi-step calls
    const streamConfig: any = {
      model: google(this.aiConfig.model),
      messages: aiMessages,
      stopWhen: stepCountIs(3), // Allow up to 3 steps for multi-step tool calls
      ...AI_CONFIGS.STREAMING
    };

    if (llmOptions.tools) {
      streamConfig.tools = llmOptions.tools;
    }

    console.log(`[AGENT] Starting stream with ${aiMessages.length} messages and ${llmOptions.tools ? Object.keys(llmOptions.tools).length : 0} tools`);
    
    const result = streamText(streamConfig);

    // Create a message ID for the response
    const messageId = `msg-${Date.now()}`;

    console.log(`[AGENT] Stream created with message ID: ${messageId}`);
    return { stream: result, messageId };
  }
}

// Factory function
export function createAgentService(
  config?: AgentConfig
): AgentService {
  return new AgentServiceImpl(config);
}
</file>

<file path="src/features/crawler/playwright.ts">
// Playwright Web Crawler Service Implementation
import { chromium, Browser, Page } from 'playwright';
import type { CrawlerService, CrawlResult, CrawlOptions, CrawlerConfig } from './types';

export class PlaywrightCrawlerService implements CrawlerService {
  private browser: Browser | null = null;
  private config: CrawlerConfig;

  constructor(config: CrawlerConfig = {}) {
    this.config = {
      headless: true,
      defaultViewport: { width: 1280, height: 720 },
      defaultTimeout: 30000,
      defaultWaitFor: 2000,
      ...config
    };
  }

  async initialize(): Promise<void> {
    // Only create a new browser if one doesn't exist or is disconnected
    if (this.browser && this.browser.isConnected()) {
      return; // Browser is already running and connected
    }

    // Close existing browser if it exists but is disconnected
    if (this.browser) {
      try {
        await this.browser.close();
      } catch (error) {
        console.warn('[CRAWLER] Error closing disconnected browser:', error);
      }
    }

    this.browser = await chromium.launch({
      executablePath: process.env.CHROME_PATH || '/app/.chrome-for-testing/chrome-linux64/chrome',
      headless: this.config.headless,
      args: [
        '--disable-gpu',
        '--no-sandbox',
        '--disable-dev-shm-usage',
        '--single-process',
        '--disable-setuid-sandbox',
      ],
    });
  }

  async close(): Promise<void> {
    if (this.browser) {
      await this.browser.close();
      this.browser = null;
    }
  }

  async takePartialScreenshot(url: string, viewport: { width: number, height: number }, fullPage: boolean, authentication?: { type: 'shopify_password'; password: string, shopDomain: string }): Promise<string> {
    await this.initialize();

    if (!url.startsWith("https://")) {
      url = `https://${url}`;
    }

    if (!this.browser) {
      throw new Error('Browser not initialized');
    }

    const page = await this.browser.newPage();

    try {
      // Set viewport
      await page.setViewportSize(viewport);

      // Navigate to page
      await page.goto(url, { waitUntil: 'domcontentloaded' });
      await page.waitForLoadState('load', { timeout: 5000 }).catch(() => { });
      await page.waitForLoadState('networkidle', { timeout: 5000 }).catch(() => { });

      // Handle Shopify password authentication if needed
      if (authentication?.type === 'shopify_password') {
        await this.handleShopifyPasswordAuth(page, authentication);
      }


      await page.setExtraHTTPHeaders({
        'User-Agent': "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 Safari/537.36"
      });

      const lazyImagesLocator = page.locator('img[loading="lazy"]:visible');
      const lazyImages = await lazyImagesLocator.all();
      for (const lazyImage of lazyImages) {
        await lazyImage.scrollIntoViewIfNeeded();
      }

      page.evaluate((_) => window.scrollTo(0, 0), 0);
      await page.evaluate(() => {
        const selectors = ['.needsClick', '.needsclick'];
        for (const sel of selectors) {
          document.querySelectorAll(sel).forEach(el => (el as HTMLElement).remove());
        }
      });

      // Handle cookie consent banners and popups
      await this.dismissCookieBanners(page);

      // Take screenshot
      return (await page.screenshot({
        type: 'png',
        fullPage: fullPage,
        path: `ss-${viewport.height}.png`
      })).toString('base64');
    }
    catch (error) {
      console.error(`[CRAWLER] Screenshot failed for ${url}:`, error);
      console.error(`[CRAWLER] Error details:`, {
        name: error instanceof Error ? error.name : 'Unknown',
        message: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : undefined
      });
      throw error; // Re-throw to let caller handle
    }
    finally {
      await page.close();
    }

    return '';
  }

  private async handleShopifyPasswordAuth(page: import('playwright').Page, auth: { type: 'shopify_password'; password: string; shopDomain: string }): Promise<void> {
    try {
      // Check if we're on a Shopify password page by looking for the password input
      const passwordInput = await page.$('input[type="password"][id="password"][name="password"]');

      if (passwordInput) {
        console.log(`Detected Shopify password page for ${auth.shopDomain}, attempting to fill password`);

        // Fill in the password
        await passwordInput.fill(auth.password);

        // Find and click the submit button
        const submitButton = await page.$('button[type="submit"]');
        if (submitButton) {
          await submitButton.click();

          // Wait for navigation after form submission
          await page.waitForLoadState('load', { timeout: 10000 }).catch(() => { });
          await page.waitForLoadState('networkidle', { timeout: 5000 }).catch(() => { });

          console.log(`Successfully submitted password for ${auth.shopDomain}`);
        } else {
          console.warn(`Submit button not found for ${auth.shopDomain}`);
        }
      } else {
        console.log(`No password input found for ${auth.shopDomain}, proceeding without authentication`);
      }
    } catch (error) {
      console.error(`Error handling Shopify password authentication for ${auth.shopDomain}:`, error);
      // Don't throw the error, just log it and continue
    }
  }

  async crawlPage(url: string, options: CrawlOptions = {}): Promise<CrawlResult> {
    await this.initialize();

    if (!this.browser) {
      throw new Error('Browser not initialized');
    }

    const page = await this.browser.newPage();

    try {
      // Set viewport
      const viewport = options.viewport || this.config.defaultViewport!;
      await page.setViewportSize(viewport);

      // Set user agent if provided
      if (options.userAgent) {
        await page.setExtraHTTPHeaders({
          'User-Agent': options.userAgent
        });
      }

      // Set timeout
      const timeout = options.timeout || this.config.defaultTimeout!;
      page.setDefaultTimeout(timeout);

      // Navigate to page
      await page.goto(url, { waitUntil: 'domcontentloaded' });
      await page.waitForLoadState('load', { timeout: 5000 }).catch(() => { });
      await page.waitForLoadState('networkidle', { timeout: 3000 }).catch(() => { });

      // Handle Shopify password authentication if needed
      if (options.authentication?.type === 'shopify_password') {
        await this.handleShopifyPasswordAuth(page, options.authentication);
      }

      const lazyImagesLocator = page.locator('img[loading="lazy"]:visible');
      const lazyImages = await lazyImagesLocator.all();
      for (const lazyImage of lazyImages) {
        await lazyImage.scrollIntoViewIfNeeded();
      }

      page.evaluate((_) => window.scrollTo(0, 0), 0);
      await page.evaluate(() => {
        const selectors = ['.needsClick', '.needsclick'];
        for (const sel of selectors) {
          document.querySelectorAll(sel).forEach(el => (el as HTMLElement).remove());
        }
      });

      // Handle cookie consent banners and popups
      await this.dismissCookieBanners(page);

      // Wait additional time if specified
      const waitFor = options.waitFor || this.config.defaultWaitFor!;
      if (waitFor > 0) {
        await page.waitForTimeout(waitFor);
      }

      // Extract HTML content
      const html = await page.content();
      // Take screenshot
      const screenshot = await page.screenshot({
        type: 'png',
        fullPage: options.screenshot?.fullPage ?? true,
        // quality: options.screenshot?.quality ?? 80,
      });

      // Extract metadata
      const title = await page.title();
      const description = await page.$eval('meta[name="description"]', el => el.getAttribute('content')).catch(() => null);

      return {
        url,
        html,
        screenshot: screenshot.toString('base64'),
        title,
        description: description || undefined,
      };
    } catch (error) {
      console.error(error);
      return {
        url,
        html: '',
        screenshot: '',
        error: error instanceof Error ? error.message : 'Unknown error occurred',
      };
    } finally {
      await page.close();
    }
  }

  async crawlMultiplePages(urls: string[], options: CrawlOptions = {}): Promise<CrawlResult[]> {
    // Initialize browser once for all pages
    await this.initialize();

    if (!this.browser) {
      throw new Error('Browser not initialized');
    }

    const results: CrawlResult[] = [];

    for (const url of urls) {
      // Check if browser is still connected before creating new page
      if (!this.browser || !this.browser.isConnected()) {
        console.warn(`[CRAWLER] Browser disconnected, reinitializing for ${url}`);
        await this.initialize();
        if (!this.browser) {
          throw new Error('Failed to reinitialize browser');
        }
      }

      let page;
      let retries = 0;
      const maxRetries = 2;
      
      while (retries <= maxRetries) {
        try {
          page = await this.browser.newPage();
          break; // Success, exit retry loop
        } catch (error) {
          retries++;
          console.warn(`[CRAWLER] Failed to create page for ${url} (attempt ${retries}/${maxRetries + 1}):`, error);
          
          if (retries > maxRetries) {
            console.error(`[CRAWLER] Max retries exceeded for ${url}`);
            results.push({
              url,
              html: '',
              screenshot: '',
              error: `Failed to create page after ${maxRetries + 1} attempts: ${error instanceof Error ? error.message : 'Unknown error'}`,
            });
            break; // Exit retry loop and continue to next URL
          }
          
          // Wait a bit before retrying
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          // Try to reinitialize browser
          try {
            await this.initialize();
          } catch (initError) {
            console.error(`[CRAWLER] Failed to reinitialize browser:`, initError);
          }
        }
      }
      
      if (!page) {
        continue; // Skip this URL if we couldn't create a page
      }

      try {
        // Set viewport
        const viewport = options.viewport || this.config.defaultViewport!;
        await page.setViewportSize(viewport);

        // Set user agent if provided
        if (options.userAgent) {
          await page.setExtraHTTPHeaders({
            'User-Agent': options.userAgent
          });
        }

        // Set timeout
        const timeout = options.timeout || this.config.defaultTimeout!;
        page.setDefaultTimeout(timeout);

        // Navigate to page
        await page.goto(url, { waitUntil: 'domcontentloaded' });
        await page.waitForLoadState('load', { timeout: 5000 }).catch(() => { });
        await page.waitForLoadState('networkidle', { timeout: 3000 }).catch(() => { });

        // Handle Shopify password authentication if needed
        if (options.authentication?.type === 'shopify_password') {
          await this.handleShopifyPasswordAuth(page, options.authentication);
        }

        const lazyImagesLocator = page.locator('img[loading="lazy"]:visible');
        const lazyImages = await lazyImagesLocator.all();
        for (const lazyImage of lazyImages) {
          await lazyImage.scrollIntoViewIfNeeded();
        }

        page.evaluate((_) => window.scrollTo(0, 0), 0);
        await page.evaluate(() => {
          const selectors = ['.needsClick', '.needsclick'];
          for (const sel of selectors) {
            document.querySelectorAll(sel).forEach(el => (el as HTMLElement).remove());
          }
        });

        // Handle cookie consent banners and popups
        await this.dismissCookieBanners(page);

        // Wait additional time if specified
        const waitFor = options.waitFor || this.config.defaultWaitFor!;
        if (waitFor > 0) {
          await page.waitForTimeout(waitFor);
        }

        // Extract HTML content
        const html = await page.content();
        // Take screenshot
        const screenshot = await page.screenshot({
          type: 'png',
          fullPage: options.screenshot?.fullPage ?? true,
          // quality: options.screenshot?.quality ?? 80,
        });

        // Extract metadata
        const title = await page.title();
        const description = await page.$eval('meta[name="description"]', el => el.getAttribute('content')).catch(() => null);

        results.push({
          url,
          html,
          screenshot: screenshot.toString('base64'),
          title,
          description: description || undefined,
        });
      } catch (error) {
        console.error(`[CRAWLER] Error crawling ${url}:`, error);
        results.push({
          url,
          html: '',
          screenshot: '',
          error: error instanceof Error ? error.message : 'Unknown error occurred',
        });
      } finally {
        await page.close();
      }
    }

    return results;
  }

  /**
   * Apply variant code to a page and take a screenshot
   */
  async takeVariantScreenshot(
    url: string, 
    variant: {
      css_code: string;
      html_code: string;
      injection_method: 'selector' | 'new_element' | 'modify_existing';
      target_selector?: string;
      new_element_html?: string;
    },
    viewport: { width: number, height: number } = { width: 1920, height: 1080 },
    authentication?: { type: 'shopify_password'; password: string, shopDomain: string }
  ): Promise<string> {
    // Create a completely isolated browser instance for this variant
    const isolatedBrowser = await chromium.launch({
      executablePath: process.env.CHROME_PATH || '/app/.chrome-for-testing/chrome-linux64/chrome',
      headless: this.config.headless,
      args: [
        '--disable-gpu',
        '--no-sandbox',
        '--disable-dev-shm-usage',
        '--single-process',
        '--disable-setuid-sandbox',
        '--disable-background-timer-throttling',
        '--disable-backgrounding-occluded-windows',
        '--disable-renderer-backgrounding',
      ],
    });

    if (!url.startsWith("https://")) {
      url = `https://${url}`;
    }

    const page = await isolatedBrowser.newPage();

    try {
      // Set viewport
      await page.setViewportSize(viewport);

      // Navigate to page (refresh to ensure clean state)
      console.log(`[CRAWLER] Navigating to ${url} for variant: ${variant.target_selector || 'new_element'}`);
      await page.goto(url, { waitUntil: 'domcontentloaded' });
      await page.waitForLoadState('load', { timeout: 5000 }).catch(() => { });
      await page.waitForLoadState('networkidle', { timeout: 5000 }).catch(() => { });

      // Handle Shopify password authentication if needed
      if (authentication?.type === 'shopify_password') {
        await this.handleShopifyPasswordAuth(page, authentication);
      }
      
      // Clear any previous variant code to ensure clean state
      await this.clearPreviousVariantCode(page);

      await page.setExtraHTTPHeaders({
        'User-Agent': "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 Safari/537.36"
      });

      // Load lazy images
      const lazyImagesLocator = page.locator('img[loading="lazy"]:visible');
      const lazyImages = await lazyImagesLocator.all();
      for (const lazyImage of lazyImages) {
        await lazyImage.scrollIntoViewIfNeeded();
      }

      // Scroll to top
      await page.evaluate(() => window.scrollTo(0, 0));
      
      // Remove any existing overlay elements
      await page.evaluate(() => {
        const selectors = ['.needsClick', '.needsclick'];
        for (const sel of selectors) {
          document.querySelectorAll(sel).forEach(el => (el as HTMLElement).remove());
        }
      });

      // Handle cookie consent banners and popups
      await this.dismissCookieBanners(page);

      // Apply variant code
      console.log(`[CRAWLER] Applying variant code for selector: ${variant.target_selector}`);
      console.log(`[CRAWLER] Variant details:`, {
        css_code: variant.css_code,
        html_code: variant.html_code,
        injection_method: variant.injection_method,
        target_selector: variant.target_selector,
        new_element_html: variant.new_element_html
      });
      await this.applyVariantCode(page, variant);

      // Wait a bit for any animations or dynamic content to settle
      await page.waitForTimeout(1000);
      
      // Simple scrolling: Scroll to target element if it exists
      if (variant.target_selector) {
        try {
          const element = page.locator(variant.target_selector).first();
          const elementExists = await element.count();
          
          if (elementExists > 0) {
            console.log(`[CRAWLER] Scrolling to target element: ${variant.target_selector}`);
            
            // Simple approach: just scroll to the element
            await element.scrollIntoViewIfNeeded({ timeout: 5000 });
            console.log(`[CRAWLER] Successfully scrolled to element`);
            
            // Add small padding for better context
            await page.evaluate(() => {
              window.scrollBy(0, -100);
            });
          } else {
            console.log(`[CRAWLER] Target element not found: ${variant.target_selector}`);
          }
        } catch (scrollError) {
          console.warn(`[CRAWLER] Failed to scroll to element:`, scrollError);
        }
      }

      // Take screenshot
      let screenshot;
      try {
        screenshot = await page.screenshot({
          type: 'png',
          fullPage: false, // Use viewport for better focus
          path: `variant-${Date.now()}-partial.png`
        });
        console.log(`[CRAWLER] Screenshot taken for variant`);
      } catch (screenshotError) {
        console.warn(`[CRAWLER] Screenshot failed:`, screenshotError);
        // Fallback to full page screenshot if partial fails
        screenshot = await page.screenshot({
          type: 'png',
          fullPage: true,
          path: `variant-${Date.now()}-full.png`
        });
        console.log(`[CRAWLER] Full page screenshot taken as fallback`);
      }
      
      return screenshot.toString('base64');

    } catch (error) {
      console.error(`[CRAWLER] Variant screenshot failed for ${url}:`, error);
      throw error;
    } finally {
      await page.close();
      await isolatedBrowser.close();
    }
  }

  /**
   * Clear any previous variant code from the page to ensure clean state
   */
  private async clearPreviousVariantCode(page: Page): Promise<void> {
    console.log(`[CRAWLER] Clearing previous variant code`);
    
    // Remove any previously injected CSS styles
    await page.evaluate(() => {
      // Remove any style elements with variant-specific classes or IDs
      const variantStyles = document.querySelectorAll('style[data-variant], style[id*="variant"], style[class*="variant"]');
      variantStyles.forEach(style => style.remove());
      
      // Remove any injected elements with variant-specific classes
      const variantElements = document.querySelectorAll('[data-variant], [id*="variant"], [class*="variant"]');
      variantElements.forEach(el => {
        // Only remove if it's not a native element
        if (el.tagName.toLowerCase().startsWith('variant-') || el.hasAttribute('data-variant')) {
          el.remove();
        }
      });
      
      // Clear any custom CSS variables or classes that might have been added
      const body = document.body;
      if (body) {
        // Remove variant-specific classes from body
        const classList = Array.from(body.classList);
        classList.forEach(className => {
          if (className.includes('variant-') || className.includes('ab-test')) {
            body.classList.remove(className);
          }
        });
      }
    });
  }

  /**
   * Apply variant code to the page
   */
  private async applyVariantCode(
    page: import('playwright').Page, 
    variant: {
      css_code: string;
      html_code: string;
      injection_method: 'selector' | 'new_element' | 'modify_existing';
      target_selector?: string;
      new_element_html?: string;
    }
  ): Promise<void> {
    try {
      // Inject CSS
      if (variant.css_code) {
        console.log(`[CRAWLER] Injecting CSS: ${variant.css_code}`);
        await page.addStyleTag({ content: variant.css_code });
        console.log(`[CRAWLER] CSS injected successfully`);
      } else {
        console.log(`[CRAWLER] No CSS code to inject`);
      }

      // Apply HTML changes based on injection method
      switch (variant.injection_method) {
        case 'selector':
          if (variant.target_selector && variant.html_code) {
            // Validate that html_code doesn't contain JavaScript
            if (variant.html_code.includes('document.') || variant.html_code.includes('querySelector') || variant.html_code.includes('innerHTML =')) {
              console.warn(`[CRAWLER] Detected JavaScript code in html_code, skipping HTML injection: ${variant.html_code.substring(0, 100)}...`);
              break;
            }
            
            console.log(`[CRAWLER] Applying selector injection: ${variant.target_selector} with HTML: ${variant.html_code}`);
            try {
              await page.evaluate(({ selector, html }) => {
                const element = document.querySelector(selector);
                if (element) {
                  // Check if html_code contains HTML tags or is just text
                  if (html.includes('<') && html.includes('>')) {
                    // It's HTML content, use innerHTML
                    element.innerHTML = html;
                    console.log(`[CRAWLER] Successfully updated element innerHTML with HTML content`);
                  } else {
                    // It's plain text, use textContent or innerText
                    element.textContent = html;
                    console.log(`[CRAWLER] Successfully updated element textContent with plain text`);
                  }
                } else {
                  console.log(`[CRAWLER] Element not found with selector: ${selector}`);
                }
              }, { selector: variant.target_selector, html: variant.html_code });
              console.log(`[CRAWLER] Selector injection completed successfully`);
            } catch (selectorError) {
              console.warn(`[CRAWLER] Invalid selector in applyVariantCode: ${variant.target_selector}`, selectorError);
              // Try fallback selector
              const fallbackSelector = variant.target_selector
                .replace(/:contains\([^)]*\)/g, '')
                .replace(/\s+/g, ' ')
                .trim();
              
              if (fallbackSelector && fallbackSelector !== variant.target_selector) {
                try {
                  await page.evaluate(({ selector, html }) => {
                    const element = document.querySelector(selector);
                    if (element) {
                      // Check if html_code contains HTML tags or is just text
                      if (html.includes('<') && html.includes('>')) {
                        element.innerHTML = html;
                      } else {
                        element.textContent = html;
                      }
                    }
                  }, { selector: fallbackSelector, html: variant.html_code });
                  console.log(`[CRAWLER] Successfully applied variant using fallback selector: ${fallbackSelector}`);
                } catch (fallbackError) {
                  console.error(`[CRAWLER] Both original and fallback selectors failed:`, fallbackError);
                }
              }
            }
          }
          break;

        case 'new_element':
          if (variant.new_element_html) {
            console.log(`[CRAWLER] Applying new_element injection with HTML: ${variant.new_element_html}`);
            await page.evaluate((html) => {
              const tempDiv = document.createElement('div');
              tempDiv.innerHTML = html;
              const newElement = tempDiv.firstElementChild;
              if (newElement) {
                document.body.appendChild(newElement);
                console.log(`[CRAWLER] Successfully added new element to body`);
              } else {
                console.log(`[CRAWLER] Failed to create new element from HTML`);
              }
            }, variant.new_element_html);
            console.log(`[CRAWLER] New element injection completed`);
          } else {
            console.log(`[CRAWLER] No new_element_html provided for new_element injection`);
          }
          break;

        case 'modify_existing':
          if (variant.target_selector && variant.html_code) {
            console.log(`[CRAWLER] Applying modify_existing injection: ${variant.target_selector} with HTML: ${variant.html_code}`);
            try {
              await page.evaluate(({ selector, html }) => {
                const element = document.querySelector(selector);
                if (element) {
                  // For modify_existing, we might want to append or prepend
                  element.insertAdjacentHTML('beforeend', html);
                  console.log(`[CRAWLER] Successfully modified existing element`);
                } else {
                  console.log(`[CRAWLER] Element not found for modify_existing: ${selector}`);
                }
              }, { selector: variant.target_selector, html: variant.html_code });
              console.log(`[CRAWLER] Modify existing injection completed successfully`);
            } catch (selectorError) {
              console.warn(`[CRAWLER] Invalid selector in modify_existing: ${variant.target_selector}`, selectorError);
              // Try fallback selector
              const fallbackSelector = variant.target_selector
                .replace(/:contains\([^)]*\)/g, '')
                .replace(/\s+/g, ' ')
                .trim();
              
              if (fallbackSelector && fallbackSelector !== variant.target_selector) {
                try {
                  await page.evaluate(({ selector, html }) => {
                    const element = document.querySelector(selector);
                    if (element) {
                      element.insertAdjacentHTML('beforeend', html);
                    }
                  }, { selector: fallbackSelector, html: variant.html_code });
                  console.log(`[CRAWLER] Successfully applied modify_existing using fallback selector: ${fallbackSelector}`);
                } catch (fallbackError) {
                  console.error(`[CRAWLER] Both original and fallback selectors failed in modify_existing:`, fallbackError);
                }
              }
            }
          }
          break;
      }
    } catch (error) {
      console.error(`[CRAWLER] Failed to apply variant code:`, error);
      // Don't throw - we still want to take a screenshot even if code application fails
    }
  }

  /**
   * Dismiss common cookie consent banners and popups
   */
  private async dismissCookieBanners(page: Page): Promise<void> {
    try {
      console.log('[CRAWLER] Looking for cookie consent banners...');
      
      // Common cookie banner selectors and their corresponding accept/close buttons
      const cookieBannerSelectors = [
        // Generic cookie banners
        '[id*="cookie"]',
        '[class*="cookie"]',
        '[id*="consent"]',
        '[class*="consent"]',
        '[id*="gdpr"]',
        '[class*="gdpr"]',
        '[id*="privacy"]',
        '[class*="privacy"]',
        '[id*="banner"]',
        '[class*="banner"]',
        // Specific common selectors
        '.cookie-banner',
        '.cookie-notice',
        '.cookie-consent',
        '.gdpr-banner',
        '.privacy-banner',
        '.consent-banner',
        '#cookie-banner',
        '#cookie-notice',
        '#cookie-consent',
        '#gdpr-banner',
        '#privacy-banner',
        '#consent-banner',
        // Cookiebot
        '#CybotCookiebotDialog',
        // OneTrust
        '#onetrust-consent-sdk',
        // CookieYes
        '.cky-consent-container',
        // Cookiebot alternatives
        '.cc-window',
        '.cc-banner',
        // Generic popup/overlay selectors
        '[role="dialog"][aria-label*="cookie" i]',
        '[role="dialog"][aria-label*="consent" i]',
        '[role="dialog"][aria-label*="privacy" i]',
        '[role="dialog"][aria-label*="gdpr" i]',
      ];

      const acceptButtonSelectors = [
        // Generic accept buttons
        'button[class*="accept"]',
        'button[class*="agree"]',
        'button[class*="allow"]',
        'button[class*="consent"]',
        'button[id*="accept"]',
        'button[id*="agree"]',
        'button[id*="allow"]',
        'button[id*="consent"]',
        // Specific common selectors
        'button.accept-cookies',
        'button.accept-all',
        'button.agree-cookies',
        'button.allow-cookies',
        'button.consent-accept',
        'button.cookie-accept',
        'button.gdpr-accept',
        'button.privacy-accept',
        '#accept-cookies',
        '#accept-all',
        '#agree-cookies',
        '#allow-cookies',
        '#consent-accept',
        '#cookie-accept',
        '#gdpr-accept',
        '#privacy-accept',
        // Cookiebot
        '#CybotCookiebotDialogBodyLevelButtonLevelOptinAllowAll',
        '#CybotCookiebotDialogBodyButtonAccept',
        // OneTrust
        '#onetrust-accept-btn-handler',
        // CookieYes
        '.cky-btn-accept',
        // Generic close/accept buttons
        'button[aria-label*="accept" i]',
        'button[aria-label*="agree" i]',
        'button[aria-label*="allow" i]',
        'button[aria-label*="consent" i]',
        'button[aria-label*="close" i]',
        // Text-based selectors
        'button:has-text("Accept")',
        'button:has-text("Accept All")',
        'button:has-text("Agree")',
        'button:has-text("Allow")',
        'button:has-text("Allow All")',
        'button:has-text("Consent")',
        'button:has-text("I Accept")',
        'button:has-text("I Agree")',
        'button:has-text("OK")',
        'button:has-text("Got it")',
        'button:has-text("Continue")',
        'button:has-text("Close")',
        'button:has-text("Dismiss")',
        // Links that might be accept buttons
        'a[class*="accept"]',
        'a[class*="agree"]',
        'a[class*="allow"]',
        'a[class*="consent"]',
        'a:has-text("Accept")',
        'a:has-text("Accept All")',
        'a:has-text("Agree")',
        'a:has-text("Allow")',
        'a:has-text("Allow All")',
        'a:has-text("I Accept")',
        'a:has-text("I Agree")',
        'a:has-text("OK")',
        'a:has-text("Got it")',
        'a:has-text("Continue")',
      ];

      // Wait a bit for cookie banners to load
      await page.waitForTimeout(1000);

      // Look for cookie banners
      let bannerFound = false;
      for (const bannerSelector of cookieBannerSelectors) {
        try {
          const banner = page.locator(bannerSelector).first();
          const isVisible = await banner.isVisible().catch(() => false);
          
          if (isVisible) {
            console.log(`[CRAWLER] Found cookie banner with selector: ${bannerSelector}`);
            bannerFound = true;
            
            // Try to find and click accept button within this banner
            let buttonClicked = false;
            for (const buttonSelector of acceptButtonSelectors) {
              try {
                const button = banner.locator(buttonSelector).first();
                const buttonVisible = await button.isVisible().catch(() => false);
                
                if (buttonVisible) {
                  console.log(`[CRAWLER] Clicking accept button: ${buttonSelector}`);
                  await button.click();
                  buttonClicked = true;
                  break;
                }
              } catch (buttonError) {
                // Continue to next button selector
                continue;
              }
            }
            
            // If no button found within the banner, try clicking the banner itself
            if (!buttonClicked) {
              try {
                console.log(`[CRAWLER] No accept button found, trying to click banner itself`);
                await banner.click();
                buttonClicked = true;
              } catch (clickError) {
                console.log(`[CRAWLER] Could not click banner: ${clickError}`);
              }
            }
            
            if (buttonClicked) {
              // Wait for banner to disappear
              await page.waitForTimeout(500);
              console.log(`[CRAWLER] Cookie banner dismissed`);
              break;
            }
          }
        } catch (error) {
          // Continue to next banner selector
          continue;
        }
      }

      if (!bannerFound) {
        console.log('[CRAWLER] No cookie banners found');
      }

      // Additional cleanup: remove any remaining cookie-related elements
      await page.evaluate(() => {
        const cookieSelectors = [
          '[id*="cookie"]',
          '[class*="cookie"]',
          '[id*="consent"]',
          '[class*="consent"]',
          '[id*="gdpr"]',
          '[class*="gdpr"]',
          '[id*="privacy"]',
          '[class*="privacy"]',
          '[id*="banner"]',
          '[class*="banner"]',
        ];
        
        cookieSelectors.forEach(selector => {
          try {
            document.querySelectorAll(selector).forEach(el => {
              const element = el as HTMLElement;
              if (element.style.position === 'fixed' || 
                  element.style.position === 'absolute' ||
                  element.classList.contains('fixed') ||
                  element.classList.contains('absolute')) {
                element.remove();
              }
            });
          } catch (e) {
            // Ignore errors
          }
        });
      });

    } catch (error) {
      console.warn('[CRAWLER] Error dismissing cookie banners:', error);
      // Don't throw - we still want to continue with the screenshot
    }
  }
}

// Factory function for easy instantiation
export function createPlaywrightCrawler(config?: CrawlerConfig): PlaywrightCrawlerService {
  return new PlaywrightCrawlerService(config);
}
</file>

<file path="package.json">
{
  "name": "backend",
  "version": "1.0.0",
  "main": "dist/index.js",
  "scripts": {
    "dev": "tsx watch -r tsconfig-paths/register src/index.ts",
    "dev:watch": "tsx watch -r tsconfig-paths/register src/index.ts",
    "build": "tsc",
    "start": "tsx -r tsconfig-paths/register dist/index.js",
    "lint": "eslint src/",
    "lint:fix": "eslint src/ --fix",
    "check:unused": "ts-unused-exports tsconfig.json",
    "check:types": "tsc --noEmit",
    "check:all": "npm run check:types && npm run check:unused && npm run lint",
    "db:generate": "prisma generate",
    "db:migrate": "prisma migrate dev",
    "db:deploy": "prisma migrate deploy",
    "db:studio": "prisma studio",
    "seed": "tsx -r tsconfig-paths/register scripts/seed.ts",
    "seed:reset": "tsx -r tsconfig-paths/register scripts/seed.ts --reset",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "engines": {
    "node": "20.x",
    "npm": "10.x"
  },
  "dependencies": {
    "@ai-sdk/google": "^2.0.16",
    "@ai-sdk/langchain": "^1.0.52",
    "@ai-sdk/openai": "^2.0.30",
    "@assistant-ui/react": "^0.11.18",
    "@assistant-ui/react-data-stream": "^0.11.0",
    "@fastify/cors": "^11.1.0",
    "@prisma/client": "^6.16.1",
    "@shopify/admin-api-client": "^1.0.0",
    "@shopify/shopify-api": "^11.14.1",
    "@types/jsonwebtoken": "^9.0.10",
    "ai": "^5.0.44",
    "assistant-stream": "^0.2.29",
    "auth0": "^4.30.0",
    "dompurify": "^3.2.6",
    "dotenv": "^16.4.5",
    "fastify": "^5.6.0",
    "jsdom": "^26.1.0",
    "jsonwebtoken": "^9.0.2",
    "jwks-rsa": "^3.2.0",
    "node-fetch": "^3.3.2",
    "openai": "^5.20.1",
    "playwright": "^1.55.1",
    "posthog-node": "^5.8.4",
    "prisma": "^6.16.1",
    "tsconfig-paths": "^4.2.0",
    "tsx": "^4.20.5",
    "zod": "^3.25.76"
  },
  "devDependencies": {
    "@types/dompurify": "^3.0.5",
    "@types/jsdom": "^21.1.7",
    "@types/node": "^24.3.1",
    "@types/node-fetch": "^2.6.11",
    "@typescript-eslint/eslint-plugin": "^8.44.1",
    "@typescript-eslint/parser": "^8.44.1",
    "eslint": "^9.35.0",
    "pino-pretty": "^13.1.1",
    "ts-unused-exports": "^11.0.1",
    "typescript": "^5.9.2"
  }
}
</file>

</files>
